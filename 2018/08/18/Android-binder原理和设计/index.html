<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Binder驱动原理Binder驱动的核心是维护一个binder_proc类型的链表。里面记录了包括ServiceManager在内的所有Client信息，当Client去请求得到某个Service时，Binder驱动就去binder_proc中查找相应的Service返回给Client，同时增加当前Service的引用个数。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android binder原理和设计">
<meta property="og:url" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Last Order">
<meta property="og:description" content="Binder驱动原理Binder驱动的核心是维护一个binder_proc类型的链表。里面记录了包括ServiceManager在内的所有Client信息，当Client去请求得到某个Service时，Binder驱动就去binder_proc中查找相应的Service返回给Client，同时增加当前Service的引用个数。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_2.png">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_10.png">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_13.png">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_18.png">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_17.png">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_21.jpg">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_11.png">
<meta property="og:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_19.png">
<meta property="article:published_time" content="2018-08-18T00:54:24.000Z">
<meta property="article:modified_time" content="2018-11-05T14:13:05.848Z">
<meta property="article:author" content="不侯鸟">
<meta property="article:tag" content="binder">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_2.png">

<link rel="canonical" href="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android binder原理和设计 | Last Order</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Last Order</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">逐渐沦为面试准备博客。。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="不侯鸟">
      <meta itemprop="description" content="学习总结">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Last Order">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android binder原理和设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-18 08:54:24" itemprop="dateCreated datePublished" datetime="2018-08-18T08:54:24+08:00">2018-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-05 22:13:05" itemprop="dateModified" datetime="2018-11-05T22:13:05+08:00">2018-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android-framework/" itemprop="url" rel="index"><span itemprop="name">android_framework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Binder驱动原理"><a href="#Binder驱动原理" class="headerlink" title="Binder驱动原理"></a>Binder驱动原理</h2><p>Binder驱动的核心是维护一个binder_proc类型的链表。里面记录了包括ServiceManager在内的所有Client信息，当Client去请求得到某个Service时，Binder驱动就去binder_proc中查找相应的Service返回给Client，同时增加当前Service的引用个数。<a id="more"></a></p>
<p>Binder驱动是作为一个特殊字符型设备存在，设备节点为/dev/binder，遵循Linux设备驱动模型。在驱动实现过程中，主要通过binder_ioctl函数与用户空间的进程交换数据。BINDER_WRITE_READ用来读写数据，数据包中有个cmd用于区分不同的请求。<br>在binder_thread_write函数中调用binder_transaction函数来转发请求并返回结果，而binder_thread_read函数用于读取结果。。当服务进程收到请求时，binder_transaction函数会通过对象的handle找到对象所在进程，如果handle为0，就认为请求的是ServiceManager进程。</p>
<p>整个Binder的流程：</p>
<p><img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_2.png" alt="binder_2"></p>
<h2 id="对象的索引和映射"><a href="#对象的索引和映射" class="headerlink" title="对象的索引和映射"></a>对象的索引和映射</h2><p>Binder中有两种索引，一是本地进程地址空间的一个地址，另一个是一个抽象的32位句柄（HANDLE），它们之间是互斥的：所有的进程本地对象的索引都是本地进程的一个地址(address, ptr, binder)，所有的远程进程的对象的索引都是一个句柄（handle）。对于发送者进程来说，索引就是一个远端对象的一个句柄，当Binder对象数据被发送到远端接收进程时，远端接受进程则会认为索引是一个本地对象地址，因此从第三方的角度来说，尽管名称不同，对于一次Binder调用，两种索引指的是同一个对象，Binder驱动则负责两种索引的映射，这样才能把数据发送给正确的进程。</p>
<p>对于Android的Binder来说，对象的索引和映射是通过binder_node和binder_ref两个核心数据结构来完成的，对于Binder本地对象，对象的Binder地址保存在binder_node-&gt;ptr里，对于远程对象，索引就保存在binder_ref-&gt;desc里，每一个binder_node都有一个binder_ref对象与之相联系，他们就是是通过ptr和desc来做映射的，如下图：</p>
<p><img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_10.png" alt="binder_10"></p>
<p>Binder句柄:<br>句柄就是个简单的整数值，用来告诉Binder驱动我们想找的目标Binder实体是哪个。但是请注意，句柄只对发起端进程和Binder驱动有意义，A进程的句柄直接拿到B进程，是没什么意义的。也就是说，不同进程中指代相同Binder实体的句柄值可能是不同的。示意图如下：</p>
<p><img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_13.png" alt="binder_13"></p>
<p>ServiceManagerService 记录了所有系统service所对应的Binder句柄，它的核心功能就是维护好这些句柄值。后续，当用户进程需要获取某个系统service的代理时，SMS就会在内部按service名查找到合适的句柄值，并“逻辑上”传递给用户进程，于是用户进程会得到一个新的合法句柄值，这个新句柄值可能在数值上和SMS所记录的句柄值不同，然而，它们指代的却是同一个Service实体。句柄的合法性是由Binder驱动保证的，这一点我们不必担心</p>
<p>flat_binder_object就是进程间传递的Binder对象，每一个flat_binder_object对象内都有一个唯一的binder_node对象或者binder_ref对象.他们之间的查找过程如下：</p>
<p><img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_18.png" alt="binder_18"></p>
<p>如果发送的flat_binder_object.type=BINDER,</p>
<ol>
<li>在发送进程内查找flat_binder_object.binder对应的binder_node</li>
<li>如果找到则执行步骤4，否则执行步骤3</li>
<li>在发送进程内创建新的binder_node,binder_node.ptr=flat_binder_object.binder</li>
<li>在接收进程内查找binder_node对应的binder_ref,如果找到则执行步骤6，否则执行步骤5</li>
<li>在接收进程内创建新的binder_ref,binder_ref.node=binder_node,分配binder_ref.desc值</li>
<li>修改flat_binder_object.type=HANDLE（BINDER_TYPE_BINDER-&gt;BINER_TYPE_HANDLE；BINDER_TYPE_WEAK_BINDER-&gt;BINDER_TYPE_WEAK_HANDLE).</li>
<li>修改flat_binder_object.handle=binder_refs.desc</li>
</ol>
<p>如果发送的flat_binder_object.type=HANDLE,</p>
<ol>
<li> 在发送进程内查找flat_binder_object.handle对应的binder_ref,如果找到，执行步骤3，否则执行步骤2</li>
<li> 设置error为BR_FAILED_REPLY，执行步骤11（这里的设计，防止了Client通过蒙猜的方式进行非法通信</li>
<li> binder_ref.node.proc是否为接收进程，如果是，则执行步骤4，否则执行步骤7</li>
<li> 设置flat_binder_obecjt.type=BINDER（BINDER_TYPE_HANDLE-&gt;BINDER_TYPE_BINDER;  BINDER_TYPE_WEAK_HANDLE-&gt;BINDER_TYPE_WEAK_BINDER)</li>
<li> 设置flat_binder_object.binder=binder_ref.node.binder.</li>
<li> 设置flat_binder_object.cookies=binder_ref.node.cookies,执行步骤11</li>
<li> 在接收进程内超找对应的binder_ref，如果未找到，执行步骤8，否则执行步骤10</li>
<li> 在接收进程内创建新的binder_ref</li>
<li> 设置binder_ref(接收进程）.node=binder_ref(发送进程）.node,并分配binder_refs（接收进程）.desc</li>
<li> 设置flat_binder_object.handle=binder_ref（接收进程）.desc</li>
<li> 结束</li>
</ol>
<p>进程1的BpBinder在发起跨进程调用时，向binder驱动传入了自己记录的句柄值，binder驱动就会在“进程1对应的binder_proc结构”的引用树中查找和句柄值相符的binder_ref节点，一旦找到binder_ref节点，就可以通过该节点的node域找到对应的binder_node节点，这个目标binder_node当然是从属于进程2的binder_proc啦，不过不要紧，因为binder_ref和binder_node都处于binder驱动的地址空间中，所以是可以用指针直接指向的。目标binder_node节点的cookie域，记录的其实是进程2中BBinder的地址，binder驱动只需把这个值反映给应用层，应用层就可以直接拿到BBinder了。</p>
<h2 id="传输机制的大体运作"><a href="#传输机制的大体运作" class="headerlink" title="传输机制的大体运作"></a>传输机制的大体运作</h2><p>Binder IPC机制的大体思路是这样的，它将每次“传输并执行特定语义的”工作理解为一个小事务，既然所传输的数据是binder_transaction_data类型的，那么这种事务的类名可以相应地定为binder_transaction。系统中当然会有很多事务啦，那么发向同一个进程或线程的若干事务就必须串行化起来，因此binder驱动为进程节点（binder_proc）和线程节点（binder_thread）都设计了个todo队列。todo队列的职责就是“串行化地组织待处理的事务”。<br>下图绘制了一个进程节点，以及一个从属于该进程的线程节点，它们各带了两个待处理的事务（binder_transaction）：</p>
<p>这样看来，传输动作的基本目标就很明确了，就是想办法把发起端的一个binder_transaction节点，插入到目标端进程或其合适子线程的todo队列去。<br>可是，该怎么找目标进程和目标线程呢？基本做法是先从发起端的BpBinder开始，找到与其对应的binder_node节点，这个在前文阐述binder_proc的4棵红黑树时已经说过了，这里不再赘述。总之拿到目标binder_node之后，我们就可以通过其proc域，拿到目标进程对应的binder_proc了。如果偷懒的话，我们直接把binder_transaction节点插到这个binder_proc的todo链表去，就算完成传输动作了。当然，binder驱动做了一些更精细的调整。<br>binder驱动希望能把binder_transaction节点尽量放到目标进程里的某个线程去，这样可以充分利用这个进程中的binder工作线程。比如一个binder线程目前正睡着，它在等待其他某个线程做完某个事情后才会醒来，而那个工作又偏偏需要在当前这个binder_transaction事务处理结束后才能完成，那么我们就可以让那个睡着的线程先去做当前的binder_transaction事务，这就达到充分利用线程的目的了。反正不管怎么说，如果binder驱动可以找到一个合适的线程，它就会把binder_transaction节点插到它的todo队列去。而如果找不到合适的线程，还可以把节点插入目标binder_proc的todo队列。</p>
<p><img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_17.png" alt="binder_17"></p>
<h2 id="Binder-相关数据结构"><a href="#Binder-相关数据结构" class="headerlink" title="Binder 相关数据结构"></a>Binder 相关数据结构</h2><p>这一部分内容可以用到的时候再看,主要是数据的封装和解析<br><img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_21.jpg" alt="binder_21"></p>
<h3 id="flat-binder-object"><a href="#flat-binder-object" class="headerlink" title="flat_binder_object"></a>flat_binder_object</h3><p>进程间传输的数据被称为Binder对象（Binder Object），它是一个<code>flat_binder_object</code>，binder驱动接收和返回的数据中，如果有BpBinder或者BBinder，都会转成一个<code>flat_binder_object</code>对象，然后再进行赋值或者解析，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * This is the flattened representation of a Binder object for transfer</span></span><br><span class="line"><span class="comment">    * between processes.  The &#x27;offsets&#x27; supplied as part of a binder transaction</span></span><br><span class="line"><span class="comment">    * contains offsets into the data where these structures occur.  The Binder</span></span><br><span class="line"><span class="comment">    * driver takes care of re-writing the structure type and data as it moves</span></span><br><span class="line"><span class="comment">    * between processes.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span>  </span><br><span class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        type;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        flags;  </span><br><span class="line">    <span class="comment">/* 8 bytes of data. */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>  </span><br><span class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span>  </span><br><span class="line">        <span class="keyword">signed</span> <span class="keyword">long</span>    handle;        <span class="comment">/* remote object */</span>  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="comment">/* extra data associated with local object */</span>  </span><br><span class="line">    <span class="keyword">void</span>            *cookie;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>其中type表示类型,flags描述了传输方式，比如同步、异步等。Android定义了五个（三大类）Binder类型，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">enum</span> &#123;</span>  </span><br><span class="line">   BINDER_TYPE_BINDER      = B_PACK_CHARS(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, B_TYPE_LARGE),  </span><br><span class="line">   BINDER_TYPE_WEAK_BINDER  = B_PACK_CHARS(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, B_TYPE_LARGE),  </span><br><span class="line">   BINDER_TYPE_HANDLE    = B_PACK_CHARS(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, B_TYPE_LARGE),  </span><br><span class="line">   BINDER_TYPE_WEAK_HANDLE= B_PACK_CHARS(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, B_TYPE_LARGE),  </span><br><span class="line">   BINDER_TYPE_FD              = B_PACK_CHARS(<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, B_TYPE_LARGE),  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">transaction_flags</span> &#123;</span>  </span><br><span class="line">    TF_ONE_WAY    = <span class="number">0x01</span>,    <span class="comment">/* this is a one-way call: async, no return */</span>  </span><br><span class="line">    TF_ROOT_OBJECT    = <span class="number">0x04</span>,    <span class="comment">/* contents are the component&#x27;s root object */</span>  </span><br><span class="line">    TF_STATUS_CODE    = <span class="number">0x08</span>,    <span class="comment">/* contents are a 32-bit status code */</span>  </span><br><span class="line">    TF_ACCEPT_FDS    = <span class="number">0x10</span>,    <span class="comment">/* allow replies with file descriptors */</span>  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>忽略强弱引用的差异，type可以分为三类BINDER、HANDLE、FD。 </p>
<ul>
<li>type为BINDER类型时，flat_binder_object代表binder_node,flat_binder_object.binder等于相应binder_node.ptr，指向Service用户空间的BBinder。</li>
<li>type为HANDLE类型时，flat_binder_object代表binder_ref,flat_binder_object.handle等于相应binder_refs.desc,也就是等于Client用户空间BpBinder.handle。</li>
<li>type为FD类型时，flat_binder_object代表文件Binder，flat_binder_object.handle是文件在进程内的文件号。</li>
</ul>
<p>传输的数据是一个复用数据联合体，对于BINDER类型，数据就是一个binder本地对象，如果是HANDLE类型，这数据就是一个远程的handle对象。该如何理解本地binder对象和远程handle对象呢？其实它们都指向同一个对象，不过是从不同的角度来说。举例来说，假如A有个对象X，对于A来说，X就是一个本地的binder对象；如果B想访问A的X对象，这对于B来说，X就是一个handle。因此，从根本上来说handle和binder都指向X。本地对象还可以带有额外的数据，保存在cookie中。</p>
<h3 id="binder-node"><a href="#binder-node" class="headerlink" title="binder_node"></a>binder_node</h3><p><code>binder_node</code> 代表一个内核中的binder实体，每一个binder_node都关联到用户态的BBinder对象。Binder实体服务其实有两种，一是通过addService注册到ServiceManager中的服务，比如ActivityManagerService、PackageManagerService、PowerManagerService等，一般都是系统服务；还有一种是通过bindService拉起的一些服务，一般是开发者自己实现的服务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> debug_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span><span class="comment">//work.type=BINDER_WORK_NODE</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span><span class="comment">//binder_node通过本节点，链入到binder_proc的nodes成员所指向的红黑树中</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">dead_node</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span><span class="comment">//binder_node所属进程的binder_proc</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">refs</span>;</span><span class="comment">//binder_ref列表，储存了所有引用本binder_node的binder_ref</span></span><br><span class="line">	<span class="keyword">int</span> internal_strong_refs;<span class="comment">//指向本binder_node的强binder_ref计数</span></span><br><span class="line">	<span class="keyword">int</span> local_weak_refs;<span class="comment">//本地弱引用计数</span></span><br><span class="line">	<span class="keyword">int</span> local_strong_refs;<span class="comment">//本地强引用计数</span></span><br><span class="line">	<span class="keyword">void</span> __user *ptr;<span class="comment">//指向用户态Binder实例的指针，通常指向BBinder的弱引用</span></span><br><span class="line">	<span class="keyword">void</span> __user *cookie;<span class="comment">//自定义数据，通常为指向BBinder的指针</span></span><br><span class="line">	<span class="keyword">unsigned</span> has_strong_ref : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> pending_strong_ref : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> has_weak_ref : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> pending_weak_ref : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> has_async_transaction : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> accept_fds : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> min_priority : <span class="number">8</span>;<span class="comment">//最低优先级</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_todo</span>;</span><span class="comment">//异步binder</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-ref"><a href="#binder-ref" class="headerlink" title="binder_ref"></a>binder_ref</h3><p><code>binder_ref</code> 代表内核中的binder引用，用户态每一个有效的BpBinder都关联到特定的binder_ref。同时binder_ref总是关联到一个binder_node</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Lookups needed: */</span></span><br><span class="line">	<span class="comment">/*   node + proc =&gt; ref (transaction) */</span></span><br><span class="line">	<span class="comment">/*   desc + proc =&gt; ref (transaction, inc/dec ref) */</span></span><br><span class="line">	<span class="comment">/*   node =&gt; refs + procs (proc exit) */</span></span><br><span class="line">	<span class="keyword">int</span> debug_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_desc</span>;</span><span class="comment">//binder_ref通过本节点，链入到binder_proc的refs_by_desc所指向的红黑树中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_node</span>;</span><span class="comment">//同上，链入到binder_proc的refs_by_node所指向的红黑树中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node_entry</span>;</span><span class="comment">//binder_ref通过本节点，链入到binder_node的refs成员所指向的双向链表中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span><span class="comment">//所属的binder_proc</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span><span class="comment">//所指向的binder_node</span></span><br><span class="line">	<span class="keyword">uint32_t</span> desc;<span class="comment">//序号,等于BpBinder.mhandle</span></span><br><span class="line">	<span class="keyword">int</span> strong;<span class="comment">//强引用计数</span></span><br><span class="line">	<span class="keyword">int</span> weak;<span class="comment">//弱引用计数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span><span class="comment">//Binder死亡通知</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-proc"><a href="#binder-proc" class="headerlink" title="binder_proc"></a>binder_proc</h3><p>binder_proc代表了使用binder driver的process，保存了process的相关信息。binder driver会为每一个调用过open函数打开“dev/binder”文件的进程创建一个binder_proc.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//binder_proc的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span> <span class="comment">//全局binder_proc列表，双向列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span> <span class="comment">//binder_thread红黑树，process内使用binder driver的线程都会被保存在这颗红黑树中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span> <span class="comment">//binder_node（binder实体）红黑树，process所持有的binder_node都保存在这颗红黑树中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span><span class="comment">//binder_ref（binder引用）红黑树，process所持有的biner_refs都会保存在颗红黑树中，红黑树以binder_ref.desc排序</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span><span class="comment">//同refs_by_desc，不过以binder_ref.node排序</span></span><br><span class="line">	<span class="keyword">int</span> pid;<span class="comment">//进程号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span><span class="comment">//进程虚地址分配表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span><span class="comment">//进程描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span><span class="comment">//文件描述符列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">	<span class="keyword">int</span> deferred_work;</span><br><span class="line">	<span class="keyword">void</span> *buffer;<span class="comment">//binder缓冲区在内核态的地址</span></span><br><span class="line">	<span class="keyword">ptrdiff_t</span> user_buffer_offset;<span class="comment">//binder缓冲区在内核态地址与用户态地址的偏移量</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span><span class="comment">//binder_buffer列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span><span class="comment">//空闲binder_buffer红黑树</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span><span class="comment">//已分配binder_buffer红黑树</span></span><br><span class="line">	<span class="keyword">size_t</span> free_async_space;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span><span class="comment">//内存分配页表</span></span><br><span class="line">	<span class="keyword">size_t</span> buffer_size;<span class="comment">//binder缓冲区到大小</span></span><br><span class="line">	<span class="keyword">uint32_t</span> buffer_free;<span class="comment">//空闲的binder缓冲区</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span><span class="comment">//binder_work列表，等待被处理的binder_work</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait;<span class="comment">//linux内核等待队列，参考函数wait_event&amp;wake_up</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span></span><br><span class="line">	<span class="keyword">int</span> max_threads;<span class="comment">//最大线程数量</span></span><br><span class="line">	<span class="keyword">int</span> requested_threads;</span><br><span class="line">	<span class="keyword">int</span> requested_threads_started;</span><br><span class="line">	<span class="keyword">int</span> ready_threads;</span><br><span class="line">	<span class="keyword">long</span> default_priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-procs"><a href="#binder-procs" class="headerlink" title="binder_procs"></a>binder_procs</h3><p>binder_procs结构的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">HLIST_HEAD</span><span class="params">(binder_procs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>展开后得到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">binder_procs</span>  =</span> &#123; .first = <span class="literal">NULL</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>随着后续不断向binder_procs表中添加节点，这个表会不断加长，示意图如下：</p>
<p><img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_11.png" alt="binder_procs"></p>
<h3 id="binder-thread"><a href="#binder-thread" class="headerlink" title="binder_thread"></a>binder_thread</h3><p>binder_thread代表了binder_proc内的线程，保存了线程相关信息。binder driver会为每一个调用过ioctl函数操作“dev/binder”文件的线程创建binder_thread.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span><span class="comment">//线程所属进程的binder_proc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span><span class="comment">//binder_thread通过rb_node链入到binder_proc的threads成员指向的红黑树中</span></span><br><span class="line">    <span class="keyword">int</span> pid;<span class="comment">//线程号,为什么线程号也叫pid呢？</span></span><br><span class="line">    <span class="keyword">int</span> looper;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span><span class="comment">//暂存binder_transaction</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span><span class="comment">//binder_work列表，等待被处理的binder_work</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></span><br><span class="line">        <span class="comment">/* buffer. Used when sending a reply to a dead process that */</span></span><br><span class="line">        <span class="comment">/* we are also waiting on */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;<span class="comment">//linux内核等待队列，参考函数wait_event&amp;wake_up</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-write-read"><a href="#binder-write-read" class="headerlink" title="binder_write_read"></a>binder_write_read</h3><p>binder_write_read为BINDER_WRITE_READ指定的数据类型，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">long</span>	write_size;	<span class="comment">/* bytes to write */</span></span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">long</span>	write_consumed;	<span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	write_buffer;</span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">long</span>	read_size;	<span class="comment">/* bytes to read */</span></span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">long</span>	read_consumed;	<span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-transaction-data"><a href="#binder-transaction-data" class="headerlink" title="binder_transaction_data"></a>binder_transaction_data</h3><p>binder_transaction_data为写入协议BC_TRANSACTION、BC_REPLY以及读出协议BR_TRANSACTION、BR_REPLY所指定的数据类型，Binder驱动的使用者（e.i. Client、Service、Service Manager）通过binder_transaction_data和Binder driver进行数据交换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></span><br><span class="line"><span class="comment">	 * identifying the target and contents of the transaction.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">size_t</span>	handle;	<span class="comment">/* target descriptor of command transaction */</span></span><br><span class="line">		<span class="keyword">void</span>	*ptr;	<span class="comment">/* target descriptor of return transaction */</span></span><br><span class="line">	&#125; target;</span><br><span class="line">	<span class="keyword">void</span>		*cookie;	<span class="comment">/* target object cookie */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	code;		<span class="comment">/* transaction command */</span> <span class="comment">//Service自定义的指令码，以SeviceManager的addService为函数例的话，code=ADD_SERVICE_TRANSACTION</span></span><br><span class="line">	<span class="comment">/* General information about the transaction. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	flags; <span class="comment">//TF_ACCEPT_FDS TF_ONE_WAY</span></span><br><span class="line">	<span class="keyword">pid_t</span>		sender_pid; <span class="comment">//发送方进程id</span></span><br><span class="line">	<span class="keyword">uid_t</span>		sender_euid; <span class="comment">//发送方用户id</span></span><br><span class="line">	<span class="keyword">size_t</span>		data_size;	<span class="comment">/* number of bytes of data */</span></span><br><span class="line">	<span class="keyword">size_t</span>		offsets_size;	<span class="comment">/* number of bytes of offsets */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this transaction is inline, the data immediately</span></span><br><span class="line"><span class="comment">	 * follows here; otherwise, it ends with a pointer to</span></span><br><span class="line"><span class="comment">	 * the data buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">			<span class="comment">/* transaction data */</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">void</span>	*buffer; </span><br><span class="line">			<span class="comment">/* offsets from buffer to flat_binder_object structs */</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">void</span>	*offsets;</span><br><span class="line">		&#125; ptr;</span><br><span class="line">		<span class="keyword">uint8_t</span>	buf[<span class="number">8</span>];</span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就像注释中说明的那样，target成员和cookie成员仅在BC_TRANSACTION和BR_TRANSACTION协议中使用。通常，Client使用BC_TRANSACTION协议写入数据时，需要通过target.handle指定数据接收方。而Service读取到BR_TRANSACTION的binder_transaction_data.ptr成员保存了用户空间binder实体的地址（实际上，BBinder的弱引用地址），而cookie成员保存了用户数据（实际上，cookie才真正保存了BBinder的地址）。而使用BC_REPLY写入时，Binder driver忽略这两个参数，而读取到BR_REPLY的 binder_transaction_data的target和cookie成员则恒为空。 </p>
<p>最后，也是对于理解binder_transaction_data最重要的一点，binder_transaction_data结构体，并不包含传输的数据，而是通过其ptr.buffer成员保存了数据的内存地址。而ptr.offsets成员则保存了Binder对象（或者说flat_binder_object）在ptr.buffer的偏移量数组的首地址。data_size成员则记录了数据的长度，offsets_size则是编译量数组的长度（以字节为单位，所以，编译量数组实际的长度是offsets_size/4)。</p>
<h2 id="binder-用户接口"><a href="#binder-用户接口" class="headerlink" title="binder 用户接口"></a>binder 用户接口</h2><ol>
<li><p><code>binder_open()</code> </p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">    . . . . . .</span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    . . . . . .</span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    . . . . . .</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    . . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 主要做了以下几件事情：</p>
<ol>
<li>首先，binder驱动分配内存以保存binder_proc数据结构。然后，binder填充binder_proc数据（初始化），增加当前线程/进程的引用计数并赋值给tsk</li>
<li>增加BINDER_STAT_PROC的对象计数，并把创建的binder_proc对象添加到全局的binder_procs中，这样任何一个进程就都可以访问到其他进程的binder_proc对象了。</li>
<li>把binder_proc对象指针赋值给filp的private_data域中，在后面每次执行binder_ioctl()，都会从filp-&gt;private_data域重新读取binder_proc。</li>
</ol>
</li>
<li><p><code>binder_mmap()</code><br> 内存的映射：<br> <img src="Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/binder_19.png" alt="binder_19"></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//需要映射的内核空间地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="comment">//取出binder_open时保存的binder_proc数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证这块内存最多只有4M  </span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请一段内存空间给内核进程</span></span><br><span class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到映射的内核空间虚拟地址首地址</span></span><br><span class="line">    proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">    <span class="comment">//计算用户空间与映射的内核空间的地址偏移量</span></span><br><span class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到映射地址的页数</span></span><br><span class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">    <span class="comment">//映射空间的大小</span></span><br><span class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为虚拟地址空间proc-&gt;buffer ~ proc-&gt;buffer + PAGE_SIZE  分配一个空闲的物理页面</span></span><br><span class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">&quot;alloc small buf&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = proc-&gt;buffer;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</span><br><span class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    binder_insert_free_buffer(proc, buffer);</span><br><span class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">    barrier();</span><br><span class="line">    proc-&gt;files = get_files_struct(current);</span><br><span class="line">    proc-&gt;vma = vma;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_alloc_small_buf_failed:</span><br><span class="line">    kfree(proc-&gt;pages);</span><br><span class="line">    proc-&gt;pages = <span class="literal">NULL</span>;</span><br><span class="line">err_alloc_pages_failed:</span><br><span class="line">    vfree(proc-&gt;buffer);</span><br><span class="line">    proc-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">err_get_vm_area_failed:</span><br><span class="line">err_already_mapped:</span><br><span class="line">err_bad_arg:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_proc *proc, <span class="keyword">int</span> allocate, <span class="keyword">void</span> *start, <span class="keyword">void</span> *end, struct vm_area_struct *vma)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *page_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> <span class="title">tmp_area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">//以页为单位分配物理页面，由于此时的end=start+PAGE_SIZE，因此只会循环一次</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page_array_ptr</span>;</span></span><br><span class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配物理页面</span></span><br><span class="line">        *page = alloc_page(GFP_KERNEL | __GFP_ZERO);</span><br><span class="line">        <span class="keyword">if</span> (*page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err_alloc_page_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_area.addr = page_addr;</span><br><span class="line">        tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>;</span><br><span class="line">        page_array_ptr = page;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把这个物理页面插入到内核空间去</span></span><br><span class="line">        ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err_map_kernel_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        user_page_addr = (<span class="keyword">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将这个物理页面插入到进程地址空间去</span></span><br><span class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err_vm_insert_page_failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>binder_ioctl()</code><br> 这个函数是Binder的最核心部分，Binder的功能就是通过ioctl命令来实现的。Binder的ioctl命令共有7个，定义在ioctl.h头文件中：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ               _IOWR(<span class="meta-string">&#x27;b&#x27;</span>, 1, struct binder_write_read)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT         _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 3, int64_t)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS          _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 5, size_t)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY        _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 6, int)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR          _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 7, int)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT              _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 8, int)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION                  _IOWR(<span class="meta-string">&#x27;b&#x27;</span>, 9, struct binder_version)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 首先是BINDER_SET_IDLE_TIMEOUT 和 BINDER_SET_IDLE_PRIORITY在目前的Binder驱动中没有实现。</p>
<ol>
<li><p>BINDER_SET_MAX_THREADS</p>
<p> 这个ioctl命令用于设置进程的Biner对象所支持的最大线程数。设置的值保存在binder_proc结构的max_threads成员里。</p>
</li>
<li><p>BINDER_SET_CONTEXT_MGR</p>
<p> 从功能上看，只有一个进程/线程能成功设置binder_context_mgr_node对象，这个进程被称为Context Manager（context_mgr）。当然，也只有创建binder_context_mgr_node对象的Binder上下文管理进程/线程才有权限重新设置这个对象。进程的权限（cred-&gt;euid）保存在binder_context_mgr_uid对象里。</p>
<p> 从接口的角度来说，这是一个进程想要成为一个Context Manager的唯一接口。一个Context Manager进程需要为binder_proc创建一个binder_node类型的节点。节点是通过binder_new_node函数来创建的，我们在后面在详细讲解这个函数。节点创建成功后内核会初始化节点的部分数据（weak_ref和strong_ref）</p>
<p> 对于ContextManager对象来说，binder_node是binder_context_mgr_node，这个是全局变量；这个binder对象的索引（handler）固定为0</p>
</li>
<li><p>BINDER_THREAD_EXIT</p>
<p> 通过调用binder_free_thread终止并释放binder_thread对象及其binder_transaction事务。</p>
</li>
<li><p>BINDER_VERSION<br> 读取当前Binder驱动支持的协议版本号。</p>
</li>
<li><p>BINDER_WRITE_READ</p>
<p> 这个ioctl命令是Binder最核心的部分，Android Binder的IPC机制就是通过这个接口来实现的。</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>引用：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/adaa1a39a274">听说你Binder机制学的不错，来面试下这几个问题</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/6618363">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/9316987">深入分析Android Binder 驱动</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/youranhongcha/blog/152233">红茶一杯话Binder</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/binder/" rel="tag"># binder</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/08/14/Android-wms%E6%80%BB%E7%BB%93/" rel="prev" title="Android-wms总结">
      <i class="fa fa-chevron-left"></i> Android-wms总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/08/20/Android%E6%8E%A7%E4%BB%B6%E6%80%BB%E7%BB%93/" rel="next" title="Android控件总结(显示流程，触摸事件派发)">
      Android控件总结(显示流程，触摸事件派发) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">Binder驱动原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E6%98%A0%E5%B0%84"><span class="nav-number">2.</span> <span class="nav-text">对象的索引和映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6%E7%9A%84%E5%A4%A7%E4%BD%93%E8%BF%90%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">传输机制的大体运作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder-%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">Binder 相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flat-binder-object"><span class="nav-number">4.1.</span> <span class="nav-text">flat_binder_object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-node"><span class="nav-number">4.2.</span> <span class="nav-text">binder_node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-ref"><span class="nav-number">4.3.</span> <span class="nav-text">binder_ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-proc"><span class="nav-number">4.4.</span> <span class="nav-text">binder_proc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-procs"><span class="nav-number">4.5.</span> <span class="nav-text">binder_procs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-thread"><span class="nav-number">4.6.</span> <span class="nav-text">binder_thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-write-read"><span class="nav-number">4.7.</span> <span class="nav-text">binder_write_read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-transaction-data"><span class="nav-number">4.8.</span> <span class="nav-text">binder_transaction_data</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binder-%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">binder 用户接口</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不侯鸟"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">不侯鸟</p>
  <div class="site-description" itemprop="description">学习总结</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nangonghuang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nangonghuang" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/jzlandon/" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;jzlandon&#x2F;" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://powman.org/" title="http:&#x2F;&#x2F;powman.org&#x2F;" rel="noopener" target="_blank">angryPowman</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不侯鸟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
