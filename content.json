{"meta":{"title":"Last Order","subtitle":null,"description":null,"author":"不侯鸟","url":"http://example.com"},"pages":[{"title":"categories","date":"2017-11-14T03:48:50.000Z","updated":"2017-11-14T04:17:17.017Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-11-14T03:54:49.000Z","updated":"2021-01-23T03:21:36.707Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于我"},{"title":"tags","date":"2017-11-14T04:15:52.000Z","updated":"2017-11-14T04:35:11.055Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java内存模型","slug":"Java内存模型","date":"2021-01-24T07:41:11.000Z","updated":"2021-01-24T09:25:30.147Z","comments":true,"path":"2021/01/24/Java内存模型/","link":"","permalink":"http://example.com/2021/01/24/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"Java 内存模型1. Java内存模型是为了解决什么问题 缓存一致性问题 在现代计算机中，并发的处理任务是一个很常见的场景，但是并发的处理任务，就涉及到处理器和存储设备之间的数据交换，由于处理器运算速度远远的大于存储设备，所以不得不设计了多层次的缓冲，比如磁盘，内存，高速缓存。在程序运行的过程中，处理器需要把数据从内存读到高速缓存中，然后进行运算，之后需要把运算结果再从缓存写到内存中。","text":"Java 内存模型1. Java内存模型是为了解决什么问题 缓存一致性问题 在现代计算机中，并发的处理任务是一个很常见的场景，但是并发的处理任务，就涉及到处理器和存储设备之间的数据交换，由于处理器运算速度远远的大于存储设备，所以不得不设计了多层次的缓冲，比如磁盘，内存，高速缓存。在程序运行的过程中，处理器需要把数据从内存读到高速缓存中，然后进行运算，之后需要把运算结果再从缓存写到内存中。 而多处理器系统中，每个处理器都有自己的高速缓存，它们又共用一个主存，假如多个处理器的运算任务涉及到同一块主存地址，那么到底哪一个高速缓存的值才是我们想要的呢？这种情况下就可能会带来内存一致性的问题。为了解决这个问题，Java虚拟机规范中定义了一种内存模型，试图屏蔽掉各种硬件和操作系统的内存访问差异，以达到跨平台一致性的效果。 指令重排序问题： 为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。 2.Java内存模型Java内存模型的主要目标是定义程序中各个变量的访问规则，规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存中保存了该线程用到的变量的主内存副本拷贝，线程不能直接读写主内存中的变量，不同的线程之间也无法访问对方工作内存中的变量，线程之间的变量值传递需要通过主存来完成，他们的关系如下： 注意这里和前面的图的区别，前面的图是具体的硬件，这里是对前面的图的一种抽象 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成： lock（锁定） unlock（解锁） read（读取） load（载入） use（使用） assign（赋值） store（存储） write（写入） 3. 原子性 可见性和有序性Java 内存模型主要围绕着在并发过程中如何处理原子性可见性和有序性这3个特征来建立的： 原子性 内存模型规定的八种操作都可以保证原子性。如果应用需要更大范围的原子性，可以使用lock和unlock，体现在代码伤就是 synchronized关键字 可见性 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。 有序性 Java程序中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）。 Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性： volatile关键字本身就包含了禁止指令重排序的语义 synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入 4. 对于volatile变量的特殊规则volatile变量的两个语义： 保证此变量对所有线程的可见性 这里的可见性是指当一条线程修改了这个变量的值，新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。但是可见性并不能完全保证volatile变量就是完全同步的。比如我们在A，B两个个线程中分别对一个 volatile变量做++的操作，假如这个变量的值是1，AB同时读到都是1，A线程做了++操作变成了2写入到主内存中，B可能之前已经从主存读了这个1的值也在++，然后得到2，最后结果是执行了两次++操作，但是得到了2 禁止指令重排序优化 主要是通过 volatile变量在赋值后，增加一句内存屏障的指令来实现的，在做重排序的时候，不能把后面的指令重排序到内存屏障之前的位置。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","permalink":"http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"mac下尝试zsh","slug":"mac下尝试zsh","date":"2018-12-27T17:39:58.000Z","updated":"2021-01-23T06:16:44.025Z","comments":true,"path":"2018/12/28/mac下尝试zsh/","link":"","permalink":"http://example.com/2018/12/28/mac%E4%B8%8B%E5%B0%9D%E8%AF%95zsh/","excerpt":"这几天尝试了一下 zsh，是linux shell 的一种","text":"这几天尝试了一下 zsh，是linux shell 的一种，mac下默认提供了六种shell，可以通过 1cat /etc/shells 查看， 12345678910# List of acceptable shells for chpass(1).# Ftpd will not allow users to connect who are not using# one of these shells./bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh 默认使用的bash，这也是大多数linux发行版的默认选择，zsh是另外一种shell，关于它们的不同，可以自行搜索。 mac上虽然自带了zsh，但是用zsh --version查看版本可以发现还是几年前的比较老的版本，于是想安装最新的版本，但是好像没法update ,只能自己另外安装，下面是安装步骤： 先安装 homebrew 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 来源于官网 https://brew.sh/ 安装zsh 1brew install zsh zsh-completions 来源：https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH 添加刚刚安装的zsh路径到系统记录查看当前系统的shell 1cat /etc/shells 我们添加刚刚下载的新的zsh路径/usr/local/bin/zsh到最下面一行 1vim /etc/shells …(vim操作自行研究) 添加完成后再次查看 12345678910111213&gt;&gt; cat /etc/shells# List of acceptable shells for chpass(1).# Ftpd will not allow users to connect who are not using# one of these shells./bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh/usr/local/bin/zsh 设置为/usr/local/bin/zsh为默认的shell 1chsh -s /usr/local/bin/zsh 不要漏了上面第3步，否则会提示 chsh: /usr/local/bin/zsh: non-standard shell, 确认设置成功：关闭终端重新打开， 12echo #SHELL // 应该显示的是 /usr/local/bin/zsh#SHELL --version // 应该显示的是最新的版本，比如 5.6.x 安装 oh-my-zsh 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 来源：https://github.com/robbyrussell/oh-my-zsh 安装成功后可以看到 12345678910 __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_ / __ \\/ __ \\ / __ `__ \\/ / / / /_ / / ___/ __ \\ / /_/ / / / / / / / / / / /_/ / / /_(__ ) / / / \\____/_/ /_/ /_/ /_/ /_/\\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh. p.p.s. Get stickers and t-shirts at https://shop.planetargon.com. 设置主题 1vim ~/.zshrc 修改 ZSH_THEME 设置主题 ，比如 ys, 执行 1source ~/.zshrc 使它生效 因为我们使用了新的shell，所以之前设置的环境变量和设置都无效了，所以还需要把之前的设置拷贝过来，之前的设置都在文件~/.bash_profile里，拷贝到~/.zshrc中 背景色，字体和颜色这些都是在终端的偏好设置里面设置，我们可以另外设置几个比较方便的别名，比如 1234alias zshrc=&quot;vim ~/.zshrc&quot;alias rcupdate=&quot;source ~/.zshrc&quot;alias stashpull=&quot;git stash &amp;&amp; git pull &amp;&amp; git stash pop&quot;alias xxxx=&quot;cd ~/desktop/xxxx&quot; 把这些内容添加到~/.zshrc文件的末尾，就可以直接使用zshrc,rcupdate,stashpull,xxxx等自定义命令了","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}],"keywords":[]},{"title":"安卓测试-Robolectric框架","slug":"安卓测试-Robolectric框架","date":"2018-12-16T05:06:47.000Z","updated":"2018-12-16T05:06:47.447Z","comments":true,"path":"2018/12/16/安卓测试-Robolectric框架/","link":"","permalink":"http://example.com/2018/12/16/%E5%AE%89%E5%8D%93%E6%B5%8B%E8%AF%95-Robolectric%E6%A1%86%E6%9E%B6/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"安卓测试-Mockito框架","slug":"安卓测试-Mockito框架","date":"2018-12-13T00:59:43.000Z","updated":"2018-12-27T17:43:46.444Z","comments":true,"path":"2018/12/13/安卓测试-Mockito框架/","link":"","permalink":"http://example.com/2018/12/13/%E5%AE%89%E5%8D%93%E6%B5%8B%E8%AF%95-Mockito%E6%A1%86%E6%9E%B6/","excerpt":"Mockito是一个用于java单元测试中的mocking框架","text":"Mockito是一个用于java单元测试中的mocking框架，mock就是模拟的意思，就是能够模拟一些类和方法的实现。当需要测试的类需要一个依赖类的时候，如果依赖类的获取很麻烦，那么可以直接使用Mock方法来模拟这个类，方便测试。 官方文档 引入build.gradle里面增加 12testImplementation &quot;org.mockito:mockito-core:+&quot;androidTestImplementation &quot;org.mockito:mockito-android:+&quot; //看了下好像没几个类，可能以后会增加功能 常用方法验证行为1234567891011121314//Let&#x27;s import Mockito statically so that the code looks clearerimport static org.mockito.Mockito.*;//mock creationList mockedList = mock(List.class);//using mock objectmockedList.add(&quot;one&quot;);mockedList.clear();//verificationverify(mockedList).add(&quot;one&quot;);verify(mockedList).clear(); Stubbing 12345678910111213141516171819202122232425 //You can mock concrete classes, not just interfacesLinkedList mockedList = mock(LinkedList.class);//stubbingwhen(mockedList.get(0)).thenReturn(&quot;first&quot;);when(mockedList.get(1)).thenThrow(new RuntimeException());doThrow(new RuntimeException()).when(mockedList).clear();//following throws RuntimeException:mockedList.clear();//following prints &quot;first&quot;System.out.println(mockedList.get(0));//following throws runtime exceptionSystem.out.println(mockedList.get(1));//following prints &quot;null&quot; because get(999) was not stubbedSystem.out.println(mockedList.get(999));//Although it is possible to verify a stubbed invocation, usually it&#x27;s just redundant//If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).//If your code doesn&#x27;t care what get(0) returns, then it should not be stubbed. Not convinced? See here.verify(mockedList).get(0); 参数匹配1234567891011121314//stubbing using built-in anyInt() argument matcherwhen(mockedList.get(anyInt())).thenReturn(&quot;element&quot;);//stubbing using custom matcher (let&#x27;s say isValid() returns your own matcher implementation):when(mockedList.contains(argThat(isValid()))).thenReturn(&quot;element&quot;);//following prints &quot;element&quot;System.out.println(mockedList.get(999));//you can also verify using an argument matcherverify(mockedList).get(anyInt());//argument matchers can also be written as Java 8 Lambdasverify(mockedList).add(argThat(someString -&gt; someString.length() &gt; 5)); 验证方法的调用次数1234567891011121314151617181920212223242526//using mockmockedList.add(&quot;once&quot;);mockedList.add(&quot;twice&quot;);mockedList.add(&quot;twice&quot;);mockedList.add(&quot;three times&quot;);mockedList.add(&quot;three times&quot;);mockedList.add(&quot;three times&quot;);//following two verifications work exactly the same - times(1) is used by defaultverify(mockedList).add(&quot;once&quot;);verify(mockedList, times(1)).add(&quot;once&quot;);//exact number of invocations verificationverify(mockedList, times(2)).add(&quot;twice&quot;);verify(mockedList, times(3)).add(&quot;three times&quot;);//verification using never(). never() is an alias to times(0)verify(mockedList, never()).add(&quot;never happened&quot;);//verification using atLeast()/atMost()verify(mockedList, atLeastOnce()).add(&quot;three times&quot;);verify(mockedList, atLeast(2)).add(&quot;three times&quot;);verify(mockedList, atMost(5)).add(&quot;three times&quot;); 验证方法的调用顺序123456789101112131415161718192021222324252627282930// A. Single mock whose methods must be invoked in a particular orderList singleMock = mock(List.class);//using a single mocksingleMock.add(&quot;was added first&quot;);singleMock.add(&quot;was added second&quot;);//create an inOrder verifier for a single mockInOrder inOrder = inOrder(singleMock);//following will make sure that add is first called with &quot;was added first&quot;, then with &quot;was added second&quot;inOrder.verify(singleMock).add(&quot;was added first&quot;);inOrder.verify(singleMock).add(&quot;was added second&quot;);// B. Multiple mocks that must be used in a particular orderList firstMock = mock(List.class);List secondMock = mock(List.class);//using mocksfirstMock.add(&quot;was called first&quot;);secondMock.add(&quot;was called second&quot;);//create inOrder object passing any mocks that need to be verified in orderInOrder inOrder = inOrder(firstMock, secondMock);//following will make sure that firstMock was called before secondMockinOrder.verify(firstMock).add(&quot;was called first&quot;);inOrder.verify(secondMock).add(&quot;was called second&quot;);// Oh, and A + B can be mixed together at will 验证方法没有执行1234567891011121314151617181920212223//using mocks - only mockOne is interactedmockOne.add(&quot;one&quot;);//ordinary verificationverify(mockOne).add(&quot;one&quot;);//verify that method was never called on a mockverify(mockOne, never()).add(&quot;two&quot;);//verify that other mocks were not interactedverifyZeroInteractions(mockTwo, mockThree);//using mocksmockedList.add(&quot;one&quot;);mockedList.add(&quot;two&quot;);verify(mockedList).add(&quot;one&quot;);//following verification will failverifyNoMoreInteractions(mockedList); doReturn()|doThrow()| doAnswer()|doNothing()|doCallRealMethod()1234567891011121314151617181920212223242526272829doThrow(new RuntimeException()).when(mockedList).clear();//following throws RuntimeException:mockedList.clear();when(mock.someMethod(anyString())).thenAnswer( new Answer() &#123; public Object answer(InvocationOnMock invocation) &#123; Object[] args = invocation.getArguments(); Object mock = invocation.getMock(); return &quot;called with arguments: &quot; + Arrays.toString(args); &#125;&#125;);//Following prints &quot;called with arguments: [foo]&quot;System.out.println(mock.someMethod(&quot;foo&quot;));List list = new LinkedList();List spy = spy(list);//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)when(spy.get(0)).thenReturn(&quot;foo&quot;);//You have to use doReturn() for stubbing:doReturn(&quot;foo&quot;).when(spy).get(0); 参数捕捉12345//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty) when(spy.get(0)).thenReturn(&quot;foo&quot;); //You have to use doReturn() for stubbing doReturn(&quot;foo&quot;).when(spy).get(0); 序列化的mock1List serializableMock = mock(List.class, withSettings().serializable()); 验证超时123456789101112//passes when someMethod() is called no later than within 100 ms//exits immediately when verification is satisfied (e.g. may not wait full 100 ms)verify(mock, timeout(100)).someMethod();//above is an alias to:verify(mock, timeout(100).times(1)).someMethod();//passes as soon as someMethod() has been called 2 times under 100 msverify(mock, timeout(100).times(2)).someMethod();//equivalent: this also passes as soon as someMethod() has been called 2 times under 100 msverify(mock, timeout(100).atLeast(2)).someMethod(); mock抽象类1234567891011121314151617//convenience API, new overloaded spy() method:SomeAbstract spy = spy(SomeAbstract.class);//Mocking abstract methods, spying default methods of an interface (only available since 2.7.13)Function function = spy(Function.class);//Robust API, via settings builder:OtherAbstract spy = mock(OtherAbstract.class, withSettings() .useConstructor().defaultAnswer(CALLS_REAL_METHODS));//Mocking an abstract class with constructor arguments (only available since 2.7.14)SomeAbstract spy = mock(SomeAbstract.class, withSettings() .useConstructor(&quot;arg1&quot;, 123).defaultAnswer(CALLS_REAL_METHODS));//Mocking a non-static inner abstract class:InnerAbstract spy = mock(InnerAbstract.class, withSettings() .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS)); 自定义验证失败信息123456// will print a custom message on verification failureverify(mock, description(&quot;This will print on failure&quot;)).someMethod();// will work with any verification modeverify(mock, times(2).description(&quot;someMethod should be called twice&quot;)).someMethod(); Java8匹配器支持12345678910111213141516171819// verify a list only had strings of a certain length added to it// note - this will only compile under Java 8verify(list, times(2)).add(argThat(string -&gt; string.length() &lt; 5));// Java 7 equivalent - not as neatverify(list, times(2)).add(argThat(new ArgumentMatcher()&#123; public boolean matches(String arg) &#123; return arg.length() &lt; 5; &#125;&#125;));// more complex Java 8 example - where you can specify complex verification behaviour functionallyverify(target, times(1)).receiveComplexObject(argThat(obj -&gt; obj.getSubObject().get(0).equals(&quot;expected&quot;)));// this can also be used when defining the behaviour of a mock under different inputs// in this case if the input list was fewer than 3 items the mock returns nullwhen(mock.someMethod(argThat(list -&gt; list.size()&lt;3))).thenReturn(null); Java8 Answer接口支持123456789// answer by returning 12 every timedoAnswer(invocation -&gt; 12).when(mock).doSomething();// answer by using one of the parameters - converting into the right// type as your go - in this case, returning the length of the second string parameter// as the answer. This gets long-winded quickly, with casting of parameters.doAnswer(invocation -&gt; ((String)invocation.getArgument(1)).length()) .when(mock).doSomething(anyString(), anyString(), anyString()); 对final对象，方法，枚举的支持12345678910final class FinalClass &#123; final String finalMethod() &#123; return &quot;something&quot;; &#125;&#125;FinalClass concrete = new FinalClass(); FinalClass mock = mock(FinalClass.class);given(mock.finalMethod()).willReturn(&quot;not anymore&quot;);assertThat(mock.finalMethod()).isNotEqualTo(concrete.finalMethod()); 创建mock对象的方法注解方法创建123456789public class ArticleManagerTest &#123; @Mock private ArticleCalculator calculator; @Mock private ArticleDatabase database; @Mock private UserProvider userProvider; private ArticleManager manager; 使用注解方法创建的时候，需要先 1MockitoAnnotations.initMocks(this); 也可以使用预置的 MockitoJUnitRunner Runner 或者 rule: MockitoRule. 直接创建1Person mPerson = mock(Person.class); //&lt;--使用mock方法 使用spy监视真正的对象你可以创建真实对象的spy对象，当使用spy对象的时候真实的方法会被调用(假如这个方法没有被stub)应当谨慎小心的使用spy对象 123456789101112131415List list = new LinkedList();List spy = spy(list);//optionally, you can stub out some methods:when(spy.size()).thenReturn(100);//using the spy calls *real* methodsspy.add(&quot;one&quot;);spy.add(&quot;two&quot;);//prints &quot;one&quot; - the first element of a listSystem.out.println(spy.get(0));//size() method was stubbed - 100 is printedSystem.out.println(spy.size()); 对spy对象要慎用when/thenReturn12345678910//optionally, you can verifyverify(spy).add(&quot;one&quot;);verify(spy).add(&quot;two&quot;); //Impossible: real method is called so spy.get(0) // throws IndexOutOfBoundsException (the list is yet empty)when(spy.get(0)).thenReturn(&quot;foo&quot;);//You have to use doReturn() for stubbingdoReturn(&quot;foo&quot;).when(spy).get(0);","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[],"keywords":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}]},{"title":"安卓测试-JUnit框架","slug":"安卓测试-JUnit框架","date":"2018-11-27T17:13:25.000Z","updated":"2018-12-16T02:15:53.143Z","comments":true,"path":"2018/11/28/安卓测试-JUnit框架/","link":"","permalink":"http://example.com/2018/11/28/%E5%AE%89%E5%8D%93%E6%B5%8B%E8%AF%95-JUnit%E6%A1%86%E6%9E%B6/","excerpt":"JUnit是java开发的一个测试框架，Android当然也能用","text":"JUnit是java开发的一个测试框架，Android当然也能用我个人的感觉是它比较适合测试纯Java逻辑的代码，比如工具类，算法的计算，类的数据操作等等。在app -&gt; src目录下，test就是它的工作目录。 在类名字上右键，go-to，选择test，就可以自动创建一个对应的测试类。在左边的文件目录里面对测试类文件右键，run，就可以执行里面的测试方法。 基础引入方法： 1testImplementation &#x27;junit:junit:4.12&#x27; JUnit4基础方法注解和常用的assertEquals之类的断言就不用说了，看名字基本都明白。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DateUtilTest &#123; private String time = &quot;2017-10-15 16:00:02&quot;; private long timeStamp = 1508054402000L; private Date mDate; @Before public void setUp() throws Exception &#123; System.out.println(&quot;测试开始！&quot;); mDate = new Date(); mDate.setTime(timeStamp); &#125; @After public void tearDown() throws Exception &#123; System.out.println(&quot;测试结束！&quot;); &#125; //该方法默认会在主线程中执行 @Test public void dateToStampTest() throws Exception &#123; assertNotEquals(4, DateUtil.dateToStamp(time)); &#125; @Test(expected = ParseException.class) public void dateToStampTest1() throws Exception &#123; DateUtil.dateToStamp(&quot;2017-10-15&quot;); &#125; @Test @Ignore(&quot;test方法不执行\\n&quot;) public void test() &#123; System.out.println(&quot;-----&quot;); &#125; //该方法会在一个单独的线程中执行，单位为毫秒，这里超时时间为2秒 @Test(timeout = 2000) public void testTimeout() &#123; System.out.println(&quot;timeout method called in thread &quot; + Thread.currentThread().getName()); &#125; @Test(expected = IndexOutOfBoundsException.class) public void empty() &#123; new ArrayList&lt;Object&gt;().get(0); &#125;&#125; 不过这里的@Test注解还有两个属性可以指定 Hamcrest与assertThatHamcrest是一个表达式类库，它提供了一套匹配符Matcher，JUnit4结合Hamcrest提供了一个全新的断言语法：assertThat，结合Hamcrest提供的匹配符，可以表达全部的测试思想。使用gradle引入JUnit4.12时已经包含了hamcrest-core.jar、hamcrest-library.jar、hamcrest-integration.jar这三个jar包，所以我们无需额外再单独导入hamcrest相关类库。 1234567891011121314151617181920212223//注意由于没有导包，直接用is(),both等等会找不到方法，他们基本都是CoreMatchers类的方法public class AssertThatTest &#123; @Test public void testMobilePhone() throws Exception &#123; Assert.assertThat(&quot;13588888888&quot;, new IsMobilePhoneMatcher()); &#125; @Test public void testAssertThat1() throws Exception &#123; Assert.assertThat(6, CoreMatchers.is(6)); &#125; @Test public void testAssertThat2() throws Exception &#123; Assert.assertThat(null, IsNull.nullValue()); &#125; @Test public void testAssertThat3() throws Exception &#123; Assert.assertThat(&quot;Hello python world&quot;,CoreMatchers.both(CoreMatchers.startsWith(&quot;Hello&quot;)).and(CoreMatchers.endsWith(&quot;World&quot;))); &#125;&#125; 自定义匹配器assertThat会用到匹配器，我们也可以自己定义匹配规则 12345678910111213141516171819202122232425262728293031323334353637import org.hamcrest.BaseMatcher;import org.hamcrest.Description;import java.util.regex.Matcher;import java.util.regex.Pattern;public class IsMobilePhoneMatcher extends BaseMatcher&lt;String&gt; &#123; /** * 进行断言判定，返回true则断言成功，否则断言失败 */ @Override public boolean matches(Object item) &#123; if (item == null) &#123; return false; &#125; Pattern pattern = Pattern.compile(&quot;(1|861)(3|5|7|8)\\\\d&#123;9&#125;$*&quot;); Matcher matcher = pattern.matcher((String) item); return matcher.find(); &#125; /** * 给期待断言成功的对象增加描述 */ @Override public void describeTo(Description description) &#123; description.appendText(&quot;预计此字符串是手机号码！&quot;); &#125; /** * 给断言失败的对象增加描述 */ @Override public void describeMismatch(Object item, Description description) &#123; description.appendText(item.toString() + &quot;不是手机号码！&quot;); &#125;&#125; 自定义 RuleRule给我的感觉类似于动态代理里面的InvocationHandler，在测试类中使用 @Rule 注解标记一个 Rule 接口的实现类，那么在 Rule 的 apply方法中就可以拦截到这个测试类的所有测试方法。 自带的Rule示例： 123456789101112131415161718192021222324252627282930313233//在测试方法内部能知道当前的方法名。public class NameRuleTest &#123; //用@Rule注解来标记一个TestRule，注意必须是public修饰的 @Rule public final TestName name = new TestName(); @Test public void testA() &#123; assertEquals(&quot;testA&quot;, name.getMethodName()); &#125; @Test public void testB() &#123; assertEquals(&quot;testB&quot;, name.getMethodName()); &#125;&#125;//超时时间public class TimeoutRuleTest &#123; @Rule public final Timeout globalTimeout = Timeout.millis(20); @Test public void testInfiniteLoop1() &#123; for (; ; ) &#123; &#125; &#125; @Test public void testInfiniteLoop2() &#123; for (; ; ) &#123; &#125; &#125;&#125; 自定义Rule： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 自定义@RuLL MyRule 演示 */public class AssertThatTest &#123; @Rule public MyRule rule = new MyRule(); @Test public void testAssertThat1() throws Exception &#123; Assert.assertThat(6, CoreMatchers.is(6)); &#125; @Test public void testAssertThat2() throws Exception &#123; Assert.assertThat(null, IsNull.nullValue()); &#125; @Test public void testAssertThat3() throws Exception &#123; Assert.assertThat(&quot;Hello python world&quot;,CoreMatchers.both(CoreMatchers.startsWith(&quot;Hello&quot;)).and(CoreMatchers.endsWith(&quot;World&quot;))); &#125; public class MyRule implements TestRule &#123; @Override public Statement apply(final Statement base, final Description description) &#123; return new Statement() &#123; @Override public void evaluate() throws Throwable &#123; // evaluate前执行方法相当于@Before String methodName = description.getMethodName(); // 获取测试方法的名字 System.out.println(methodName + &quot;测试开始！&quot;); base.evaluate(); // 运行的测试方法 // evaluate后执行方法相当于@After System.out.println(methodName + &quot;测试结束！&quot;); &#125; &#125;; &#125; &#125;&#125;public class RepeatRule implements TestRule &#123; //这里定义一个注解，用于动态在测试方法里指定重复次数 @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.METHOD&#125;) public @interface Repeat &#123; int count(); &#125; @Override public Statement apply(final Statement base, final Description description) &#123; Statement repeatStatement = new Statement() &#123; @Override public void evaluate() throws Throwable &#123; Repeat repeat = description.getAnnotation(Repeat.class); //如果有@Repeat注解，则会重复执行指定次数 if (repeat != null) &#123; for (int i = 0; i &lt; repeat.count(); i++) &#123; base.evaluate(); &#125; &#125; else &#123; //如果没有注解，则不会重复执行 base.evaluate(); &#125; &#125; &#125;; return repeatStatement; &#125;&#125;public class RepeatTest &#123; @Rule public final RepeatRule repeatRule = new RepeatRule(); //该方法重复执行5次 @RepeatRule.Repeat(count = 5) @Test public void testMethod() throws IOException &#123; System.out.println(&quot;---test method---&quot;); &#125; @Test public void testMethod2() throws IOException &#123; System.out.println(&quot;---test method2---&quot;); &#125;&#125; 测试方法的执行顺序 当我们运行一个测试类里的所有测试方法时，测试方法的执行顺序并不是固定的，JUnit4提供@ FixMethodOrder注解来配置执行顺序，其可选值有：MethodSorters.NAME_ASCENDING、MethodSorters.DEFAULT、MethodSorters.JVM 12345678910111213141516171819202122@FixMethodOrder(MethodSorters.NAME_ASCENDING)public class TestExecOrder &#123; @Test public void testD() &#123; System.out.println(&quot;DDDDD&quot;); &#125; @Test public void testA() &#123; System.out.println(&quot;AAAAA&quot;); &#125; @Test public void testB() &#123; System.out.println(&quot;BBBBB&quot;); &#125; @Test public void testC() &#123; System.out.println(&quot;CCCCC&quot;); &#125;&#125; Test runners所有的单元测试方法都是通过Runner来执行的。Runner只是一个抽象类，它是用来跑测试用例并通知结果的，JUnit提供了很多Runner的实现类，可以根据不同的情况选择不同的test runner。 通过@RunWith注解，可以为我们的测试用例选定一个特定的Runner来执行。默认的test runner是 BlockJUnit4ClassRunner。@RunWith(JUnit4.class)，使用的依然是默认的test runner，实质上JUnit4继承自BlockJUnit4ClassRunner。 SuiteSuite 翻译过来是测试套件，意思是让我们将一批其他的测试类聚集在一起，然后一起执行，这样就达到了同时运行多个测试类的目的。 123456789@RunWith(Suite.class)@Suite.SuiteClasses(&#123; TestLogin.class, TestLogout.class, TestUpdate.class&#125;)public class TestSuite &#123; //不需要有任何实现方法&#125; 执行运行TestSuite，相当于同时执行了这3个测试类。Suite还可以进行嵌套，即一个测试Suite里包含另外一个测试Suite。 1234@RunWith(Suite.class)@Suite.SuiteClasses(TestSuite.class)public class TestSuite2 &#123;&#125; Parameterized 参数化假如我们有一个待测试类 1234567891011public class Fibonacci &#123; public static int compute(int n) &#123; int result = 0; if (n &lt;= 1) &#123; result = n; &#125; else &#123; result = compute(n - 1) + compute(n - 2); &#125; return result; &#125;&#125; 针对这个函数，我们需要多个输入参数来验证是否正确 使用构造函数来注入参数值1234567891011121314151617181920212223242526 //指定Parameterized作为test runner @RunWith(Parameterized.class)public class TestParams &#123; //这里是配置参数的数据源，该方法必须是public static修饰的，且必须返回一个可迭代的数组或者集合 // JUnit会自动迭代该数据源，自动为参数赋值，所需参数以及参数赋值顺序由构造器决定。 @Parameterized.Parameters public static List getParams() &#123; return Arrays.asList(new Integer[][]&#123;&#123;0, 0&#125;, &#123;1, 1&#125;, &#123;2, 1&#125;, &#123;3, 2&#125;, &#123;4, 3&#125;, &#123;5, 5&#125;, &#123;6, 8&#125;&#125;); &#125; private int input; private int expected; //在构造函数里，指定了2个输入参数，JUnit会在迭代数据源的时候，自动传入这2个参数。 // 例如：当获取到数据源的第3条数据&#123;2，1&#125;时，input=2，expected=1 public TestParams(int input, int expected) &#123; this.input = input; this.expected = expected; &#125; @Test public void testFibonacci() &#123; System.out.println(input + &quot;,&quot; + expected); Assert.assertEquals(expected, Fibonacci.compute(input)); &#125;&#125; 使用注解123456789101112131415161718192021@RunWith(Parameterized.class)public class TestParams2 &#123; @Parameterized.Parameters public static List getParams() &#123; return Arrays.asList(new Integer[][]&#123;&#123;0, 0&#125;, &#123;1, 1&#125;, &#123;2, 1&#125;, &#123;3, 2&#125;, &#123;4, 3&#125;, &#123;5, 5&#125;, &#123;6, 8&#125;&#125;); &#125; //这里必须是public，不能是private @Parameterized.Parameter public int input; //注解括号里的参数，用来指定参数的顺序，默认为0 @Parameterized.Parameter(1) public int expected; @Test public void testFibonacci() &#123; System.out.println(input + &quot;,&quot; + expected); Assert.assertEquals(expected, Fibonacci.compute(input)); &#125;&#125; CategoriesCategories继承自Suite，但是比Suite功能更加强大，它能对测试类中的测试方法进行分类执行。当你想把不同测试类中的测试方法分在一组，Categories就很管用。 代码 github地址 引用：Android单元测试(一)：JUnit框架的使用Android单元测试","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[],"keywords":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}]},{"title":"flutter get started","slug":"flutter-get-started","date":"2018-11-05T11:15:45.000Z","updated":"2018-11-05T14:05:08.315Z","comments":true,"path":"2018/11/05/flutter-get-started/","link":"","permalink":"http://example.com/2018/11/05/flutter-get-started/","excerpt":"今天尝试了一下flutter,记一下过程","text":"今天尝试了一下flutter,记一下过程 安装和运行get-started 首先它说需要安装Git for Windows ，好像没有用到这个，因为我本身就已经有了，所以不知道没装会不会ok，建议安装 然后是下载 flutter_windows_v0.9.4-beta.zip ，300多M，这个是真的慢，我看了全局vpn依然很慢 解压出 flutter 文件夹，并且设置环境变量指向 flutter\\bin ，有一万多个文件把，解压也是超慢。 dos命令行运行 flutter doctor，检测环境设置，因为已经安装了Android-Studio了，所以jdk,sdk，AS，模拟器 那一块都没有问题，如果打算使用visio studio code 的话需要安装 flutter插件才能被发现。 如果打算使用AS的话，需要依次搜索安装插件 Dart 和 flutter ，这里我开了全局vpn依然安装不了flutter插件，不知道为什么，根据它错误提示里面的地址，我复制到浏览器里面下载了zip格式的插件然后导入到AS里面。 使用AS的话，直接创建Flutter项目就行，创建的时候记得勾选offline,不过即使是offline了，创建过程还是不知道为什么卡了很久很久。使用vsc的话，直接ctrl+p ,输入 &gt; ,再选择 Flutter: New Project 就行，直接就创建好了，或者使用命令行: 12flutter create myappcd myapp 创建后打开 myapp文件夹也行，也很快。 运行就，点击AS 的run按钮 ，或者vsc的debug(记得先点一下右边的配置小按钮)，或者 flutter run，按 R 是实时部署代码。 IDE的选择的话，我本来是倾向于vsc的，dart看起来像是ts一类的语言语法，但是实际打开后发现vsc来做这个的话，内存占用也到了七八百M了，和AS不相上下了。抽空看了看 google io 上的一些 flutter 的介绍视频，里面的程序员也都是用的 AS，所以还是决定用 AS 了。 大概看了下美团和咸鱼的试用报告，了解了下渲染效率和原理，觉得还是不错的。特别是看了使用flutter30分钟实现一个跨平台的IM app之后，觉得有点惊艳。谷歌的firebase和service全家桶套餐原来还有远程数据库的功能。视频里就演示了下双端读取同步数据库来实现IM，有些意思。 Demo官网文档的演示教程分1，2两部分，第一部分简单介绍了下text，展示了一个列表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:english_words/english_words.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;Startup Name Generator&#x27;, home: RandomWords(), ); &#125;&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize: 18.0); Widget _buildSuggestions() &#123; return ListView.builder( padding: const EdgeInsets.all(16.0), itemBuilder: (context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return Divider(); final index = i ~/ 2; if (index &gt;= _suggestions.length) &#123; _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125;); &#125; Widget _buildRow(WordPair pair) &#123; return ListTile( title: Text( pair.asPascalCase, style: _biggerFont, ), ); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&#x27;Startup Name Generator&#x27;), ), body: _buildSuggestions(), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override RandomWordsState createState() =&gt; new RandomWordsState();&#125; 通过 void main() =&gt; runApp(MyApp()); 来启动一个界面，MyApp则是一个 StatelessWidget 的控件，需要实现的虚方法 build要求返回一个 Widget 对于有状态变化的控件，需要使用 StatefulWidget 控件。继承后虚方法要求返回一个State. 然后新建一个状态类继承 State，把控件的名字作为 泛型参数写进去，State 的子类则需要返回一个 Widget。 可以使用 Scaffold 类来包裹 Widget 作为body参数的值来返回，可以使用ListView.builder（padding,ListTile）来构造一个列表控件。 感觉和rn相比，理解起来更接近客户端的思维。rn写起来则是更接近web的思维，尖括号大括号小括号一起上，还要用 StyleSheet.create 来写css，很不习惯。 第二部分展示了一下路由和页面交互的功能。呃，前端里面的路由意思就是页面跳转，这个也是看rn的时候迷糊了一段才明白。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:english_words/english_words.dart&#x27;;void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return new MaterialApp( title: &#x27;Flutter Demo&#x27;, theme: new ThemeData( // This is the theme of your application. // // Try running your application with &quot;flutter run&quot;. You&#x27;ll see the // application has a blue toolbar. Then, without quitting the app, try // changing the primarySwatch below to Colors.green and then invoke // &quot;hot reload&quot; (press &quot;r&quot; in the console where you ran &quot;flutter run&quot;, // or press Run &gt; Flutter Hot Reload in IntelliJ). Notice that the // counter didn&#x27;t reset back to zero; the application is not restarted. primarySwatch: Colors.blue, ), home: RandomWords(), ); &#125;&#125;class RandomWordState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); final _biggerFont = const TextStyle(fontSize: 18.0); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&#x27;Startup Name Generator&#x27;), actions: &lt;Widget&gt;[ // Add 3 lines from here... new IconButton(icon: const Icon(Icons.list), onPressed: _pushSaved), ], // ... to here. ), body: _buildSuggestions(), ); &#125; Widget _buildSuggestions() &#123; return ListView.builder( padding: const EdgeInsets.all(16.0), // The itemBuilder callback is called once per suggested word pairing, // and places each suggestion into a ListTile row. // For even rows, the function adds a ListTile row for the word pairing. // For odd rows, the function adds a Divider widget to visually // separate the entries. Note that the divider may be difficult // to see on smaller devices. itemBuilder: (context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return Divider(); // The syntax &quot;i ~/ 2&quot; divides i by 2 and returns an integer result. // For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2. // This calculates the actual number of word pairings in the ListView, // minus the divider widgets. final index = i ~/ 2; // If you&#x27;ve reached the end of the available word pairings... if (index &gt;= _suggestions.length) &#123; // ...then generate 10 more and add them to the suggestions list. _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125;); &#125; Widget _buildRow(WordPair pair) &#123; final bool alreadySaved = _saved.contains(pair); return ListTile( title: Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( // Add the lines from here... alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), // ... to here. onTap: () &#123; // Add 9 lines from here... setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, ); &#125; void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute&lt;void&gt;( // Add 20 lines from here... builder: (BuildContext context) &#123; final Iterable&lt;ListTile&gt; tiles = _saved.map( (WordPair pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;, ); final List&lt;Widget&gt; divided = ListTile.divideTiles( context: context, tiles: tiles, ).toList(); return new Scaffold( appBar: new AppBar( title: const Text(&#x27;Saved suggestions&#x27;), ), body: new ListView(children: divided), ); &#125;, ), // ... to here. ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return new RandomWordState(); &#125;&#125; 按钮的话是通过增加一个 onPressed: _pushSaved方法来实现，js里面对于这种突然而然出来的参数已经见怪不怪了。。路由则是通过 Navigator.of(context).push( MaterialPageRoute(builder:Widget) )来实现。其中用到了一些简单的图片，都是内置的。","categories":[{"name":"flutter","slug":"flutter","permalink":"http://example.com/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://example.com/tags/flutter/"}],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://example.com/categories/flutter/"}]},{"title":"Android-binder-java层","slug":"Android-binder-java层","date":"2018-11-03T09:07:37.000Z","updated":"2018-11-05T14:13:02.551Z","comments":true,"path":"2018/11/03/Android-binder-java层/","link":"","permalink":"http://example.com/2018/11/03/Android-binder-java%E5%B1%82/","excerpt":"java层分为系统服务的binder 和 bindService的 binder","text":"java层分为系统服务的binder 和 bindService的 binder 系统服务以ServiceManager.java 为例 : addService的过程12345678910111213141516171819202122232425//ServiceManager::getIServiceManager()private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager;&#125;//ServiceManagerNative::asInterfacestatic public IServiceManager asInterface(IBinder obj)&#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj);&#125; ServiceManager通过getIServiceManager()拿到远程接口，BinderInternal.getContextObject()是一个native方法： 12345678static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; // 这里 new BpBinder(handle)，具体函数见下面 // 注意这里 ProcessState::self() 会打开驱动，建立内存映射 sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); // 返回的是BinderProxy，并且设置了这个BinderProxy的mNativeDatas指针指向这个bpBinder,具体函数见下面 return javaObjectForIBinder(env, b);&#125; 在c++层调用ProcessState::getContextObject(NULL)得到一个c++的BpBinder(0)对象，并且通过jni的反射把它包装为一个BinderProxy的java对象返回给java，并且设置了BinderProxy(0)对象又有c++层BpBinder(0)对象的指针，因此 1ServiceManagerNative.asInterface(Binder.allowBlocking(BinderInternal.getContextObject())) 等于 1new ServiceManagerProxy(Binder.allowBlocking(new BinderProxy(0))` 从类的设计上来看，ServiceManagerProxy是ServiceManagerNative的一个静态代理类，通过asInterface()方法传入一个BinderProxy来构造，在ServiceManagerProxy的方法实现上，请求都转发给了BinderProxy,所以ServiceManagerProxy也是一个适配器类，把BinderProxy的方法适配成ServiceManagerProxy的方法来给用户调用。BinderProxy含有c++层BpBinder的指针，所以跨进程调用都是通过它来实现。 当java层调用 getIServiceManager().addService(…) 的时候，比如添加ActivityManagerService,因为继承了Binder,所以初始化的时候会设置一个mObject指针指向c++层的JavaBBinder类，这个JavaBBinder又有一个mObject指针指向JavaBBinder,这个JavaBBinder是c++层BBinder的子类，表示一个服务的实体，因此这里的Java层的getIServiceManager().addService(…) ，就转成了c++层的 BpBinder(0)::transact(…),transact的参数包含了name,JavaBBinder, 到这里就和前面的BpServiceManager.addService()一样了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// android / platform / frameworks / base / master / . / core / java / android / os / ServiceManagerNative.java$ServiceManagerProxypublic void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); data.writeStrongBinder(service); data.writeInt(allowIsolated ? 1 : 0); data.writeInt(dumpPriority); mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0); reply.recycle(); data.recycle();&#125;// android / platform / frameworks / base / master / . / core / jni / android_os_Parcel.cppstatic void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)&#123; Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr); if (parcel != NULL) &#123; const status_t err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object)); if (err != NO_ERROR) &#123; signalExceptionForError(env, clazz, err); &#125; &#125;&#125;// android / platform / frameworks / base / master / . / core / jni / android_util_Binder.cppsp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)&#123; if (obj == NULL) return NULL; // Instance of Binder? 读取 Binder.java 的 mObject指针,得到JavaBBinderHolder，再get()，得到JavaBBinder,这个类是 BBinder.cpp的子类 if (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123; JavaBBinderHolder* jbh = (JavaBBinderHolder*) env-&gt;GetLongField(obj, gBinderOffsets.mObject); return jbh-&gt;get(env, obj); &#125; // Instance of BinderProxy? 读取 BinderProxy.java 的 mObject指针，得到 BpBinder if (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123; return getBPNativeData(env, obj)-&gt;mObject; &#125; ALOGW(&quot;ibinderForJavaObject: %p is not a Binder object&quot;, obj); return NULL;&#125;//android / platform / frameworks / native / master / . / libs / binder / Parcel.cppstatus_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123; return flatten_binder(ProcessState::self(), val, this);&#125;status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; /*proc*/, const sp&lt;IBinder&gt;&amp; binder, Parcel* out)&#123; flat_binder_object obj; if (IPCThreadState::self()-&gt;backgroundSchedulingDisabled()) &#123; /* minimum priority for all nodes is nice 0 */ obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS; &#125; else &#123; /* minimum priority for all nodes is MAX_NICE(19) */ obj.flags = 0x13 | FLAT_BINDER_FLAG_ACCEPTS_FDS; &#125; if (binder != nullptr) &#123; IBinder *local = binder-&gt;localBinder(); if (!local) &#123; BpBinder *proxy = binder-&gt;remoteBinder(); if (proxy == nullptr) &#123; ALOGE(&quot;null proxy&quot;); &#125; const int32_t handle = proxy ? proxy-&gt;handle() : 0; obj.hdr.type = BINDER_TYPE_HANDLE; obj.binder = 0; /* Don&#x27;t pass uninitialized stack data to a remote process */ obj.handle = handle; obj.cookie = 0; &#125; else &#123; obj.hdr.type = BINDER_TYPE_BINDER; obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs()); obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local); &#125; &#125; else &#123; obj.hdr.type = BINDER_TYPE_BINDER; obj.binder = 0; obj.cookie = 0; &#125; return finish_flatten_binder(binder, obj, out);&#125;inline static status_t finish_flatten_binder( const sp&lt;IBinder&gt;&amp; /*binder*/, const flat_binder_object&amp; flat, Parcel* out)&#123; return out-&gt;writeObject(flat, false);&#125; getService的过程首先是获取 getIServiceManager()，这个在上面已经分析过了。之后是 getService(name)的方法，和上面类似，区别在于上面是writeStrongBinder写入service,这里是多了个readStrongBinder读取service,最后的结果是拿到了一个 BinderProxy. mRemote.transact(…)的过程可以去看c++流程部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158// android / platform / frameworks / base / master / . / core / java / android / os / ServiceManagerNative.java$ServiceManagerProxypublic IBinder getService(String name) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder;&#125;// android / platform / frameworks / base / master / . / core / jni / android_os_Parcel.cppstatic jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jobject clazz)&#123; Parcel* parcel = parcelForJavaObject(env, clazz); if (parcel != NULL) &#123; return javaObjectForIBinder(env, parcel-&gt;readStrongBinder()); &#125; return NULL;&#125;//android / platform / frameworks / native / master / . / libs / binder / Parcel.cpp//得到一个 BpBindersp&lt;IBinder&gt; Parcel::readStrongBinder() const&#123; sp&lt;IBinder&gt; val; // Note that a lot of code in Android reads binders by hand with this // method, and that code has historically been ok with getting nullptr // back (while ignoring error codes). readNullableStrongBinder(&amp;val); return val;&#125;//android / platform / frameworks / native / master / . / libs / binder / Parcel.cppstatus_t Parcel::readNullableStrongBinder(sp&lt;IBinder&gt;* val) const&#123; return unflatten_binder(ProcessState::self(), *this, val);&#125;//android / platform / frameworks / native / master / . / libs / binder / Parcel.cppstatus_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc,const Parcel&amp; in, sp&lt;IBinder&gt;* out)&#123; const flat_binder_object* flat = in.readObject(false); if (flat) &#123; switch (flat-&gt;hdr.type) &#123; case BINDER_TYPE_BINDER: *out = reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie); return finish_unflatten_binder(nullptr, *flat, in); case BINDER_TYPE_HANDLE: *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle); return finish_unflatten_binder( static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in); &#125; &#125; return BAD_TYPE;&#125;// android / platform / frameworks / native / master / . / libs / binder / ProcessState.cpp// 根据handle 生成一个BpBindersp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); handle_entry* e = lookupHandleLocked(handle); if (e != nullptr) &#123; // We need to create a new BpBinder if there isn&#x27;t currently one, OR we // are unable to acquire a weak reference on this current one. See comment // in getWeakProxyForHandle() for more info about this. IBinder* b = e-&gt;binder; if (b == nullptr || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; if (handle == 0) &#123; // Special case for context manager... // The context manager is the only object for which we create // a BpBinder proxy without already holding a reference. // Perform a dummy transaction to ensure the context manager // is registered before we create the first local reference // to it (which will occur when creating the BpBinder). // If a local reference is created for the BpBinder when the // context manager is not present, the driver will fail to // provide a reference to the context manager, but the // driver API does not return status. // // Note that this is not race-free if the context manager // dies while this code runs. // // TODO: add a driver API to wait for context manager, or // stop special casing handle 0 for context manager and add // a driver API to get a handle to the context manager with // proper reference counting. Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, nullptr, 0); if (status == DEAD_OBJECT) return nullptr; &#125; b = BpBinder::create(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; // This little bit of nastyness is to allow us to add a primary // reference to the remote proxy when this team doesn&#x27;t have one // but another team is sending the handle to us. result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125;// android / platform / frameworks / base / master / . / core / jni / android_util_Binder.cpp// If the argument is a JavaBBinder, return the Java object that was used to create it.// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.// // 根据 BpBinder 生成一个 BinderProxy并且返回jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; if (val == NULL) return NULL; if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; // It&#x27;s a JavaBBinder created by ibinderForJavaObject. Already has Java object. jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object(); LOGDEATH(&quot;objectForBinder %p: it&#x27;s our own %p!\\n&quot;, val.get(), object); return object; &#125; // For the rest of the function we will hold this lock, to serialize // looking/creation/destruction of Java proxies for native Binder proxies. AutoMutex _l(gProxyLock); BinderProxyNativeData* nativeData = gNativeDataCache; if (nativeData == nullptr) &#123; nativeData = new BinderProxyNativeData(); &#125; // gNativeDataCache is now logically empty. jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get()); if (env-&gt;ExceptionCheck()) &#123; // In the exception case, getInstance still took ownership of nativeData. gNativeDataCache = nullptr; return NULL; &#125; BinderProxyNativeData* actualNativeData = getBPNativeData(env, object); if (actualNativeData == nativeData) &#123; // New BinderProxy; we still have exclusive access. nativeData-&gt;mOrgue = new DeathRecipientList; nativeData-&gt;mObject = val; gNativeDataCache = nullptr; ++gNumProxies; if (gNumProxies &gt;= gProxiesWarned + PROXY_WARN_INTERVAL) &#123; ALOGW(&quot;Unexpectedly many live BinderProxies: %d\\n&quot;, gNumProxies); gProxiesWarned = gNumProxies; &#125; &#125; else &#123; // nativeData wasn&#x27;t used. Reuse it the next time. gNativeDataCache = nativeData; &#125; return object;&#125; 当java层调用 getIServiceManager().getService(…) 的时候，执行完毕后，还会调用 reply.readStrongBinder() 去读取远程调用的返回值，根据 handle 生成一个 BpBinder , 再根据 BpBinder 生成一个BinderProxy,这样子就拿到了需要的service的代理对象了。 可以看到，ServiceManager 仅仅是对 IServiceManager 的一个管理类，ServiceManagerNative是一个Binder虚基类，因为 ServiceManager 作为一个管理类，c++层的BBinder已经实现了，所以这里不需要实现 ServiceManagerNative了，只是用了它的静态方法，如果java类想要c++的数据，通过parcel.readXXX 就可以得到。 bindService 的 binder这里从网上找了一个 code example： GetDeviceInfoInterface.aidl : 12345interface IRemote&#123; int add(int a, int b); &#125; GetDeviceInfoService.java: 12345678910111213141516public class ArithmeticService extends Service&#123; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; private final IRemote.Stub mBinder = new IRemote.Stub() &#123; @Override public int add(int a, int b) throws RemoteException &#123; // TODO Auto-generated method stub return (a + b); &#125; &#125;;&#125; MainActivity.java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends Activity implements OnClickListener &#123; ServiceConnection mServiceConnection; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initConnection(); &#125; private void initConnection()&#123; mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub mService = null; Toast.makeText(getApplicationContext(), &quot;no&quot;, Toast.LENGTH_SHORT).show(); Log.d(&quot;IRemote&quot;, &quot;Binding - Service disconnected&quot;); &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // TODO Auto-generated method stub mService = IRemote.Stub.asInterface((IBinder) service); Toast.makeText(getApplicationContext(), &quot;yes&quot;, Toast.LENGTH_SHORT).show(); Log.d(&quot;IRemote&quot;, &quot;Binding is done - Service connected&quot;); &#125; &#125;; if(mService == null) &#123; Intent it = new Intent(); it.setAction(&quot;com.remote.service.CALCULATOR&quot;); bindService(it, mServiceConnection, Service.BIND_AUTO_CREATE); &#125; &#125; protected void onDestroy() &#123; super.onDestroy(); unbindService(mServiceConnection);&#125;; 接下来从bindService看起，bindService传入了一个类 ServiceConnection 作为回调。由于Activity的context实际上是ContextImpl,所以这里会到 ContextImpl.java里面去： 123456789101112131415161718192021222324252627282930313233//ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn,int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), getUser());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser. IServiceConnection sd; ... try &#123; IBinder token = getActivityToken(); if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(this); int res = ActivityManager.getService().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( &quot;Not allowed to bind to service &quot; + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 这里把传入的 ServiceConnection 类作为参数构造了一个 ServiceDispatcher, 然后返回了ServiceDispatcher的内部类mIServiceConnection，这是一个Binder类实体。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// LoadedAPK.javastatic final class ServiceDispatcher &#123; private final ServiceDispatcher.InnerConnection mIServiceConnection; private final ServiceConnection mConnection; private final Context mContext; private final Handler mActivityThread; private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service, boolean dead) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; sd.connected(name, service, dead); &#125; &#125; &#125; private final ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections = new ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;(); ServiceDispatcher(ServiceConnection conn, Context context, Handler activityThread, int flags) &#123; mIServiceConnection = new InnerConnection(this); mConnection = conn; mContext = context; mActivityThread = activityThread; mLocation = new ServiceConnectionLeaked(null); mLocation.fillInStackTrace(); mFlags = flags; &#125; ServiceConnection getServiceConnection() &#123; return mConnection; &#125; IServiceConnection getIServiceConnection() &#123; return mIServiceConnection; &#125; public void connected(ComponentName name, IBinder service, boolean dead) &#123; if (mActivityThread != null) &#123; mActivityThread.post(new RunConnection(name, service, 0, dead)); &#125; else &#123; doConnected(name, service, dead); &#125; &#125; &#125;// IServiceConnection.aidlinterface IServiceConnection &#123; void connected(in ComponentName name, IBinder service, boolean dead);&#125; 之后是ActivityManager.getService().bindService(…): 123456789101112131415161718192021222324252627282930313233343536//ActivityManager.javapublic static IActivityManager getService() &#123; return IActivityManagerSingleton.get();&#125;private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;;// ServiceManager.javapublic static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return Binder.allowBlocking(rawGetService(name)); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;error in getService&quot;, e); &#125; return null;&#125;private static IBinder rawGetService(String name) throws RemoteException &#123; final long start = sStatLogger.getTime(); final IBinder binder = getIServiceManager().getService(name); ...&#125; 在上面已经讲过，这里得到的是一个IActivityManager.Proxy类，是ActivityManagerService的远程接口.从app进程发起AMS的调用，参数中传递了一个Binder实体，在驱动的处理中，就会为app进程创建一个binder_node,同时在AMS的进程(也就是system_server)中创建一个binder_ref，然后还会把flat_binder_object的BINDER_TYPE_BINDER转成BINDER_TYPE_HANDLE类型，因此后面解析出来是一个BpBinder接口。对于AMS来说，binder线程唤醒后会执行executeCommand(…) 123456789101112131415161718192021222324252627282930status_t IPCThreadState::executeCommand(int32_t cmd)&#123; ... switch (cmd) &#123; ...... case BR_TRANSACTION: &#123; ... if (tr.target.ptr) &#123; // We only have a weak reference on the target object, so we must first try to // safely acquire a strong reference before doing anything else with it. if (reinterpret_cast&lt;RefBase::weakref_type*&gt;( tr.target.ptr)-&gt;attemptIncStrong(this)) &#123; error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this); &#125; else &#123; error = UNKNOWN_TRANSACTION; &#125; &#125; else &#123; error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; ... &#125; break; ....... &#125; ...&#125; 这里有把tr.cookie保存的值强转为BBinder类型(cookie的值在binder_thread_read设置)，对于c++的服务来说，它们本身已经继承了BBinder,所以会进入到它们自己的transact方法中，对于这里的调用来说，保存的是一个JavaBBinder类(可以看上面，对于Binder,writeStrongBinder写入的是一个JavaBBinder类) 1234567891011121314151617class JavaBBinder : public BBinder&#123; protected: status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) override &#123; ... jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); ... &#125; private: JavaVM* const mVM; jobject const mObject; // GlobalRef to Java Binder mutable std::once_flag mPopulateDescriptor; mutable String16 mDescriptor; &#125;; JavaBBinder 会通过jni反射调到它对应的Binder类的 onTransact 方法，在这里是指 IActivityManagerService.Stub里的方法，又会继续调用到子类的ams的bindService方法，终于来到了ams类。。 这里回到InnerConnection的connected()方法，依次调用到ServiceDispatcher.connected(),然后就是 mConnection.onServiceConnected。 总体上来说，这里还是binder的应用之一，因为serviceConnection不能跨进程，所以构造了一个InnerConnection，并且传给ams，这样ams就能主动通知app了，ams在创建service后，如果有bindservice,那么就会把 service 的成员变量，一个 Binder 作为参数通过 InnerConnection 的接口通知回app，这样app就拿到了 service 里面的 Binder 的远程接口，然后就可以调用这个 Binder 的方法了。","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[{"name":"binder","slug":"binder","permalink":"http://example.com/tags/binder/"}],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"Android-binder总结","slug":"Android-binder总结","date":"2018-11-02T05:02:24.000Z","updated":"2018-11-05T14:14:13.350Z","comments":true,"path":"2018/11/02/Android-binder总结/","link":"","permalink":"http://example.com/2018/11/02/Android-binder%E6%80%BB%E7%BB%93/","excerpt":"一些描述性的总结,大多数前面两篇已经描述过了","text":"一些描述性的总结,大多数前面两篇已经描述过了 进程结构： binder_proces 是保存在binder驱动中的一个全局的链表 注册服务的时候，会在service_manager中创建ref,在服务的进程中创建node,客户进程请求服务的时候会在自己的进程创建ref，都保存在各自的proc的红黑树的结构中 数据流向 BBinder会转成一个flat_binder_object，然后加上 name 序列化到 Parcel里 然后加上 target= 0和code=ADD_SERVICE 转成 binder_transation_data 对象， 然后加上 cmd = BC_TRANSACTION 写入到IPC_ThreadState的mOut 里面,mOut和mIn 构造一个 binder_write_read 对象， 发送给 binder 驱动 binder 驱动拷贝这个数据到内核，构造一个 binder_transaction_data 发送给服务进程的todo队列，同时向用户进程回复BR_COMPLETE 服务进程构造 binder_transaction_data 和 BC_REPLY 回复给 binder 驱动 请求过程 传输数据的大小限制取决于binder_open的参数: ServiceManager 初始化的时候传入的是 128*1024，也就是128k， 这个我们用不上 其他系统服务初始化的时候传入的是 BINDER_VM_SIZE(1*1024*1024-4096*2)，也就是 1M-8K 系统服务与bindService等启动的服务的区别 深入理解Binder通信原理及面试问题Binder系列10—总结","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[{"name":"binder","slug":"binder","permalink":"http://example.com/tags/binder/"}],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"java-锁","slug":"java-锁","date":"2018-10-30T01:34:19.000Z","updated":"2021-01-24T09:16:37.172Z","comments":true,"path":"2018/10/30/java-锁/","link":"","permalink":"http://example.com/2018/10/30/java-%E9%94%81/","excerpt":"主要是锁，线程相关的一些知识点","text":"主要是锁，线程相关的一些知识点 线程间通信 volatile和synchronized wait/notify 管道输入输出流 Thread.join() 线程池本质是 对任务的一个生产者消费者模型，通过worker来对job进行消费，没有就阻塞，这种就是核心线程。job是对runnable或者callable接口的实现，加入到阻塞队列可以更简单的进行同步的操作。 原子操作的实现原理处理器实现原子操作有两种方式： 通过总线锁来保证原子性 通过缓存锁来保证原子性 java种则通过CAS来实现原子操作，CAS的底层就是处理器的指令 synchronized关键字 synchronized 锁的对象 synchronized 可以用来修饰类的实例方法、静态方法、代码块 修饰实例方法的时候，锁是当前实例对象 修饰静态同步方法的时候，锁是当前class类对象 修饰代码块的时候，锁是synchronized括号里配置的对象 synchronized 的特点 synchronized 具备可重入性，对同一个线程在获得锁之后在调用其他需要同样锁的代码时可以直接调用，其可重入性是通过记录锁的持有线程和持有数量来实现的，调用 synchronized 代码时检查对象是否已经被锁，是则检查是否被当前线程锁定，是则计数加一，不是则加入等待队列，释放时计数减一直到为零释放锁。 synchronized 是重量级锁，竞争失败的线程会阻塞。 synchronized 的实现原理 语义底层是通过一个 monitor 监视器对象来完成，监视器锁（monitor）的本质依赖于底层操作系统的互斥锁（Mutex Lock）实现，而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，所以这就是为什么 synchronized 效率低且重量级的原因（Java 1.6 进行了优化，但是相比其他锁机制还是略显偏重）。 其实 wait、notify 等方法也依赖于 monitor 对象，所以这就是为什么只有在同步的块或者方法中才能调用 wait、notify 等方法，否则会抛出 IllegalMonitorStateException 异常的原因。 每日一题 锁的级别java中每个对象都可作为锁，锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。并且锁只能升级不能降级，但是偏向锁状态可以被重置为无锁状态。 自旋自旋是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。 1234567891011121314151617181920import java.util.concurrent.atomic.AtomicReference;public class SpinLock &#123; private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;(); public void lock() &#123; Thread currentThread = Thread.currentThread(); // 如果锁未被占用，则设置当前线程为锁的拥有者 while (!owner.compareAndSet(null, currentThread)) &#123; &#125; &#125; public void unlock() &#123; Thread currentThread = Thread.currentThread(); // 只有锁的拥有者才能释放锁 owner.compareAndSet(currentThread, null); &#125;&#125; 线程B尝试进入临界区的时候，在lock()函数里面会一直CAS失败而不能进入到临界区，此时就是自旋状态。可以看到这个语义是靠CAS来实现的。 对象头锁的实现机制与java对象头息息相关，锁的所有信息，都记录在java的对象头中。用2字宽(WORD)（32位JVM中1字宽==4Byte=32bit）存储对象头，如果是数组类型使用3字存储（还需存储数组长度）。对象头中包括mark word、类元数据的指针和数组的长度。 长度 内容 说明 32/64bit Mark Word 存储对象的hashCode或锁信息等。 32/64bit Class Metadata Address 存储到对象类型数据的指针 32/64bit Array length 数组的长度（如果当前对象是数组） mark word默认存储对象的hashcode,GC分代年龄，锁的状态，偏向锁的线程ID等。32位位： 在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下： 偏向锁引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。 当只有一个线程去竞争锁的时候，我们不需要阻塞，也不需要自旋，因为只有一个线程在竞争，我们只要去判断该偏向锁中的ThreadID是否为当前线程即可。 如果线程2要竞争锁对象，（偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线程是否存活， 如果没有存活，那么锁对象被重置为无锁状态，再使用cas替换偏向锁线程ID为线程2,锁不升级；如果存活，那么立刻查找该线程（线程1）的栈帧信息， 如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。 轻量锁轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。 线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1的锁记录地址； 如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。 但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，线程2还在自旋等待，或者又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。 优缺点对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用于只有一个线程访问同步块场景。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 如果始终得不到锁竞争的线程使用自旋会消耗CPU。 追求响应时间。 同步块执行速度非常快。 重量级锁 线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。 追求吞吐量。 同步块执行速度较长。 Java并发——Synchronized关键字和锁升级，详细分析偏向锁和轻量级锁的升级 Lock锁lock锁和synchronized的对比 非阻塞的获取锁（基于CAS的自旋？），synchronized竞争失败的线程会阻塞 能够响应中断,当获取到锁的线程被中断的时候，中断异常将会被抛出，同时锁会被释放，synchronized不会响应中断 有超时时间，synchronized会一直阻塞 LockSupport在Java多线程中，当需要阻塞或者唤醒一个线程时，都会使用LockSupport工具类来完成相应的工作。LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也因此成为了构建同步组件的基础工具。 LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread)方法来唤醒一个被阻塞的线程，这些方法描述如下： 方法名称 描 述 void park() 阻塞当前线程，如果掉用unpark(Thread)方法或被中断，才能从park()返回 void parkNanos(long nanos) 阻塞当前线程，超时返回，阻塞时间最长不超过nanos纳秒 void parkUntil(long deadline) 阻塞当前线程，直到deadline时间点 void unpark(Thread) 唤醒处于阻塞状态的线程 需要注意的是，和wait,notify不一样，park和unpark之间没有顺序要求，可以理解为调用unpark则获得了一个许可，没有这个许可则阻塞。(If the thread was blocked on park then it will unblock. Otherwise, its next call to park is guaranteed not to block.) lock锁实现原理基于AbstractQueuedSynchronizer(AQS,队列同步器)实现： 先说大致流程：队列同步器依赖内部的同步队列（一个fifo双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点并将其加入同步队列，同时阻塞线程，当同步状态释放的时候，会把节点中的线程唤醒，使其再次尝试获取同步状态。 节点的定义可以看作是有一些额外属性的双向链表，同步器内部则保存了链表的头尾节点的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 一个独占锁的示例代码,,不支持重入 */public class MyLock &#123; private static class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int acquires) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; @Override protected boolean tryRelease(int i) &#123; if (getState() == 0) &#123; throw new IllegalMonitorStateException(); &#125; setExclusiveOwnerThread(null); setState(0); return true; &#125; /** * 一般表示是否被当前线程所独占 * * @return */ @Override protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; ConditionObject newCondition() &#123; return new ConditionObject(); &#125; &#125; private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125;&#125; 扩展： 一行一行源码分析清楚AbstractQueuedSynchronizer 一行一行源码分析清楚 AbstractQueuedSynchronizer(二) ArrayBlockingQueueArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。 12345678910111213// 用于存放元素的数组final Object[] items;// 下一次读取操作的位置int takeIndex;// 下一次写入操作的位置int putIndex;// 队列中的元素数量int count;// 以下几个就是控制并发用的同步器final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull; ArrayBlockingQueue用到了一个锁（ReentranLock基于AQS实现，因此就带有一个同步队列）和两个condition，也就是一个同步队列和两个条件队列。 对于ArrayBlockingQueue里面的数组数据写，写数据的时候从0向后写，遇到数组结尾则重置位置，继续从0开始，因为如果有数据被读了， 那0开始的一段一定是空的，这样就不会覆盖数据。 对于ArrayBlockingQueue里面的数组数据读，读数据的时候从0向后读，遇到数组结尾则重置位置，继续从0开始，算是跟着写的顺序，这样就肯定能读到数据，除非数组中没有数据了。 对于同步队列，每个线程尝试进入临界区的时候会调用lock.lock创建节点并且加入到同步队列末尾，如果锁是公平锁，那么还需要排队，如果是非公平锁，那么可以直接竞争,竞争成功则把带有自己线程ID的节点设置为同步队列的头节点。临界区执行完毕后从同步队列中删除节点。 如果遇到conditionA .await()调用， 因为这段代码在临界区，因此这个线程一定就是头节点的线程，此时会根据线程ID重新创建一个节点加入到conditionA的条件队列的末尾。 如果遇到conditionA.signal()调用，则会在conditionA的条件队列中找到头节点（等待最久的线程），把它从条件队列中移除，并且加入到锁的同步队列中，如果同步队列的锁是公平锁，那么还需要排队，如果是非公平锁，那么可以直接竞争锁，竞争成功则设置自己为头结点，进入临界区。 LinkedBlockingQueueLinkedBlockingQueue 是链表实现的阻塞队列，这里默认和最大长度是Integer.MAX_VALUE。可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。 1234567891011// take, poll, peek 等读操作的方法需要获取到这个锁private final ReentrantLock takeLock = new ReentrantLock();// 如果读操作的时候队列是空的，那么等待 notEmpty 条件private final Condition notEmpty = takeLock.newCondition();// put, offer 等写操作的方法需要获取到这个锁private final ReentrantLock putLock = new ReentrantLock();// 如果写操作的时候队列是满的，那么等待 notFull 条件private final Condition notFull = putLock.newCondition(); LinkedBlockingQueue用到了两个锁（ReentranLock基于AQS实现，因此就带有一个同步队列）和两个condition，也就是两个同步队列和两个条件队列。 同步队列和条件队列之间节点的变化和上面还是类似的，不过这边因为有两个同步队列，取数据的时候只锁了读锁，此时还是可以进行写，数据全部取出的时候才会阻塞读线程。写数据的时候也只是锁了写锁，此时还是可以读，数据达到最大值的时候才会阻塞写线程。 SynchronousQueueSynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。它的队列不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。 在它的实现代码中没有用到AQS锁，是基于CAS自旋和LockSupport阻塞而实现的。 主要的逻辑： 12345678910111213141516// 写入值public void put(E o) throws InterruptedException &#123; if (o == null) throw new NullPointerException(); if (transferer.transfer(o, false, 0) == null) &#123; // 1 Thread.interrupted(); throw new InterruptedException(); &#125;&#125;// 读取值并移除public E take() throws InterruptedException &#123; Object e = transferer.transfer(null, false, 0); // 2 if (e != null) return (E)e; Thread.interrupted(); throw new InterruptedException();&#125; 其中，transferer接口对应于SynchronousQueue的两个内部类，构造 SynchronousQueue 的时候，我们可以指定公平策略。公平模式对应 TransferQueue。而非公平模式则对应 TransferStack。 12static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; &#123; ... &#125;static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123; ... &#125; 其他的细节还是直接看解读 Java 并发队列 BlockingQueue吧，他写的比较好。 PriorityBlockingQueuePriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。 PriorityQueue 的线程安全版本。 //todo 很多代码没有详细看，只是过了一下大致的流程","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"Android-SparseArray","slug":"Android-SparseArray","date":"2018-10-29T14:53:31.000Z","updated":"2018-11-05T14:13:58.994Z","comments":true,"path":"2018/10/29/Android-SparseArray/","link":"","permalink":"http://example.com/2018/10/29/Android-SparseArray/","excerpt":"SparseArray 是Android里面加入的数据结构","text":"SparseArray 是Android里面加入的数据结构,在插入的时候会对Key做hash，然后按照二分查找的算法去找到合适的位置插入或者更新对应的value值。和Hashmap相比较的话，用到的内存会比散列表小，因为少了那部分阈值的空数组位，但是数据量大起来后，二分查找比起散列表直接hash取位置还是要慢一些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261//内部维护一个int[]类型的key数组，一个object[]类型的value数组，key会保持有序并且无重复public class SparseArray&lt;E&gt; implements Cloneable &#123; private static final Object DELETED = new Object(); //用于删除的标记 private boolean mGarbage = false; private int[] mKeys; private Object[] mValues; private int mSize; public SparseArray() &#123; this(10); &#125; public SparseArray(int initialCapacity) &#123; if (initialCapacity == 0) &#123; mKeys = EmptyArray.INT; mValues = EmptyArray.OBJECT; &#125; else &#123; mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity); mKeys = new int[mValues.length]; &#125; mSize = 0; &#125; @Override public SparseArray&lt;E&gt; clone() &#123; SparseArray&lt;E&gt; clone = null; try &#123; clone = (SparseArray&lt;E&gt;) super.clone(); clone.mKeys = mKeys.clone(); clone.mValues = mValues.clone(); &#125; catch (CloneNotSupportedException cnse) &#123; /* ignore */ &#125; return clone; &#125; public E get(int key) &#123; return get(key, null); &#125; public E get(int key, E valueIfKeyNotFound) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &lt; 0 || mValues[i] == DELETED) &#123; return valueIfKeyNotFound; &#125; else &#123; return (E) mValues[i]; &#125; &#125; public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; mGarbage = true; &#125; &#125; &#125; public void remove(int key) &#123; delete(key); &#125; public void removeAt(int index) &#123; if (mValues[index] != DELETED) &#123; mValues[index] = DELETED; mGarbage = true; &#125; &#125; public void removeAtRange(int index, int size) &#123; final int end = Math.min(mSize, index + size); for (int i = index; i &lt; end; i++) &#123; removeAt(i); &#125; &#125; //把数组标记为DELETED的元素置为null，非标记的元素向前移动，然后更新属性 private void gc() &#123; int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i &lt; n; i++) &#123; Object val = values[i]; if (val != DELETED) &#123; if (i != o) &#123; keys[o] = keys[i]; values[o] = val; values[i] = null; &#125; o++; &#125; &#125; mGarbage = false; mSize = o; &#125; //首先会查找，如果找到了相同的key，会直接替换value的值，因此不会存在相同的key的情况，没找到的情况下，如果i&lt;size并且最后一次二分查找的低位标记为DELETED的话，直接把key,value赋值过去，否则gc()一次，然后调用工具类把key,value插入到i位置，这样的话key依然是有序的 public void put(int key, E value) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; mValues[i] = value; &#125; else &#123; i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125; &#125; public int size() &#123; if (mGarbage) &#123; gc(); &#125; return mSize; &#125; public int keyAt(int index) &#123; if (mGarbage) &#123; gc(); &#125; return mKeys[index]; &#125; public E valueAt(int index) &#123; if (mGarbage) &#123; gc(); &#125; return (E) mValues[index]; &#125; public void setValueAt(int index, E value) &#123; if (mGarbage) &#123; gc(); &#125; mValues[index] = value; &#125; public int indexOfKey(int key) &#123; if (mGarbage) &#123; gc(); &#125; return ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; public int indexOfValue(E value) &#123; if (mGarbage) &#123; gc(); &#125; for (int i = 0; i &lt; mSize; i++) if (mValues[i] == value) return i; return -1; &#125; public void clear() &#123; int n = mSize; Object[] values = mValues; for (int i = 0; i &lt; n; i++) &#123; values[i] = null; &#125; mSize = 0; mGarbage = false; &#125; public void append(int key, E value) &#123; if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) &#123; put(key, value); return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); &#125; mKeys = GrowingArrayUtils.append(mKeys, mSize, key); mValues = GrowingArrayUtils.append(mValues, mSize, value); mSize++; &#125; @Override public String toString() &#123; if (size() &lt;= 0) &#123; return &quot;&#123;&#125;&quot;; &#125; StringBuilder buffer = new StringBuilder(mSize * 28); buffer.append(&#x27;&#123;&#x27;); for (int i=0; i&lt;mSize; i++) &#123; if (i &gt; 0) &#123; buffer.append(&quot;, &quot;); &#125; int key = keyAt(i); buffer.append(key); buffer.append(&#x27;=&#x27;); Object value = valueAt(i); if (value != this) &#123; buffer.append(value); &#125; else &#123; buffer.append(&quot;(this Map)&quot;); &#125; &#125; buffer.append(&#x27;&#125;&#x27;); return buffer.toString(); &#125;----------------------------------------------------------------------//上面用到的工具类的二分查找算法 static int binarySearch(int[] array, int size, int value) &#123; int lo = 0; int hi = size - 1; while (lo &lt;= hi) &#123; final int mid = (lo + hi) &gt;&gt;&gt; 1; //算数右移 final int midVal = array[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; return ~lo; // value not present 取反为负数，再取反可以获取二分的最后一次位置，直接插入新的值 &#125;","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"二叉树常见操作","slug":"二叉树常见操作","date":"2018-10-27T16:42:00.000Z","updated":"2021-01-24T09:19:40.763Z","comments":true,"path":"2018/10/28/二叉树常见操作/","link":"","permalink":"http://example.com/2018/10/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"遍历等等","text":"遍历等等 Java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; @Override public String toString() &#123; return &quot;&quot; + val; &#125;&#125;//非递归的前序遍历public List&lt;TreeNode&gt; getPreOrderIteratively(TreeNode p) &#123; return getPreOrderIteratively(p, true);&#125;//对于非叶子节点，如果有一个子树位空会把它打印出来private List&lt;TreeNode&gt; getPreOrderIteratively(TreeNode p, boolean printNull) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;TreeNode&gt; listP = new ArrayList&lt;&gt;(); while (p != null || !stack.isEmpty()) &#123; while (p != null) &#123; listP.add(p); stack.push(p); if (printNull &amp;&amp; !isLeaf(p) &amp;&amp; p.left == null) &#123; listP.add(null); &#125; p = p.left; &#125; if (!stack.isEmpty()) &#123; p = stack.pop(); if (printNull &amp;&amp; !isLeaf(p) &amp;&amp; p.right == null) &#123; listP.add(null); &#125; p = p.right; &#125; &#125; return listP;&#125;private boolean isLeaf(TreeNode parent) &#123; if (parent.left == null &amp;&amp; parent.right == null) &#123; return true; &#125; return false;&#125;private boolean isSameTreeNode(TreeNode p1, TreeNode p2) &#123; if (p1 == null &amp;&amp; p2 == null) &#123; return true; &#125; if (p1 == null || p2 == null) &#123; return false; &#125; return p1.val == p2.val;&#125;//递归的层次遍历public List&lt;List&lt;Integer&gt;&gt; levelOrderRecursively (TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); result = levelOrderInternal(root, result,0); return result;&#125;private List&lt;List&lt;Integer&gt;&gt; levelOrderInternal(TreeNode node, List&lt;List&lt;Integer&gt;&gt; result, int level)&#123; if(node == null) return result; if(result.size() &lt;= level)&#123; result.add(new ArrayList&lt;&gt;()); &#125; result.get(level).add(node.val); levelOrderInternal(node.left,result, level+1); levelOrderInternal(node.right,result,level+1); return result;&#125;//非递归的层次遍历public List&lt;List&lt;Integer&gt;&gt; levelOrderIteratively(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if(root ==null)&#123; return ret; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode levelStart = root ; queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); if(node == levelStart)&#123; list = new ArrayList&lt;&gt;(); ret.add(list); levelStart = null ; &#125; list.add(node.val); if(node.left !=null)&#123; queue.offer(node.left); if(levelStart == null)&#123; levelStart = node.left; &#125; &#125; if(node.right !=null)&#123; queue.offer(node.right); if(levelStart == null)&#123; levelStart = node.right ; &#125; &#125; &#125; return ret ;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"一个硬币凑齐数值的问题","slug":"一个硬币凑齐数值的问题","date":"2018-10-24T16:06:00.000Z","updated":"2018-10-27T17:35:32.520Z","comments":true,"path":"2018/10/25/一个硬币凑齐数值的问题/","link":"","permalink":"http://example.com/2018/10/25/%E4%B8%80%E4%B8%AA%E7%A1%AC%E5%B8%81%E5%87%91%E9%BD%90%E6%95%B0%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"晚上看到qq群里讨论一个算法题：四个人分别有10000元 A只有1元的 B只有2元的 C只有5元的 D只有10元的","text":"晚上看到qq群里讨论一个算法题：四个人分别有10000元 A只有1元的 B只有2元的 C只有5元的 D只有10元的 1.问现在要凑10000元 有多少方法 ？2.假设投资额为10000，但最高出资的比例不能超过51%，问集资方案有多少种 ？ 为了准备面试，第一次刷题，刷了四五天的leetcode，结果面试算法题写出来了，但还是挂了，有点迷茫睡了一觉，醒来刚好看到这个题目，顺便做一做把。因为自己完全不知道动态规划，只知道个名称，最后做出来花了很久。 思路的话第一时间想到的是leetcode上一个爬楼梯的题目，不过仔细算了下发现有点不太一样，一个是爬楼梯有顺序，二是爬楼梯只有1步和2步。 这里的话，如果我们用4种面值去凑11块钱，那么，D可能出0或者1张，如果出0张，那问题就变成了3种面值去凑11块钱，如果出1张，那么问题就变成了3种面值去凑1块钱，嗯，这是关键的部分，其他的可以类似的推算，比如4种面值去凑22块钱，那么D可能出0，1，2张，又变成3个3种面值去凑钱的问题，根据5块钱出0，1，2….等等张数的时候，3种面值去凑钱又可以变成2种面值去凑钱的问题，2种面值去凑钱的话，根据2块钱出0，1…张可以直接得出有多少种方法，比如2种面值凑3块钱，那么2块钱可以出0或者1张，有两种方法。2种面值凑4块钱，则是3种方法，因为2块钱可以出0，1，2三种，5块钱依然是3种方法。下面就是代码实现了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Test &#123; public static void main(String[] args) &#123; System.out.println(get4n(10000)); // 1671170501 System.out.println(get4n(10000, 5100)); //884304594 &#125; // 表示用4种(1,2,5,10)硬币计算凑齐n块钱有多少种方法,i表示出的10块钱的总额，例如 // i==0的时候，就表示要用3种硬币凑齐所有的n块钱 public static long get4n(int n) &#123; long sum = 0; for (int i = 0; i &lt;= n; i += 10) &#123; sum += get3n(n - i); &#125; return sum; &#125; // 表示用3种(1,2,5)硬币计算凑齐n块钱有多少种方法 private static long get3n(int n) &#123; long sum = 0; for (int i = 0; i &lt;= n; i += 5) &#123; sum += get2n(n - i); &#125; return sum; &#125; // 表示用2种(1,2)硬币计算凑齐n块钱有多少种方法 private static long get2n(int n) &#123; return 1 + (n / 2); &#125; // 出的10块钱的总额不得大于 maxPer public static long get4n(int n, int maxPer) &#123; long sum = 0; for (int i = 0; i &lt;= maxPer; i += 10) &#123; sum += get3n(n - i, maxPer); &#125; return sum; &#125; // 出的5块钱的总额不得大于 maxPer private static long get3n(int n, int maxPer) &#123; long sum = 0; for (int i = 0; i &lt;= maxPer; i += 5) &#123; sum += get2n(n - i, maxPer); &#125; return sum; &#125; private static long get2n(int n, int maxPer) &#123; if (n &lt; maxPer) &#123; return 1 + (n / 2); &#125; else &#123; int bMax = maxPer / 2 - 1; int bMin = (n - maxPer) / 2 + 1; if (bMax &lt; bMin) &#123; return 0; &#125; return bMax - bMin + 1; &#125; &#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"按XML格式打印view和它的子view","slug":"Q-A-按XML格式打印view和它的子view","date":"2018-10-16T12:50:29.000Z","updated":"2018-10-27T17:14:09.719Z","comments":true,"path":"2018/10/16/Q-A-按XML格式打印view和它的子view/","link":"","permalink":"http://example.com/2018/10/16/Q-A-%E6%8C%89XML%E6%A0%BC%E5%BC%8F%E6%89%93%E5%8D%B0view%E5%92%8C%E5%AE%83%E7%9A%84%E5%AD%90view/","excerpt":"逻辑很简单，就是递归就结束了，很麻烦的是xml的格式调整，换行和缩进花了很久。没有要求写文件，不过写了看看效果","text":"逻辑很简单，就是递归就结束了，很麻烦的是xml的格式调整，换行和缩进花了很久。没有要求写文件，不过写了看看效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View view = findViewById(R.id.layout); ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView(); String str = printViewHierarchy(viewGroup); writeFile(str);&#125;private String printViewHierarchy(ViewGroup viewGroup) &#123; String lineStarter = &quot;&quot;; String blank = &quot; &quot;; StringBuilder builder = new StringBuilder(); builder.append(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot;?&gt;&quot;); builder.append(&quot;\\n&quot;); travelView(viewGroup, builder, lineStarter, blank); return builder.toString();&#125;private void writeFile(String str) &#123; File output = new File(Environment.getExternalStorageDirectory(), &quot;treeView.xml&quot;); if (output.exists()) &#123; output.delete(); &#125; try &#123; FileOutputStream outputStream = new FileOutputStream(output); outputStream.write(str.getBytes()); outputStream.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#125;&#125;public void travelView(View view, StringBuilder builder, String lineStarter, String blank) &#123; if (view instanceof ViewGroup) &#123; ViewGroup viewGroup = ((ViewGroup) view); builder.append(getStartTag(lineStarter, view)); if (viewGroup.getChildCount() != 0) &#123; builder.append(&quot;\\n&quot;); &#125; boolean newLine = true; for (int i = 0; i &lt; viewGroup.getChildCount(); i++) &#123; View child = viewGroup.getChildAt(i); if (newLine) &#123; lineStarter += blank; newLine = false; &#125; travelView(child, builder,lineStarter,blank); &#125; if (viewGroup.getChildCount() != 0) &#123; lineStarter = lineStarter.substring(0, lineStarter.length() - blank.length()); builder.append(getEndTag(lineStarter, view)); &#125; else &#123; builder.append(getEndTag(&quot; &quot;, view)); &#125; &#125; else &#123; builder.append(getStartTag(lineStarter, view)); builder.append(getEndTag(&quot; &quot;, view)); &#125;&#125;private String getEndTag(String pre, View view) &#123; return (pre + &quot;&lt;/&quot; + getViewName(view) + &quot;&gt;&quot; + &quot;\\n&quot;);&#125;private String getStartTag(String pre, View view) &#123; return (pre + &quot;&lt;&quot; + getViewName(view) + &quot;&gt;&quot;);&#125;private String getViewName(View view) &#123; String s = view.toString(); int index = s.indexOf(&quot;&#123;&quot;); index = (index == -1) ? s.length() : index; s = s.subSequence(0, index).toString(); int start = s.lastIndexOf(&quot;.&quot;); if (start != -1) &#123; s = s.substring(start + 1); &#125; return s;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"http 相关知识","slug":"http-相关知识","date":"2018-10-15T04:57:42.000Z","updated":"2021-01-24T09:18:44.902Z","comments":true,"path":"2018/10/15/http-相关知识/","link":"","permalink":"http://example.com/2018/10/15/http-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"http文档","text":"http文档 HTTP报文格式由三个部分组成，分别是： 状态行 消息报头 正文 如下所示，HTTP响应的格式与请求的格式十分类似： 1234567891011请求报文： &lt;method&gt; &lt;request-URL&gt; &lt;version&gt; &lt;headers&gt; &lt;blank line&gt; &lt;entity-body&gt;响应报文： HTTP-Version Status-Code Reason-Phrase CRLF &lt;headers&gt; &lt;blank line&gt; &lt;entity-body&gt; 头部字段分为请求头部字段，响应头部字段和通用头部字段三种类型， 请求报文头部字段有Accept、From 等等， 响应报文有 Content-Length 等， 通用有Cache-Control，Content-Type,Date等 get和post区别？两者没有本质区别，相比之下，get请求报文在startLine的url里面会直接带上query参数，post请求报文则不会带上，query参数会放在body里面。不过这些也都是通用的做法，在get请求报文的body里面带上query参数可能不会被大多数的服务器解析. get格式: 123456789GET &#x2F;sn&#x2F;index.php?sn&#x3D;123&amp;n&#x3D;asa HTTP&#x2F;1.1Accept: *&#x2F;*Accept-Language: zh-cnhost: localhostContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 12Connection:close post格式： 12345678910POST &#x2F;sn&#x2F;index.php HTTP&#x2F;1.1Accept: *&#x2F;*Accept-Language: zh-cnhost: localhostContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 12Connection:closesn&#x3D;123&amp;n&#x3D;asa 响应码分类响应码由三位十进制数字组成，它们出现在由HTTP服务器发送的响应的第一行。 响应码分五种类型，由它们的第一位数字表示： 1xx：信息，请求收到，继续处理 2xx：成功，行为被成功地接受、理解和采纳 3xx：重定向，为了完成请求，必须进一步执行的动作 4xx：客户端错误，请求包含语法错误或者请求无法实现 5xx：服务器错误，服务器不能实现一种明显无效的请求 常见的响应码如下： 200：请求成功，请求内容与该响应一起返回 202：请求已被接受，但还没处理。 301：请求的资源已被永久移动到新的位置。 302：请求的资源被临时移动到新的位置。 400：请求参数有误，当前请求无法被服务器理解。 401：请求需要验证用户 403：不允许访问该地址 404：Not Found 408：请求超时 500：服务器内部错误 502：Bad Gateway网关出错 HTTP和HTTPS HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443 HTTPS 协议提供了三个强大的功能： 内容加密。浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。 身份认证。保证用户访问的是百度服务，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持 数据完整性。防止内容被第三方冒充或者篡改。 HTTP和HTTP1.1Http1.1比Http1.0多了以下优点： 支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如身份认证、状态管理和Cache缓存等机制相关的请求头和响应头). Http2.0Http1.1主要针对的是tcp连接中握手和挥手导致的时延。而Http2.0主要针对的是tcp连接中慢启动导致的时延，同时也改进了串行执行的问题。 Http2的主要特点： 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能（假如你请求index.html，会把它需要的main.js也推送过来，这样就不用再去请求main.js）。 HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； 在网页请求中这样似乎很常见，但是在移动端的编程中并没有用到，如果这样阻塞对移动端的影响还是挺大的，比如请求一个图片，后面再一个普通json请求，如果json请求需要等待图片io结束才能进行，那app早就被人卸载了。。。okhttp中采用的是连接建立之后会缓存一段时间这种方式来避免重复的握手和挥手，请求发送前会检查是不是有可以重用的连接。 HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行； 具体如图： 更多：浅析HTTP/2的多路复用HTTP/2笔记之流和多路复用 三次握手和四次挥手三次握手三次握手过程示意图如下： 三次握手过程 第一步: 客户机的TCP首先向服务器得TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被设置为1。另外，客户机会随机选择一个起始序号seq=x。（连接请求报文不携带数据，但要消耗一个序号） 第二步: 服务器得TCP收到请求连接报文段后，如果同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq=y（确认报文不携带数据，但也要消耗掉一个序号）。 第三步： 当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置为1，序号字段为x+1，确认号字段ack=y+1。该报文段可以携带数据，不过不携带数据则不消耗序号。 成功进行以上三步之后，TCP连接就建立了，接下来就可以传送应用层数据了，TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。 上述TCP连接建立过程可总结如下： 123451. SYN&#x3D;1,seq&#x3D;x2. SYN&#x3D;1,ACK&#x3D;1,seq&#x3D;y,ack&#x3D;x+13. ACK&#x3D;1,seq&#x3D;x+1,ack&#x3D;y+1 为什么建立连接需要3次握手 如果采用两次的话，会出现下面这种情况： TCP的三次握手最主要是防止已过期的连接再次传到被连接的主机。 比如是客户端要连到服务器，结果发送的连接信息由于某种原因没有到达服务器；于是，客户端又发了一 次，结果这次服务器收到了，于是就发信息回来，两机就连接。传完东西后，断开。结果这时候，原先没有到达的连接信息突然又传到了服务器，于是服务器发确认信息给客户端，然后服务器就以为和客户端连上了，这个时候服务器就在等待客户端传东西过去。 三次握手改成仅需要两次握手，死锁是可能发生 考虑客户机和服务器之间的通信，假定客户机向服务器发送连接请求，服务器收到这个分组后，回复确认分组。按照两次握手的协定，服务器认为连接已经成功建立了，可以开始发送数据分组。 可是，可能出现一种情况就是，服务器的确认分组在传输过程中被丢失，而此时客户端没有收到确认分组；客户端此时不知道服务器是否已经准备好，不知道服务器建议什么样的序列号，客户端甚至怀疑服务器是否收到了自己的连接请求分组。 在这种情况下，客户端认为连接还未建立成功，将忽略服务器发来的任何数据分组，只等待连接确认应答分组。而服务器发出的分组超时后，重复发同样的分组，这样就形成了死锁。 简单描述： 客户端 ： 我要建立连接 服务端 ： 我OK了，缓存已经分配，连接号给你。 客户端 ： 我知道你ok了，我也开始把 四次挥手四次挥手如下图所示： 看起来四次挥手好像很复杂，其实很简单。无非就是客户端和服务器端各自提出关闭，值得注意的是TIME-WAIT，后面小结详细说。 四次挥手过程 第一步： 客户机打算关闭连接，就向其TCP发送一个连接释放报文段，并停止再发送数据，主动关闭TCP连接，该报文的的FIN标志位被置1，seq=u，它等于前面已传送过的数据的最后一个字节序号+1（FIN报文段即使不携带数据，也要消耗一个序号），TCP是全双工的，即可以想象成一条TCP连接上有两条数据通路。当发送FIN报文时，发送FIN的一端就不能再发送数据，也就是关闭了其中一条数据通路，但对方还可以发送数据。 第二步： 服务器收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于它前面已经传送过的数据的最后一个自己的序号+1。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。 第三步： 若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN=1的连接释放报文段。 第四步： 客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认号ack=w+1，序号seq=u+1。此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态。 上述TCP连接释放过程可总结如下： 12345671. FIN&#x3D;1,seq&#x3D;u2. ACK&#x3D;1,seq&#x3D;v,ack&#x3D;u+13. FIN&#x3D;1,ACK&#x3D;1,seq&#x3D;w,ack&#x3D;u+14. ACK&#x3D;1,seq&#x3D;u+1,ack&#x3D;w+1 TIME-WAIT作用 为什么需要TIME_WAIT？有如下几个原因： 因为在第四步的时候，客户机发送的ACK可能丢失并导致服务端重新发送FIN消息，TIME_WAIT维护连接状态. 如果执行主动关闭的一方客户机不进入到TIME_WAIT状态就关闭连接那会发生什么呢？当重传的FIN消息到达时，因为TCP已经不再有连接的信息了，所以就用RST(重新启动)消息应答，导致服务端进入错误的状态而不是有序终止状态，如果发送最后ACK消息的一方处于TIME_WAIT状态并仍然记录着连接的信息，它就可以正确的响应对等方服务端的FIN消息了. TIME_WAIT为连接中”离群的段”提供从网络中消失的时间. 考虑一下，如果延迟或者重传段在连接关闭后到达时会发生什么呢？通常情况下，因为TCP仅仅丢弃该数据并响应RST消息，所以这不会造成任何问题。当RST消息到达发出延时段的主机时，因为该主机也没有记录连接的任何信息，所以它也丢弃该段。然而，如果两个相同主机之间又建立了一个具有相同端口号的新连接，那么离群的段就可能被看成是新连接的，如果离群的段中数据的任何序列号恰恰在新连接的当前接收窗口中，数据就会被重新接收，其结果就是破坏新连接。 简单描述： 客户端 ： 我传完了，可以关闭了 服务端 ： 我知道了，这边可能还有点东西没传完 服务端 ： 我也传完了 客户端 ： 我知道了，2MSL后我也关闭 服务端 ：收到确认后关闭连接 tcp报文和 udp报文TCP报文段首部 UDP数据报格式 TCP的拥塞控制 拥塞的标志 ： 重传计时器超时 接收到三个重复确认 慢开始 慢开始不是指cwnd的增长速度慢（指数增长），而是指TCP开始发送设置cwnd=1。 思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。 拥塞避免（按线性规律增长） 拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 思路：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞控制窗口加一。 快速重传和快速恢复 代理：https://blog.csdn.net/watson2017/article/details/79897693 Https一些推算过程 其实https的关键在于非对称加解密算法，有了这个算法作为基础，后面才能有这么多验证过程 数字签名将报文按双方约定的摘要算法Hash后得到的一个固定位数的报文摘要，再使用CA机构的公钥加密得到数字签名。 在这里报文包含： 你提交给CA的公钥 你提交给CA的标识信息（网址，邮件等） 有效期（证书的有效时间） CA机构的标识信息 在数学上保证：只要改动报文中任何一位，重新计算出来的报文摘要值就会与原先的值不相符。这就保证了报文的不可更改性。 证书证书需要申请，并由专门的数字证书认证机构 CA 通过非常严格的审核之后颁发的电子证书，证书是对服务器端的一种认证。证书的内容： 你提交给CA的公钥 你提交给CA的标识信息（网址，邮件等） 有效期（证书的有效时间） CA机构的标识信息 摘要算法（md5,sha1,sha256等等） 颁发者的数字签名，用来证明使用者的公钥和使用者的标识符信息之间的绑定的有效性。 客户端收到证书以后，用CA的的公钥解密数字签名，得到报文摘要A，解密成功说明这个证书确实是由这个CA颁发的。拿1234按照5去hash，得到报文摘要B，再，对比A和B是否相同，相同则说明报文信息没有被篡改。CA的公钥是存在客户端本地的，CA机构和它们的公钥都是已知的保证权威的。 PRFPRF是一个“伪随机数函数”，这个函数很聪明，在规约中也有定义。它使用基于哈希的消息验证码（HMAC）的MD5和SHA-1两种哈希函数将密钥，ASCII字符以及我们给的种子结合起来。对每个哈希函数发送一半的输入。说它聪明的原因是即使面对MD5和SHA-1的弱点，它的防攻击能力还很强。这个过程可以自我反馈并不停地循环，而且我们要多少字节就能生成多少。 https的过程 客户端向服务端发起请求，并且带上自己支持的加密算法（ Cipher Suites），ssl版本，摘要算法等等，产生一个随机数A（Client random）。 服务端把自己的证书返回给客户端，并且带上选择的加密算法，摘要算法等等，产生一个随机数B（Server random）。 客户端验证这个证书，通过后再生成一个随机数C（Pre-master secret），客户端会使用这三个随机数ABC使用PRF生成一个master_secret，然后再使用 master_secret和随机数AB再PRF一次得到加密套件key block，里面包含后面通信会用到的各种密钥。然后使用证书中的公钥加密C，发送给服务器端，并且发送change_cipher_spec协议通知服务器，客户端已经准备好。 服务器端用私钥解密C，用同样的方式生成master_secret和加密套件key block，然后发送change_cipher_spec协议通知客户端，服务器已经准备好 感谢 Android校招笔记 浅析TCP协议中的疑难杂症","categories":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}]},{"title":"Java-hashmap,concurrentHashmap","slug":"Java-hashmap","date":"2018-10-13T08:59:24.000Z","updated":"2021-01-24T09:17:05.972Z","comments":true,"path":"2018/10/13/Java-hashmap/","link":"","permalink":"http://example.com/2018/10/13/Java-hashmap/","excerpt":"java8的hashmap和concurrentHashmap","text":"java8的hashmap和concurrentHashmap HashMap hashmap的几个字段的含义 1234int threshold; // 所能容纳的key-value对极限，超过就要进行扩容。threshold = table.length * loadFactorfinal float loadFactor; // 负载因子int size; //保存的键值对的数目transient Node&lt;K,V&gt;[] table; // 散列表数组 hashmap的构造函数 1234567891011121314151617181920212223242526272829303132333435363738394041public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; /*** Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial* capacity and the default load factor (0.75).** @param initialCapacity the initial capacity.* @throws IllegalArgumentException if the initial capacity is negative.*/public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; /*** Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity* (16) and the default load factor (0.75).*/public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 在构造函数里面，如果我们传入了初始值大小，则会对这个值做一个tableSizeFor(...)的处理，处理的结果是 最小的大于cap的2的幂(这个算法没看明白)，并且设置 threshold 的值为它，否则 threshold 的值为 0 hashmap的散列函数 1index = hash(key) &amp; (table.length()-1) 当 table.length() 的值是2的幂次方的时候，table.length()-1的值在bit位上则全是1，因此这里的index的值实际上等于hash值的末位数字。比如 index = 101101010 &amp; 111 = 010 = 2 ,这个key对应的数据应该放在数组的2位置。 put过程 key-value在hashmap 中以 Node 节点的形式存储，Node节点保存有next值，指向下一个节点。如果存在下一个节点，则说明这里有hash冲突，作为链表保存，否则仅仅是一个Node节点存储。其中，转化为红黑树的时候，红黑树的节点 TreeNode 是Node 的子类 扩容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; //如果是刚刚初始化，这里oldTab是null int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold ， 两倍 &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 对应于在构造函数中传入了初始化大小，那么tableSizeFor处理后的值就成了散列表数组的初始化大小 else &#123; // zero initial threshold signifies using defaults // 在构造函数中如果没有传入初始化大小，这里oldThr是等于0的，采用默认值，默认是16 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // 前面确定了扩容后的参数，这里把原来的节点移到新的数组中去 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //如果在这个位置上没有冲突，则直接复制过去 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //如果这个位置上是红黑树，处理 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order，如果这个位置是个长度大于1的链表 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; //这句在下面有分析，是怎么拆分链表的 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 当需要扩容的时候，会调用 resize()函数。在扩容后，因为散列函数不变，因此 1index = hash(key) &amp; (table.length()-1) 仍然成立，但是此时，table的大小变成了原来的两倍，因此在散列的时候，后面的括号的值会多一位1，假如刚开始有： index = 101101010 &amp; 111 = 010 = 2 ； 那么扩容后则变成了 ： index = 101101010 &amp; 1111 = 1010 = 10 观察下可以知道，如果高1位（第四位，扩容后的最高位）的值为0，那么扩容后节点的位置不变，如果高1位的位置为1，那么扩容后节点的位置为index + table.length。而获取这个高1位的值的方法，则可以是 hash(key) &amp; (table.length()) 因为 table.length() 是2的幂次方，因此一定是 ..00100… ，相与运算之后刚好可以得到这个位的值是1还是0 在 resize() 函数中， 如果是0，则添加到 newTab[j] 位置的链表中去，如果是1，则添加到 newTab[j + oldCap] 的链表中去 重写key的equals和hashCode :A和B对象equals方法返回true，hashCode方法返回值必然一样；A和B对象hashCode不一样，那么equals方法必须返回false。A和B对象hashCode一样，不能判定A equals B。 ConcurrentHashMap 一些参数 12345678910111213// 0：默认值// -1：代表哈希表正在进行初始化// -N 表示有N-1个线程正在进行扩容操作 // 大于0：相当于 HashMap 中的 threshold，表示阈值 private transient volatile int sizeCtl;//表示散列表transient volatile Node&lt;K,V&gt;[] table;//哈希表扩容的时候会用，扩容完成后会被重置为 null。private transient volatile Node&lt;K,V&gt;[] nextTable;static final int MOVED = -1; // hash值是-1，表示这是一个forwardNode节点 static final int TREEBIN = -2; // hash值是-2 表示这时一个TreeBin节点 构造函数，这里只选常用的 12345678910111213// 这里和hashmap有些不一样，初始化的大小是 initialCapacity*1.5+1，再向上取到2的n次方，// hashmap是直接用 initialCapacity 向上取到2的n次方public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap;&#125;//不带参数甚至什么都不初始化public ConcurrentHashMap() &#123;&#125; put函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 public V put(K key, V value) &#123; return putVal(key, value, false); &#125;/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //initTable()的时候也需要考虑多个线程操作的情景，使用cas来保证线程同步 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; //如果这个数组位置上还没有节点，cas插入 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) // 帮助数据迁移，假如此时正在扩容 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; else if (f instanceof ReservationNode) throw new IllegalStateException(&quot;Recursive update&quot;); &#125; &#125; // binCount != 0 表示插入到了节点到了链表或者红黑树中去了，返回之前的值 if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; 从过程上看，和hashmap的区别在于，插入的时候， 如果在数组对应的hash位置上没有元素，那么使用cas来插入而不是直接赋值，如果插入失败，会继续循环继续判断这个位置有没有别的线程已经插入了，直到插入成功为止。 如果对应的hash位置上已经有元素了，那么这里要么是单链表要么是红黑树，把头结点作为锁，再执行插入操作 hash的方法没变，但是对于hashcode,会先spread() : spread(hash) &amp; (n-1) 因为有个for( ; ; )循环的存在，所以遇到节点是MOVED的时候，会先帮助进行数据迁移。 12345678910111213141516171819202122232425final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; //返回一个 16 位长度的扩容校验标识 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; //sizeCtl 如果处于扩容状态的话 //前 16 位是数据校验标识，后 16 位是当前正在扩容的线程总数 //这里判断校验标识是否相等，如果校验符不等或者扩容操作已经完成了，直接退出循环，不用协助它们扩容了 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; //否则调用 transfer 帮助它们进行扩容 //sc + 1 标识增加了一个线程进行扩容 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table;&#125; 为并发而生的 ConcurrentHashMap 转移函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // 计算每个线程转移的数据的最小步长 if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) &#123; //这里的for循环，下面会多次执行 Node&lt;K,V&gt; f; int fh; while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; // 这里transferIndex小于0表示数组迁移任务已经分配完了，不需要协助了 else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; //这里的else if 分支表示为线程分配任务，负责的区间在数组上的索引是（nextbound,nextIndex），第一次while循环的时候前面两个分支都不满足条件，进来这里分配，通过CAS更新transferIndex的值为前一个transferIndex-stride,更新成功后i也有了值，然后跳出了while循环，在下次for循环进来的时候会进入while的第一/二个分支 else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; //当前线程所有任务完成 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; //结束了就更新相关的变量 if (finishing) &#123; nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit &#125; &#125; //如果散列表旧表这个位置为空，则把ForwardingNode赋值给这个位置 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); //如果散列表旧表这个位置为ForwardingNode，表示已经处理过了 else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; synchronized (f) &#123; //如果散列表旧表这个位置为链表节点，CAS的方式迁移，位置变化和hashmap差不多，最后会追加在散列表旧表里面设置ForwardingNode表示已经处理过了 if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123; int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; //如果散列表旧表这个位置为红黑树，CAS的方式迁移，最后会追加在散列表旧表里面设置ForwardingNode表示已经处理过了 else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; 这里主要是两个无限循环导致分支的控制有点复杂，在迁移的过程中还是要对数组旧表的位置处的结点加锁。整个迁移过程不加锁的原因是，根据hash函数，旧表迁移到新表，旧表中位置为i的节点在新表中只可能有两个位置，i和i+n，只需要对这个节点加锁，保证迁移过程就行。A线程负责i节点，B线程负责j节点，C线程负责k节点，只要节点没有重叠，迁移就不会有多线程的问题。完成后会把旧表中这个位置设置为ForwardingNode，这样别的线程扫描到这个节点也会发现处理过了，跳过它。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"常见排序算法的实现","slug":"常见排序算法的实现","date":"2018-10-08T06:58:31.000Z","updated":"2021-01-24T09:19:34.915Z","comments":true,"path":"2018/10/08/常见排序算法的实现/","link":"","permalink":"http://example.com/2018/10/08/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"排序算法之前写过的脚本语言全都忘了，这里打算利用排序算法复习一下。。。。","text":"排序算法之前写过的脚本语言全都忘了，这里打算利用排序算法复习一下。。。。 冒泡排序冒泡排序(En) 冒泡排序(CH) 优化点： 每趟排序会使一个数字到达到达它的最终位置，所以每趟冒泡的次数最大是length-1-i； 在一趟冒泡中如果没有发生位置交换，则认为已经是有序队列，不再进行冒泡； Java版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Main &#123; public static void main(String[] args) &#123; int[] numbers = getIntArray(); // bubberSort(numbers); bubberSort2(numbers); &#125; private static int[] getIntArray() &#123; Random random = new Random(); int length = 20; int[] numbers = new int[length]; for (int i = 0; i &lt; length; i++) &#123; numbers[i] = random.nextInt(100); &#125; return numbers; &#125; public static void bubberSort(numbers)(int[] numbers) &#123; int length = numbers.length; for (int i = 0; i &lt; length - 1; i++) &#123; for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (numbers[j] &gt; numbers[j + 1]) &#123; swap(numbers, j, j+1); &#125; &#125; &#125; printArray(numbers); &#125; public static void bubberSort2(int[] numbers) &#123; int length = numbers.length; boolean changed = false; for (int i = 0; i &lt; length - 1; i++) &#123; for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (numbers[j] &gt; numbers[j + 1]) &#123; swap(numbers, j, j + 1); changed = true; &#125; &#125; if (!changed) &#123; break; &#125; changed = false ; &#125; printArray(numbers); &#125; private static void printArray(int[] arr) &#123; IntStream.of(arr).forEach(x -&gt; System.out.print(&quot;,&quot; + x)); System.out.println(); &#125; private static void swap(int[] data, int i, int j) &#123; if (i == j) &#123; return; &#125; data[i] = data[i] + data[j]; data[j] = data[i] - data[j]; data[i] = data[i] - data[j]; &#125;&#125; javaScript: 12345678910111213141516171819let numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];function bubber_sort(arr)&#123; if (arr instanceof Array)&#123; for(let i = 0 ;i&lt; arr.length-1;i++)&#123; for(let j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; (function(arr,x,y)&#123; arr[x] = arr[x] ^ arr[y] ; arr[y] = arr[x] ^ arr[y] ; arr[x] = arr[x] ^ arr[y] ; &#125;)(arr,j,j+1); &#125; &#125; &#125; console.log(arr.join()); &#125;&#125;bubber_sort(numbers); c++: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#define GET_LEN(array, len) \\ &#123; \\ len = sizeof(array) / sizeof(array[0]); \\ &#125;void swap(int arr[], int x, int y)&#123; arr[x] = arr[x] ^ arr[y]; arr[y] = arr[x] ^ arr[y]; arr[x] = arr[x] ^ arr[y];&#125;void swap(int *a ,int *b)&#123; *a = *a^*b ; *b = *a^*b ; *a = *a^*b ;&#125;void swap(int &amp;a ,int &amp;b)&#123; a = a^b ; b = a^b ; a = a^b ;&#125;void bubber_sort(int numbers[],int length)&#123; for (int i = 0; i &lt; length - 1; i++) &#123; for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (numbers[j] &gt; numbers[j + 1]) &#123; // swap(numbers, j, j + 1); // swap(&amp;numbers[j],&amp;numbers[j+1]); // swap(numbers[j],numbers[j+1]); std::swap(numbers[j],numbers[j+1]); &#125; &#125; &#125; for (int i = 0; i &lt; length; i++) &#123; std::cout &lt;&lt; numbers[i] &lt;&lt; &quot;,&quot;; &#125;&#125;int main()&#123; int numbers[] = &#123;82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75&#125;; int length; GET_LEN(numbers, length); bubber_sort(numbers,length); return 0;&#125; python: 12345678910numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];def bubber_sort(numbers): for i in range(len(numbers)-1): for j in range(len(numbers)-1-i): if numbers[j] &gt; numbers[j+1]: numbers[j],numbers[j+1] = numbers[j+1],numbers[j] print(numbers)bubber_sort(numbers) TypeScript(啊，好像和js一样，改一下解构赋值凑个数…): 12345678910111213let numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];function bubber_sort(arr:number[])&#123; for(let i = 0 ;i&lt; arr.length-1;i++)&#123; for(let j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; [arr[j],arr[j+1]]=[arr[j+1],arr[j]] &#125; &#125; &#125; console.log(arr.join()); &#125;bubber_sort(numbers); 选择排序选择排序(En) 选择排序(CH) 每一趟选出一个最小(最大)的放到最终位置。 Java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Main &#123; public static void main(String[] args) &#123; int[] numbers = getIntArray(); selectionSort(numbers); &#125; private static int[] getIntArray() &#123; Random random = new Random(); int length = 20; int[] numbers = new int[length]; for (int i = 0; i &lt; length; i++) &#123; numbers[i] = random.nextInt(100); &#125; return numbers; &#125; public static void printArray(int[] arr) &#123; IntStream.of(arr).forEach(x -&gt; System.out.print(&quot;,&quot; + x)); System.out.println(); &#125; private static void swap(int[] data, int i, int j) &#123; if (i == j) &#123; return; &#125; data[i] = data[i] + data[j]; data[j] = data[i] - data[j]; data[i] = data[i] - data[j]; &#125; public static void selectionSort(int[] arr) &#123; int min; for (int i = 0; i &lt; arr.length; i++) &#123; min = i; for (int j = i; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; if(min!=i)&#123; swap(arr,min,i); &#125; &#125; printArray(arr); &#125;&#125; JavaScript: 123456789101112131415161718let numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];function selection_sort(arr)&#123; let min = 0 ; for(let i = 0 ;i&lt; arr.length;i++)&#123; min = i ; for(let j=i;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[min])&#123; min = j ; &#125; &#125; if(min != i)&#123; [arr[i],arr[min]]=[arr[min],arr[i]] &#125; &#125; console.log(arr.join());&#125;selection_sort(numbers) Python: 12345678910111213numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];def selection_sort(numbers): for i in range(len(numbers)): min=i for j in range(i,len(numbers)): if numbers[min] &gt; numbers[j]: min=j if min != i : numbers[i],numbers[min] = numbers[min],numbers[i] print(numbers)selection_sort(numbers) C++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#define GET_LEN(array, len) \\ &#123; \\ len = sizeof(array) / sizeof(array[0]); \\ &#125;void swap(int &amp;a ,int &amp;b)&#123; a = a^b ; b = a^b ; a = a^b ;&#125;void selection_sort(int numbers[],int length)&#123; int min = 0 ; for (int i = 0; i &lt; length ; i++) &#123; min=i; for (int j = i; j &lt; length ; j++) &#123; if (numbers[min] &gt; numbers[j]) &#123; min = j ; &#125; &#125; if(min != i)&#123; swap(numbers[min],numbers[i]); &#125; &#125; for (int i = 0; i &lt; length; i++) &#123; std::cout &lt;&lt; numbers[i] &lt;&lt; &quot;,&quot;; &#125;&#125;int main()&#123; int numbers[] = &#123;82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75&#125;; int length; GET_LEN(numbers, length); selection_sort(numbers,length); return 0;&#125; 插入排序插入排序(En) 插入排序(CH) Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main &#123; public static void main(String[] args) &#123; int[] numbers = getIntArray(); insertionSort(numbers); &#125; private static int[] getIntArray() &#123; Random random = new Random(); int length = 20; int[] numbers = new int[length]; for (int i = 0; i &lt; length; i++) &#123; numbers[i] = random.nextInt(100); &#125; return numbers; &#125; public static void printArray(int[] arr) &#123; IntStream.of(arr).forEach(x -&gt; System.out.print(&quot;,&quot; + x)); System.out.println(); &#125; private static void swap(int[] data, int i, int j) &#123; if (i == j) &#123; return; &#125; data[i] = data[i] + data[j]; data[j] = data[i] - data[j]; data[i] = data[i] - data[j]; &#125; public static void insertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int insertIndex = i ; int temp = arr[i]; for (int j = i; j &gt; 0; j--) &#123; if (temp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; insertIndex = j - 1; &#125; &#125; arr[insertIndex] = temp; &#125; printArray(arr); &#125;&#125; JavaScript: 123456789101112131415161718let numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];function insertion_sort(arr)&#123; for(let i = 0 ;i&lt; arr.length;i++)&#123; let index = j ; let key = arr[i] ; for(let j=i;j&gt;0;j--)&#123; if(key&lt;arr[j-1])&#123; arr[j] = arr[j-1] ; index = j-1; &#125; &#125; arr[index] = key ; &#125; console.log(arr.join());&#125;insertion_sort(numbers) python: 1234567891011121314numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];def insertion_sort(numbers): for i in range(len(numbers)): key = numbers[i] index = i for j in range(i,0,-1): if key &lt; numbers[j-1]: numbers[j] = numbers[j-1] index = j-1 numbers[index] = key print(numbers)insertion_sort(numbers) C++ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#define GET_LEN(array, len) \\ &#123; \\ len = sizeof(array) / sizeof(array[0]); \\ &#125;void insertion_sort(int numbers[],int length)&#123; for (int i = 0; i &lt; length ; i++) &#123; int index=i; int key = numbers[i]; for (int j = i; j &gt; 0 ; j--) &#123; if (key &lt; numbers[j-1]) &#123; numbers[j] = numbers[j-1] ; index= j-1 ; &#125; &#125; numbers[index]= key ; &#125; for (int i = 0; i &lt; length; i++) &#123; std::cout &lt;&lt; numbers[i] &lt;&lt; &quot;,&quot;; &#125;&#125;int main()&#123; int numbers[] = &#123;82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75&#125;; int length; GET_LEN(numbers, length); insertion_sort(numbers,length); return 0;&#125; 快速排序快速排序(En) 快速排序(CH) 快速排序需要注意的是，不要太过于看重左右节点交换的过程，每一趟排序只是为了分成左右两个子段。比如可以不用左右交换，直接从头到尾遍历，遇到比key小的值就放到key的左边，这样子也可以得到结果 Java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Main &#123; public static void main(String[] args) &#123; int[] numbers = getIntArray(); quickSort(numbers); &#125; private static int[] getIntArray() &#123; Random random = new Random(); int length = 20; int[] numbers = new int[length]; for (int i = 0; i &lt; length; i++) &#123; numbers[i] = random.nextInt(100); &#125; return numbers; &#125; public static void printArray(int[] arr) &#123; IntStream.of(arr).forEach(x -&gt; System.out.print(&quot;,&quot; + x)); System.out.println(); &#125; public static void quickSort(int[] arr) &#123; quicksortInternal(arr, 0, arr.length - 1); printArray(arr); &#125; private static void quicksortInternal(int[] arr, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int index = quicksortPartion(arr, start, end); quicksortInternal(arr, start, index - 1); quicksortInternal(arr, index + 1, end); &#125; private static int quicksortPartion(int[] arr, int start, int end) &#123; int pivot = arr[start]; while (start &lt; end) &#123; while (arr[end] &gt;= pivot &amp;&amp; start != end) &#123; end--; &#125; arr[start] = arr[end]; while (arr[start] &lt;= pivot &amp;&amp; start != end) &#123; start++; &#125; arr[end] = arr[start]; &#125; arr[start] = pivot; return start; &#125; // 这里也可以模仿下面的js方法写 public static void quickSort2(int[] numbers)&#123; List&lt;Integer&gt; arr = Arrays.stream(numbers).boxed().collect(Collectors.toList()); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(arr.size()); quickSortInternal2(arr,list); System.out.println(list.toString()); &#125; public static void quickSortInternal2(List&lt;Integer&gt; arr,List&lt;Integer&gt; result)&#123; if(arr.size() == 0)&#123; return; &#125; if(arr.size() == 1)&#123; result.add(arr.get(0)); return; &#125; quickSortInternal2(arr.stream().filter(x -&gt; x &lt; arr.get(0)).collect(Collectors.toList()),result); result.addAll(arr.stream().filter(x -&gt; x.equals(arr.get(0))).collect(Collectors.toList())); quickSortInternal2(arr.stream().filter(x -&gt; x &gt; arr.get(0)).collect(Collectors.toList()),result); &#125;&#125; JavaScript: 12345678910111213141516171819202122232425262728293031323334353637383940let numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];function quick_sort(arr)&#123; quick_sort_internal(arr,0,arr.length-1); console.log(arr.join());&#125;function quick_sort_internal(arr,lo,hi)&#123; if(lo &gt;= hi)&#123; return ; &#125; let index = (function(arr,lo,hi)&#123; let pivot = arr[lo]; while(lo &lt; hi)&#123; while(arr[hi] &gt;= pivot &amp;&amp; lo &lt; hi )&#123; hi--; &#125; arr[lo] = arr[hi] while(arr[lo] &lt;= pivot &amp;&amp; lo &lt; hi)&#123; lo++; &#125; arr[hi] = arr[lo]; &#125; arr[lo] = pivot; return lo; &#125;)(arr,lo,hi) quick_sort_internal(arr,lo,index-1); quick_sort_internal(arr,index+1,hi);&#125;quick_sort(numbers)//第二种方法。。。const qsort = xs =&gt; xs.length===0?xs: [ ...qsort(xs.filter(x=&gt;x&lt;xs[0])), ...xs.filter(x=&gt;x===xs[0]), ...qsort(xs.filter(x=&gt;x&gt;xs[0]))]qsort([...numbers]) Python: 123456789101112131415161718192021222324252627282930numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];def quick_sort(numbers): quick_sort_internal(numbers,0,len(numbers)-1) print(numbers) def quick_sort_internal(numbers,lo,hi): if lo &gt;= hi : return index = quick_sort_partition(numbers,lo,hi) print(&#x27;index =&#x27; + str(index) ) quick_sort_internal(numbers,lo,index-1) quick_sort_internal(numbers,index+1,hi)def quick_sort_partition(numbers,lo,hi): pivot = numbers[lo] while lo&lt;hi: while numbers[hi] &gt;= pivot and lo &lt; hi : hi=hi-1 numbers[lo]=numbers[hi] while numbers[lo] &lt;= pivot and lo &lt; hi : lo=lo+1 numbers[hi] = numbers[lo] numbers[lo] = pivot return loquick_sort(numbers[:])## 这里也可以模仿上面的js方法写 C++: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#define GET_LEN(array, len) \\ &#123; \\ len = sizeof(array) / sizeof(array[0]); \\ &#125;int quick_sort_partition(int numbers[] ,int lo,int hi)&#123; int pivot = numbers[lo]; while( lo &lt; hi)&#123; while( numbers[hi] &gt;= pivot &amp;&amp; lo &lt; hi)&#123; hi--; &#125; numbers[lo] = numbers[hi]; while( numbers[lo] &lt;= pivot &amp;&amp; lo &lt; hi)&#123; lo++; &#125; numbers[hi] = numbers[lo]; &#125; numbers[lo] = pivot ; return lo ;&#125;void quick_sort_internal(int numbers[],int lo,int hi)&#123; if(lo &gt;= hi)&#123; return; &#125; int index = quick_sort_partition(numbers,lo,hi); quick_sort_internal(numbers,lo,index-1); quick_sort_internal(numbers,index+1,hi);&#125;void quick_sort(int numbers[],int length)&#123; quick_sort_internal(numbers,0,length-1); for (int i = 0; i &lt; length; i++) &#123; std::cout &lt;&lt; numbers[i] &lt;&lt; &quot;,&quot;; &#125;&#125;int main()&#123; int numbers[] = &#123;82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75&#125;; int length; GET_LEN(numbers, length); quick_sort(numbers,length); return 0;&#125; 希尔排序Java: 1 JavaScript: 1 Python 1 C++: 1 归并排序归并排序(En) 归并排序(CH) Java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class Main &#123; public static void main(String[] args) &#123; int[] numbers = getIntArray(); quickSort(numbers); &#125; private static int[] getIntArray() &#123; Random random = new Random(); int length = 20; int[] numbers = new int[length]; for (int i = 0; i &lt; length; i++) &#123; numbers[i] = random.nextInt(100); &#125; return numbers; &#125; public static void printArray(int[] arr) &#123; IntStream.of(arr).forEach(x -&gt; System.out.print(&quot;,&quot; + x)); System.out.println(); &#125; public static void mergeSort(int[] numbers) &#123; mergeSortInternal(numbers, 0, numbers.length - 1); printArray(numbers); &#125; public static void mergeSortInternal(int[] numbers, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int middle = (start + end) / 2; mergeSortInternal(numbers, start, middle); mergeSortInternal(numbers, middle+1, end);// mergeLeftAndRight(numbers, start, end); merge(numbers, start,middle, end); &#125; //正经写法。。 private static void merge(int[] numbers, int left, int middle, int right) &#123; int lp = left; int rp = middle + 1; int tp = 0; int[] temp = new int[right - left + 1]; while (lp &lt;= middle &amp;&amp; rp &lt;= right) &#123; if (numbers[lp] &lt;= numbers[rp]) &#123; temp[tp++] = numbers[lp++]; &#125; else &#123; temp[tp++] = numbers[rp++]; &#125; &#125; while (lp &lt;= middle) &#123; temp[tp++] = numbers[lp++]; &#125; while (rp &lt;= right) &#123; temp[tp++] = numbers[rp++]; &#125; for (int i = 0; i &lt; temp.length; i++) &#123; numbers[i + left] = temp[i]; &#125; &#125; //使用插入排序来合并左右数组，效率会损失 private static void mergeLeftAndRight(int[] numbers, int start, int end) &#123; for (int i = start + 1; i &lt; end + 1; i++) &#123; int insertIndex = i; int temp = numbers[i]; for (int j = i; j &gt; start; j--) &#123; if (temp &lt; numbers[j - 1]) &#123; numbers[j] = numbers[j - 1]; insertIndex = j - 1; &#125; &#125; numbers[insertIndex] = temp; &#125; &#125;&#125; JavaScript: 12345678910111213141516171819202122232425262728293031323334353637let numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];function merge_sort(numbers)&#123; merge_sort_internal(numbers,0,numbers.length-1); console.log(numbers.join());&#125;function merge_sort_internal(numbers,left,right)&#123; if(left &gt;= right)&#123; return; &#125; let middle = Math.floor((left+right)/2); merge_sort_internal(numbers,left,middle); merge_sort_internal(numbers,middle+1,right); (function(numbers,l,m,r)&#123; let lp = l ; let rp = m+1 ; let temp = []; while (lp &lt;= m &amp;&amp; rp &lt;= r) &#123; if (numbers[lp] &lt;= numbers[rp]) &#123; temp.push(numbers[lp++]); &#125; else &#123; temp.push(numbers[rp++]); &#125; &#125; while (lp &lt;= m) &#123; temp.push(numbers[lp++]); &#125; while (rp &lt;= r) &#123; temp.push(numbers[rp++]); &#125; for (let i = 0; i &lt; temp.length; i++) &#123; numbers[i + l] = temp[i]; &#125; &#125;)(numbers,left,middle,right);&#125;merge_sort(numbers) Python 1234567891011121314151617181920212223242526272829303132333435numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];def merge_sort(numbers): merge_sort_internal(numbers,0,len(numbers)-1) print(numbers)def merge_sort_internal(nums,left,right): if left&gt;=right : return middle = int((left+right)/2) merge_sort_internal(nums,left,middle) merge_sort_internal(nums,middle+1,right) merge_left_and_right(nums,left,middle,right)def merge_left_and_right(numbers,l,m,r): lp = l rp = m+1 temp = [] while lp &lt;=m and rp &lt;=r: if numbers[lp] &lt;= numbers[rp] : temp.append(numbers[lp]); lp = lp+1 else : temp.append(numbers[rp]) rp = rp +1 while lp &lt;= m : temp.append(numbers[lp]) lp = lp+1 while rp &lt;= r : temp.append(numbers[rp]) rp = rp+1 for i in range(len(temp)) : numbers[i + l] = temp[i]merge_sort(numbers[:]) C++: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#define GET_LEN(array, len) \\ &#123; \\ len = sizeof(array) / sizeof(array[0]); \\ &#125;void merge_sort_merge(int numbers[] ,int left,int middle,int right)&#123; int lp = left; int rp = middle + 1; int tp = 0; int * temp = new int[right - left + 1]; while (lp &lt;= middle &amp;&amp; rp &lt;= right) &#123; temp[tp++] = numbers[lp] &lt;= numbers[rp] ? numbers[lp++]:numbers[rp++]; &#125; while (lp &lt;= middle) &#123; temp[tp++] = numbers[lp++]; &#125; while (rp &lt;= right) &#123; temp[tp++] = numbers[rp++]; &#125; for (int i = 0; i &lt; right - left + 1; i++) &#123; numbers[i + left] = temp[i]; &#125; delete[] temp;&#125;void merge_sort_internal(int numbers[],int left,int right)&#123; if(left &gt;= right)&#123; return; &#125; int middle = (left+right)/2; merge_sort_internal(numbers,left,middle); merge_sort_internal(numbers,middle+1,right); merge_sort_merge(numbers,left,middle,right);&#125;void merge_sort(int numbers[],int length)&#123; merge_sort_internal(numbers,0,length-1); for (int i = 0; i &lt; length; i++) &#123; std::cout &lt;&lt; numbers[i] &lt;&lt; &quot;,&quot;; &#125;&#125;int main()&#123; int numbers[] = &#123;82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75&#125;; int length; GET_LEN(numbers, length); merge_sort(numbers,length); return 0;&#125; 堆排序堆排序(En) 堆排序(CH) 堆分为大根堆和小根堆。 堆排序则是分为几个步骤： 建堆 建堆有两种方式，一种是对数据从0开始执行插入操作，每次插入后调整。 一种是直接从 len/2 处向0处开始调整，大多数排序都是以这种方式建堆。 交换根节点和最末节点，然后对len-1的数据重新建堆，用大根堆的时候根节点最大，此时此最大值会在最末节点位置处。 重复第二步，直到建堆的数据数量等于1。 Java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Main &#123; public static void main(String[] args) &#123; int[] numbers = getIntArray(); heapSort(numbers); &#125; private static int[] getIntArray() &#123; Random random = new Random(); int length = 20; int[] numbers = new int[length]; for (int i = 0; i &lt; length; i++) &#123; numbers[i] = random.nextInt(100); &#125; return numbers; &#125; public static void printArray(int[] arr) &#123; IntStream.of(arr).forEach(x -&gt; System.out.print(&quot;,&quot; + x)); System.out.println(); &#125; private static void swap(int[] data, int i, int j) &#123; if (i == j) &#123; return; &#125; data[i] = data[i] + data[j]; data[j] = data[i] - data[j]; data[i] = data[i] - data[j]; &#125; public static void heapSort(int[] arr) &#123; int end = arr.length - 1; do &#123; buildMaxHeap(arr, end); swap(arr, 0, end); end--; &#125; while (end &gt; 0); printArray(arr); &#125; private static void buildMaxHeap(int[] arr, int end) &#123; for (int i = end / 2; i &gt;= 0; i--) &#123; HeapAdjust(arr, end, i); &#125; &#125; private static void HeapAdjust(int[] arr, int end, int adjustNode) &#123; int left = 2 * adjustNode + 1; int right = 2 * adjustNode + 2; int maxPosition = adjustNode; if (left &gt; end) &#123; //没有子节点 &#125; else if (right &gt; end) &#123; //只有一个左子节点 if (arr[left] &gt; arr[adjustNode]) &#123; swap(arr, left, adjustNode); maxPosition = left; &#125; &#125; else &#123; int bigger = arr[left] &lt; arr[right] ? right : left; if (arr[adjustNode] &lt; arr[bigger]) &#123; swap(arr, adjustNode, bigger); maxPosition = bigger; &#125; &#125; if (maxPosition != adjustNode) &#123; //说明这个节点没有调整，最终一定会到叶子节点或者无须调整而停止递归 HeapAdjust(arr, end, maxPosition); &#125; &#125;&#125; JavaScript: 1234567891011121314151617181920212223242526272829303132333435363738394041let numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75];function heap_sort(numbers)&#123; let end = numbers.length - 1; do &#123; build_max_heap(numbers, end); [numbers[0],numbers[end]] = [numbers[end],numbers[0]] ; end--; &#125; while (end &gt; 0); console.log(numbers.join());&#125;function build_max_heap(arr,end) &#123; for (let i = Math.floor(end / 2); i &gt;= 0; i--) &#123; heap_adjust(arr, end, i); &#125;&#125;function heap_adjust(arr, end, adjust_node) &#123; let left = 2 * adjust_node + 1; let right = 2 * adjust_node + 2; let maxPosition = adjust_node; if (left &gt; end) &#123; &#125; else if (right &gt; end) &#123; if (arr[left] &gt; arr[adjust_node]) &#123; [arr[left],arr[adjust_node]] = [arr[adjust_node],arr[left]] ; maxPosition = left; &#125; &#125; else &#123; let bigger = arr[left] &lt; arr[right]?right:left; if (arr[adjust_node] &lt; arr[bigger]) &#123; [arr[bigger],arr[adjust_node]] = [arr[adjust_node],arr[bigger]] ; maxPosition = bigger; &#125; &#125; if (maxPosition != adjust_node) &#123; heap_adjust(arr, end, maxPosition); &#125;&#125;heap_sort([...numbers]) Python 1234567891011121314151617181920212223242526272829303132333435numbers = [82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75]def heap_sort(numbers): end = len(numbers) - 1 while True : build_max_heap(numbers, end) numbers[0],numbers[end] = numbers[end],numbers[0] end = end -1 if end &lt; 0 : break print(numbers)def build_max_heap(arr,end) : for i in range(int(end / 2),-1,-1): heap_adjust(arr, end, i)def heap_adjust(arr, end, adjust_node) : left = 2 * adjust_node + 1 right = 2 * adjust_node + 2 maxPosition = adjust_node if left &gt; end : pass elif right &gt; end : if arr[left] &gt; arr[adjust_node] : arr[left],arr[adjust_node] = arr[adjust_node],arr[left] maxPosition = left else : bigger = right if arr[left] &lt; arr[right] else left; if arr[adjust_node] &lt; arr[bigger] : arr[bigger],arr[adjust_node] = arr[adjust_node],arr[bigger] maxPosition = bigger if maxPosition != adjust_node : heap_adjust(arr, end, maxPosition)heap_sort(numbers[:]) C++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#define GET_LEN(array, len) \\ &#123; \\ len = sizeof(array) / sizeof(array[0]); \\ &#125;void swap(int &amp;a ,int &amp;b)&#123; a = a^b ; b = a^b ; a = a^b ;&#125;void heap_adjust(int arr[] ,int end,int adjust_node)&#123; int left = 2 * adjust_node + 1; int right = 2 * adjust_node + 2; int maxPosition = adjust_node; if (left &gt; end) &#123; //没有子节点 &#125; else if (right &gt; end) &#123; //只有一个左子节点 if (arr[left] &gt; arr[adjust_node]) &#123; swap(arr[left], arr[adjust_node]); maxPosition = left; &#125; &#125; else &#123; int bigger = arr[left] &lt; arr[right] ? right : left; if (arr[adjust_node] &lt; arr[bigger]) &#123; swap(arr[adjust_node], arr[bigger]); maxPosition = bigger; &#125; &#125; if (maxPosition != adjust_node) &#123; heap_adjust(arr, end, maxPosition); &#125;&#125;void build_max_heap(int numbers[],int end)&#123; for(int i = end/2 ; i&gt;=0; i--)&#123; heap_adjust(numbers,end,i); &#125;&#125;void heap_sort(int numbers[],int length)&#123; int end = length-1; do&#123; build_max_heap(numbers,end); swap(numbers[0],numbers[end]); end--; &#125;while(end&gt;0); for (int i = 0; i &lt; length; i++) &#123; std::cout &lt;&lt; numbers[i] &lt;&lt; &quot;,&quot;; &#125;&#125;int main()&#123; int numbers[] = &#123;82,37,10,69,1,92,6,13,77,33,47,12,23,82,71,57,58,51,57,75&#125;; int length; GET_LEN(numbers, length); heap_sort(numbers,length); return 0;&#125; 写的时候发现好多基本的语法都全忘光了。。c++的交换，发现用异或来交换可能会导致问题，比如我想象的过程是 123456789arr[0] = 1 ;swap(arr[0],arr[0]) ;a = 1, b=1a = a ^ b = 0b = a ^ b = 0 ^ 1 = 1a = a ^ b = 0 ^ 1 = 1 结果实际执行的是 1234567a = 1, b=aa = a ^ a = 0b = a ^ a = 0 a = a ^ a = 0 另外js和python的版本基本都是直接复制的java的逻辑，没有用上它们特色的函数式编程等方式，比如js版本的快排，虽然它要了更多空间，但是js的那种实现明显更‘地道’.","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"Android控件-RecyclerView3-缓存","slug":"Android控件-RecyclerView3-缓存","date":"2018-09-17T03:01:38.000Z","updated":"2018-11-05T14:15:38.261Z","comments":true,"path":"2018/09/17/Android控件-RecyclerView3-缓存/","link":"","permalink":"http://example.com/2018/09/17/Android%E6%8E%A7%E4%BB%B6-RecyclerView3-%E7%BC%93%E5%AD%98/","excerpt":"RecyclerView的缓存其实更多的是概念性的东西，新增了种类繁多的flag，和listview相比，区分了createViewHolder和bindViewHolder步骤，带来了部分性能上的提升。","text":"RecyclerView的缓存其实更多的是概念性的东西，新增了种类繁多的flag，和listview相比，区分了createViewHolder和bindViewHolder步骤，带来了部分性能上的提升。 123456789101112131415161718192021// Recycler 用来管理 scrapped 或者 detached item views 并且把它们用于重用。// scrapped view 是指依然 attach 到 RecyclerView 但是已经被标记为 remove 或者reuse 的view，这类view可以被重新绑定和使用//通常 Recycler 会被 LayoutManager 用来获取view, 这些view代表adapter中一个特定位置或者ID所对应的的数据。如果将要被重用的//view 被认为是 &quot;dirty&quot; 的，此时会要求adapter重新绑定数据和view，否则这个view可以直接被LayoutManager重用。public final class Recycler &#123; final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2;&#125; ViewHolder定义了一些flag状态，这些状态是RecyclerView缓存的核心内容 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * This ViewHolder has been bound to a position; mPosition, mItemId and mItemViewType * are all valid. ViewHolder 已经绑定到了一个位置，它的数据，mPosition，mItemId和 mItemViewType 都是有效的 */ static final int FLAG_BOUND = 1 &lt;&lt; 0; /** * The data this ViewHolder&#x27;s view reflects is stale and needs to be rebound * by the adapter. mPosition and mItemId are consistent. ViewHolder 的view 对应的数据需要更新和重新绑定，mPosition和mItemId没变 */ static final int FLAG_UPDATE = 1 &lt;&lt; 1; /** * This ViewHolder&#x27;s data is invalid. The identity implied by mPosition and mItemId * are not to be trusted and may no longer match the item view type. * This ViewHolder must be fully rebound to different data. ViewHolder 的数据完全无效，mPosition，mItemId，mItemViewType 都变了，必须重新完全绑定到一个不同的数据 */ static final int FLAG_INVALID = 1 &lt;&lt; 2; /** * This ViewHolder points at data that represents an item previously removed from the * data set. Its view may still be used for things like outgoing animations. ViewHolder 的view 对应的数据被移除了，这个view可能仍然会被用在动画中 */ static final int FLAG_REMOVED = 1 &lt;&lt; 3; /** * This ViewHolder should not be recycled. This flag is set via setIsRecyclable() * and is intended to keep views around during animations. ViewHolder 不应该被回收，用于在动画期间使用 */ static final int FLAG_NOT_RECYCLABLE = 1 &lt;&lt; 4; /** * This ViewHolder is returned from scrap which means we are expecting an addView call * for this itemView. When returned from scrap, ViewHolder stays in the scrap list until * the end of the layout pass and then recycled by RecyclerView if it is not added back to * the RecyclerView. */ static final int FLAG_RETURNED_FROM_SCRAP = 1 &lt;&lt; 5; /** * This ViewHolder is fully managed by the LayoutManager. We do not scrap, recycle or remove * it unless LayoutManager is replaced. * It is still fully visible to the LayoutManager. ViewHolder 完全被 LayoutManager 控制，Recycler 不处理它 */ static final int FLAG_IGNORE = 1 &lt;&lt; 7; /** * When the View is detached form the parent, we set this flag so that we can take correct * action when we need to remove it or add it back. */ static final int FLAG_TMP_DETACHED = 1 &lt;&lt; 8; /** * Set when we can no longer determine the adapter position of this ViewHolder until it is * rebound to a new position. It is different than FLAG_INVALID because FLAG_INVALID is * set even when the type does not match. Also, FLAG_ADAPTER_POSITION_UNKNOWN is set as soon * as adapter notification arrives vs FLAG_INVALID is set lazily before layout is * re-calculated. */ static final int FLAG_ADAPTER_POSITION_UNKNOWN = 1 &lt;&lt; 9; /** * Set when a addChangePayload(null) is called */ static final int FLAG_ADAPTER_FULLUPDATE = 1 &lt;&lt; 10; /** * Used by ItemAnimator when a ViewHolder&#x27;s position changes */ static final int FLAG_MOVED = 1 &lt;&lt; 11; /** * Used by ItemAnimator when a ViewHolder appears in pre-layout */ static final int FLAG_APPEARED_IN_PRE_LAYOUT = 1 &lt;&lt; 12; 虽然缓存机制是RecyclerView提供的，但是它还需要LayoutManager来配合调用相应的方法，在 LinearLayoutManager的 onlayoutChildren 方法里面 调用了 RecyclerView 的 detachAndScrapAttachedViews() : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void detachAndScrapAttachedViews(Recycler recycler) &#123; final int childCount = getChildCount(); for (int i = childCount - 1; i &gt;= 0; i--) &#123; final View v = getChildAt(i); scrapOrRecycleView(recycler, i, v); &#125;&#125;private void scrapOrRecycleView(Recycler recycler, int index, View view) &#123; final ViewHolder viewHolder = getChildViewHolderInt(view); if (viewHolder.shouldIgnore()) &#123; if (DEBUG) &#123; Log.d(TAG, &quot;ignoring view &quot; + viewHolder); &#125; return; &#125; if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved() &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123; removeViewAt(index); recycler.recycleViewHolderInternal(viewHolder); &#125; else &#123; detachViewAt(index); recycler.scrapView(view); mRecyclerView.mViewInfoStore.onViewDetached(viewHolder); &#125;&#125; void scrapView(View view) &#123; final ViewHolder holder = getChildViewHolderInt(view); if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID) || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123; if (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) &#123; throw new IllegalArgumentException(&quot;Called scrap view with an invalid view.&quot; + &quot; Invalid views cannot be reused from scrap, they should rebound from&quot; + &quot; recycler pool.&quot; + exceptionLabel()); &#125; holder.setScrapContainer(this, false); mAttachedScrap.add(holder); &#125; else &#123; if (mChangedScrap == null) &#123; mChangedScrap = new ArrayList&lt;ViewHolder&gt;(); &#125; holder.setScrapContainer(this, true); mChangedScrap.add(holder); &#125;&#125; detachAndScrapAttachedViews会对 RecyclerView所有的 可见view 进行scrap或者 recycle 操作，同时满足三个条件的viewHolder会被recycle，否则会被scrap: viewHolder被标记为无效了，一个典型的场景就是adapter调用了notifydatasetChanged()方法，调用markKnownViewsInvalid()对所有的holder添加 invalidate 和 update标记。 viewHolder对应的item 没有被移除出adapter Adapter没有指定hasStableIds，默认没有指定 对于recycle的viewHolder,如果能够添加到 mCachedViews，则添加进去，否则添加到 RecycledViewPool 里面去。mCachedViews有一个默认最大值是2，如果超过了，会把位置0的数据放到 RecycledViewPool 里面去 对于被scrap的viewHolder又做了两种区分，被标记为 FLAG_REMOVED|FLAG_INVALID 或者 没有 FLAG_UPDATE 标记 或者 canReuseUpdatedViewHolder()的holder会被添加到 mAttachedScrap ，否则添加到 mChangedScrap 。这里完全没看出来这两种有什么区别，在使用上，获取viewHolder缓存的时候， prelayout 阶段会先从 mChangedScrap 中去查找， 其他阶段会跳过 mChangedScrap 直接从 mAttachedScrap 中查找。 在LinearLayoutManager的onlayoutChildren方法中，添加view的时候会尝试去获取viewHolder,最终会调用到Recycler的获取缓存的方法中： 123456789101112//LinearLayoutManager::layoutChunkvoid layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); ...&#125;//Recycler::tryGetViewHolderForPositionByDeadlineViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; ...&#125; 在 tryGetViewHolderForPositionByDeadline 中，就是尝试依次从各种缓存里面取出viewHolder的过程，如果是从 RecyclerPool 或者 createViewHolder 中取得的VH,都是未绑定的状态，此时一定会执行bind操作，对于其他的来源(scrap,hiddenview,cached)，则会根据条件筛选来决定是不是要执行bind操作。这里就是与ListView区别的地方了，listView在getView方法中会全部重新绑定一遍数据，这里是如果VH带有update标记或者invalidate标记才重新bind,否则这个VH包含的view可以直接使用。 对于RecyclerView其实还有很多的东西，比如position的计算过程，滑动中的缓存过程，嵌套滑动的处理，这些有空再看","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[{"name":"列表控件","slug":"列表控件","permalink":"http://example.com/tags/%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6/"}],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"翻译--RecyclerView Animations","slug":"翻译-RecyclerView-Animations","date":"2018-09-12T02:11:35.000Z","updated":"2018-11-05T14:45:25.575Z","comments":true,"path":"2018/09/12/翻译-RecyclerView-Animations/","link":"","permalink":"http://example.com/2018/09/12/%E7%BF%BB%E8%AF%91-RecyclerView-Animations/","excerpt":"原文是 RecyclerView 的作者写的，解释了这个控件里面的一些概念。这里翻译一下(注意这是旧的源码，例如新的版本中layout分成了三步而不是两步，大致是把这里提到的prelayout拆分成了step1和step2)","text":"原文是 RecyclerView 的作者写的，解释了这个控件里面的一些概念。这里翻译一下(注意这是旧的源码，例如新的版本中layout分成了三步而不是两步，大致是把这里提到的prelayout拆分成了step1和step2) 第一部分ListView 是Android里面最受欢迎的控件之一，即使它有许多的功能和特性，但是使用起来非常复杂并且很难自定义。随着UI的进化和手机的发展，这个缺点开始越来越明显。通过实现一些简单的约定，我们可以控制很多行为： items是怎么布局的 动画 item 装饰 回收策略… 当然，这种灵活性的代价也伴随着更复杂的类结构，同时，也有更多的东西需要学习。 在这片文章里面，我将会深入RecyclerView的内部细节，特别是动画是怎么运作的。 在 Honeycomb 版本的时候，Android Framework 引入了 LayoutTransition 动画，它可以非常容易的把 ViewGroup 内部的的变化通过动画表现出来。 它工作的方式是在ViewGroup布局变化的前后分别取一个快照，然后创造一个动画集合来表示这两种状态的变化过程。这种方式和RecycleView对Adapter的变化所执行的动画的原理是类似的。 不幸的是，LayoutTransitions动画和list有点不兼容，主要是list里面的子条目和ViewGroup里面的子view不一样。用对views使用的这一套动画机制去对items使用时，理解这个区别非常重要。 在正常的ViewGroup中，如果一个view是刚被添加到视图树的，那么它就可以被当作新添加的view然后执行相应的动画(比如淡入效果).对于视图集合来说，情况有点不一样。 比如，一个子条目的view变的可见可能是因为它前面的某个子条目被从adapter中移出了。在这种情况下，为新的item 执行一个淡入动画可能会导致一些误解，因为它本来就是在list中的，虽然这个view是刚刚在屏幕中可见。RecyclerView知道这个item是不是新添加的，但是如果item不是新添加的，它就不知道这个item之前在哪里(注:意思是没有缓存view的引用？)。同样的情况也发生在view消失的时候，RecyclerView不知道这个view会到那里去如果它没有被从Adapter中移出的话。 为了解决这个问题，RecyclerView 可以向 LayoutManager 请求新出现的view 的之前的位置。虽然这样做可行，但这会需要在LayoutManager中存一些记录，并且对于一些更复杂的LayoutManager来说这些记录计算起来可能会很麻烦。 RecyclerView用来处理item显示和消失动画(指对list中过去和现在一直都存在的items所对应的views执行出现和消失的动画)的方法是通过layoutManager来执行预布局逻辑。一方面来说，RecyclerView想要在这次变化之前知道这些view被布局在哪里，另一方面，如果LayoutManager把当前不可见的view布局出来，RecyclerView想要知道在这次变化之后这些view将会被布局到哪里。 为了使 LayoutManager 更容易的提供这些信息，当adapter有应该执行动画的数据变化的时候，RecyclerView 通过两个步骤来处理。这两个步骤是： 在第一步（preLayout阶段），RecyclerView 要求 LayoutManager依据额外的信息来局部之前的状态，对于上面的例子来说，这个意思是告诉它 “重新布局这些items,顺便说下，C已经被移除了”.LayoutManager 则正常运行布局过程，但是它知道C将会被移除掉，所以它会用view把C空出来的过程填充起来。这个过程中比较有趣的部分是，RecyclerView依然表现的好像C仍然在Adapter中一样，如果这时候LayoutManager请求在位置2的view,RecyclerView会返回C的view给它(getViewForPosition(2) == View(‘C’))，如果LayoutManager请求位置4的view，RecyclerView会返回E对应的view给它（虽然现在Adapter中D是第四个(注:这里好像有错？C移除后D是第三个了))，返回的view的LayoutParams有个isItemRemoved方法，LayoutManager可以用它来检查这个view是不是对应一个马上要消失的item。 在第二步（postLayout阶段）,RecyclerView 会请求 LayoutManager 重新布局它的子条目。这一次“C”已经不在Adapter中了，getViewForPosition(2)会返回“D”，getViewForPosition(4)会返回“F”，记住，这时候子条目C已经从Adapter中移除了，但是因为RecyclerView仍然持有C对应的View的引用，所以它可以表现的仿佛C依然在一样。换句话说，RecyclerView也会对LayoutManager做记录 每次LayoutManager调用onLayoutChildren的时候，它都会先暂时的detach掉所有的view然后再从scratch中取出来重新布局。没有变化的view会被scrap缓存中返回回来，它们的测量结果依然有效，所以对这种view的重新布局会相对简单。 LinearLayoutManager preLayout的结果: (红色部分表示对用户可见的区域)* LinearLayoutManager postlayout的结果 在这两个阶段过后，RecyclerView知道了View从哪里来，所以可以执行正确的动画。 你可能会问，C对应的View都没有被LayoutManager布局了，它怎么还是可见的？ 需要明确说明的是，在pre-layout阶段LayoutManager依然布局C的原因是它看起来仍然在Adapter，在post-layout阶段LayoutManager不布局的原因则是C的确不在Adapter里面了。对于LayoutManger来说C不再是它的子view了，但是对RecyclerView来说却不是这样。当一个view被从LayoutManager中移除的时候，如果 ItemAnimator想要它执行动画，RecyclerView会仍然把它作为一个子view(这样子动画才能够正常执行)。更多的细节在第二部分会描述。 消失子条目的处理在两个阶段执行以后，RecyclerView 可以正确的执行添加动画了，但现在还有个问题就是消失动画。考虑一下下面的情况，当一个新的item被添加到list中，会导致其他的一些子条目被挤出可见区域，动画过程如下： 当X被添加到A之后的时候，会导致F被挤出屏幕外，因为LayoutManager不会布局F，所以LayoutTransition认为它被UI移除了然后执行一个淡出动画，实际上，F仍然在adapter中但是被推出了可见区域而已。 为了解决这个问题，RecyclerView为Layoutmanager提供了一些额外的api来获取这些信息。在postlayout阶段的末尾，LayourManager可以调用getScrapList来获取出于这种情况下的view列表（没有被LayoutManager布局出来但是仍然在adapter中),然后它仍然会布局这些view,就好像RecyclerView很大可以容纳他们一样。 LinearLayoutManager postLayout的结果: (红色部分表示对用户可见的区域)* 一个重要的细节是，由于这些view在动画结束后就没必要存在了，LayoutManager会调用addDisappearingView而不是addView。这会告诉RecyclerView，这个view应该在动画结束后移除掉。这个view会被RecyclerView添加到hidden views，因此它会在这个方法调用结束后马上从LayoutManager的子view列表中移除掉。通过这种方式，LayoutManager可以清除掉它。 刚开始的时候，你可能认为 LayoutManager 可以计算出 View 从哪里来或者要去哪里，这样子就不需要两个layout步骤来计算了。不幸的是，在同一个步骤中，如果adapter的多种类型发生变化，会有很多边界情况发生。对于一个更复杂的LayoutManager（比如StaggeredGridLayout)来说，计算一个Item放在哪个位置不是一件容易的事情，通过两步layout的方式可以为LayoutManager减轻很多压力并且能够很容易的支持合适的动画而不用花太多力气。 目前位置，我已经提到了RecyclerView中预处理动画的原理的主要内容，但对于LayoutManager来说仍然有很多事情要做。你可以在第二部分了解到背后仍然需要做的事情。 第二部分 RecyclerView 即使在一些child 被LayoutManager移除掉的时候依然保持它们的attached状态，具体的过程是什么？这样不会破坏RecyclerView和 LayoutManager 之间的状态吗？ 是的，在某种程度上的确有点这个意思，但是： RecyclerView 的确保留了它们作为ViewGroup的子view,但是把它们都对LayoutManager隐藏了，每次LayoutManager调用方法获取它们的children的时候，RecyclerView会把隐藏的view也考虑在内（是指考虑屏蔽）。让我们看一下part 1 中 C被移出adapter的例子： 在这里C淡出了，如果LayoutManager调用getChildCount(),RecyclerView会返回6虽然它有7个children,如果LayoutManager调用getChildAt(int),Recycler会进行合适的偏移来跳过C（或者任何隐藏的children）。如果LayoutManager调用addView(view,position),RecyclerView也会在ViewGroup调用addView之前进行适当的偏移。 当动画结束的时候，RecyclerView会移出这个View然后回收它 更多的细节你可以看ChildHelper这个内部类的实现 在Pre-layout阶段，RecyclerView对item的位置是怎么处理的？这时候item在Adapter中的位置不一样。 这得益于adapter新增的特定事件的通知，当Adapter派发notify xx 事件的时候，RecyclerView会记录它们并且为这个变化请求一次布局，在下一个布局阶段之前到来的事件都会在一起执行。 当onLayout被系统调用的时候，RecyclerView执行以下步骤： 对这些事件重新排序，把move事件放到事件list的末尾。移动move事件到结尾仅仅是一个简化步骤，因此这里不打算讨论它的细节。你可以在OpReorderer类中找到感兴趣的细节。 按顺序一个一个处理事件，并且更新已经存在的ViewHolder的位置。如果一个ViewHolder被移除掉，它也会被标记为移除状态。当这么做的时候，RecyclerView也会决定adapter数据的变化是不是要在preLayout步骤之前或者之后分发给LayoutManager,这个过程如下： 如果是一个add操作，它会被延期执行因为item不应该在preLayout阶段存在。 如果是一个update或者remove操作并且这个操作会影响到已经存在的ViewHolder，这个操作会被推迟执行。如果这个操作不会影响到已经存在的ViewHolder,它就会被分发到LayoutManager，这是因为RecyclerView不能复现这个item之前的状态（它没有代表这个item之前的状态的ViewHolder） 如果是一个move操作，它会被延期执行因为RecyclerView可以在prelayout阶段弄一个假的位置。比如，如果把位置3的item移动到位置5，在prelayout阶段如果位置3的view被请求的话，RecyclerView返回位置5的view RecyclerView会在必要的时候重写这些操作。比如，一个更新或者删除操作影响到了一些ViewHolder,RecyclerView会拆分这些操作。如果一个操作应该被分发给LayoutManager但是一个延迟的操作会影响它，RecyclerView会重排序这些操作使它们依然是一致的。 比如说，如果有一个在位置3添加1的操作，这个操作被延迟了，紧接着有一个不能被延迟的删除位置5的1的操作，RecyclerView会把删除位置4的1分发给LayoutManager，这么做是因为Adapter在添加1到位置3之后执行删除位置5的1并且通知它。因此RecyclerView没有告诉layoutManager关于添加1到位置3的事情，它重写了remove操作来保证一致。 这种做法使得对于layoutManager来说追踪一个item会很容易。adapter和layoutManager之间的抽象关系使得这一切称为可能，因此ReclcyclerView不需要把Adapter的引用传给layoutManager,相反的，RecyclerView提供了一些通过State和Recycler类来接触Adapter的方法。 ViewHolders也有它们自己的旧位置，prelayout位置和最终adpater位置。当viewHolder.getPosition被调用的时候，它们会返回prelayout位置或者最终adapter位置，这取决于当时处在layout的哪个状态（pre 还是post).LayoutManager不需要知道这些因为它总是保持和之前的分发给它的事件保持一致。 在Adapter的更新处理完后，RecyclerView保存已经存在的View的位置和大小信息并在之后把它们用于动画。 RecyclerView在preLayout阶段会调用LayoutManager.onLayoutChildren，在上一段中提到过，layoutmanager会执行它的正常layout逻辑，它要做的就是为更多的比如正在删除或者变化的item(isItemRemoved,isItemChanged)进行布局，删除的或者变化的item依然出现在Adapter提供给LayoutManager的api中。这种情况下，layoutManager仅仅是把它们当作普通的view来处理 在pre-layout结束后，RecyclerView再次记录这些view的位置信息然后把剩下的Adapter 更新分发给LayoutManager. RecyclerView 再次调用layoutManager的 onLayout（postLayout阶段），这一次，在postlayout结束后，所有的item的位置都会和adapter中的数据一致，layoutManager再次执行正常的布局逻辑 postLayout结束后，RecycerView再次检查view的位置信息，然后决定哪些item是add,remove,changed,moved.它会隐藏掉remove的view,并且把没有添加到LayoutManager的view添加到RecyclerView（因为要执行动画）. 要执行动画的items会被传给ItemAnimator来开始动画效果。动画结束后，Item Animator调用一个回调告诉RecyclerView移除和回收不再需要的view 如果LayoutManager 在内部数据结构中使用item 的位置信息会发生什么？ 因为RecyclerView会重写adapter的变化，layoutManager要做的就是当一个adapter数据变化的回调到来的时候更新它自己的记录。RecyclerView保证这些更新会在合适的时机以合适的顺序调用。 在layout的任何时间点，如果layoutManager想要获取Adapter的一些额外数据，它可以调用Recycler.convertPreLayoutPositionToPostLayout来获取item在adapter中的位置。比如，GridLayoutManager就使用了这个接口来获取item的信息。 notifyDataSetChanged 被调用的时候会发生什么?预处理动画会执行吗？ 不会，这是为什么notifyDataSetChanged应该是你最后才考虑调用的方法。当notifyDataSetChanged调用的时候，RecyclerView无法知道items移动到哪里去了因此它没法正确的模拟getViewForPosition的调用。此时它仅仅是执行一个普通布局容器动画将会做的事情 第三部分( 这里是我自己加的 ) 为什么要执行多次layout ? 为了正确的执行动画，所以必须知道条目的信息，包括数据改变之前和之后的，主要是记录position对应的holder和 RecyclerView.State，对于默认的实现DefaultAnimation()来说，主要是用到了top和left，translationX等，可见SimpleAnimation类的animateChange()方法，对于之前的，为什么不直接拿当前的信息呢？只能猜测是为了要recyclerview最初的状态，当前状态可能是用户交互过的，view的信息可能已经变化了，在step1中完成 ，对于之后的，就是拿新数据layout更新一次可以拿到，在step2中完成。 notifyItemXXX 和 notifyDataSetChanged 的区别？ 主要区别还是在于执行动画，对于notifyDataSetChanged，一般来说不执行动画(Recyclerview的dispatchLayoutStep1中做的判断），而对于 notifyItemXXX ，则根据 item变化的类型决定是不是要执行动画，此时RecyclerView其实也并不知道data数据集哪里变化了，需要开发者主动去告诉它，哪个item insert,remove等等，如果你在data list尾部插入数据，然后notifyItemInsert(0),这时候数据也会错乱，RecyclerView会误认为data list的0位置是新插入的数据，然后生成位置0对应的view,插入进去。。","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[{"name":"列表控件","slug":"列表控件","permalink":"http://example.com/tags/%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6/"}],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"Android控件-RecyclerView2-ItemDecoration","slug":"Android控件-RecyclerView2-ItemDecoration","date":"2018-09-10T03:35:32.000Z","updated":"2018-11-05T14:15:34.541Z","comments":true,"path":"2018/09/10/Android控件-RecyclerView2-ItemDecoration/","link":"","permalink":"http://example.com/2018/09/10/Android%E6%8E%A7%E4%BB%B6-RecyclerView2-ItemDecoration/","excerpt":"在 RecyclerView 中， 我们可以通过 recyclerView.addItemDecoration() 的方式添加 ItemDecoration ，比如下划线，字母索引等。","text":"在 RecyclerView 中， 我们可以通过 recyclerView.addItemDecoration() 的方式添加 ItemDecoration ，比如下划线，字母索引等。 使用自己实现 ItemDecoration ,只需要实现两个方法: 123456789101112static class Example extends RecyclerView.ItemDecoration&#123; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125;&#125; 其中 onDraw() 提供了一个canvas 用于绘制，getItemOffsets则提供了设置 ItemDecoration 大小的机会，以官方的 DividerItemDecoration 为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; private void drawVertical(Canvas canvas, RecyclerView parent) &#123; canvas.save(); final int left; final int right; //noinspection AndroidLintNewApi - NewApi lint fails to handle overrides. if (parent.getClipToPadding()) &#123; left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right, parent.getHeight() - parent.getPaddingBottom()); &#125; else &#123; left = 0; right = parent.getWidth(); &#125; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(child.getTranslationY()); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); &#125; canvas.restore(); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; if (mDivider == null) &#123; outRect.set(0, 0, 0, 0); return; &#125; if (mOrientation == VERTICAL) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125;&#125;static void getDecoratedBoundsWithMarginsInt(View view, Rect outBounds) &#123; final LayoutParams lp = (LayoutParams) view.getLayoutParams(); final Rect insets = lp.mDecorInsets; outBounds.set(view.getLeft() - insets.left - lp.leftMargin, view.getTop() - insets.top - lp.topMargin, view.getRight() + insets.right + lp.rightMargin, view.getBottom() + insets.bottom + lp.bottomMargin);&#125; 在 drawVertical() 中，先是根据 getClipToPadding() 来判断，要不要把Item绘制到 RecyclerView 的padding 里面，顺便做一个过度绘制的优化，然后调用 getDecoratedBoundsWithMargins() 取得 bottom 的值用于计算绘制的区域，计算的时候用到了 lp.mDecorInsets ，在单个ItemDecoration的情况下，这个值就是在 getItemOffsets() 中设置的 outRect 的值 。需要注意的是，虽然 outRect 的数据结构表示一个矩形，但是这里实际上是表示在child四个方向上的距离值，可以理解为setpadding(left,top,right,bottom),这么命名实在是很让人混乱。。 在这里可以看到，对于简单的分割线，这里只是为每一个 child 绘制了下面的区域 ,其他的区域也都是设置为0.官方的接口其实就只是提供了你绘制的区域(这个还要自己计算)和canvas,让你自己去绘制。关于使用，就是这些了，下面看一下 RecyclerView 是怎么调用这些方法的。 原理一般来说，作为容器 Container 基本上只需要绘制自己的 background 的， RecyclerView 继承了 ViewGroup 后给我们使用的不仅仅是一个容器，还带了点私货，这个私货就是 itemDecoration , 对于每一个 item , RecyclerView 新定义了 layoutParam，在自己的layoutparams 中保存了一个 mDecorInsets 的变量，用来记载 itemDecoration 的范围。在 measure,layout 的时候都会考虑到这些值进行测量和布局，最后在ondraw里面把 canvas 交给开发者自己去实现。不过它留的接口传的参数实在是怪异，需要知道详情才知道怎么去绘制。 由于child的测量和绘制也是由LayoutManager去自定义实现的，但是系统也提供了LinearLayoutManager等实现，这里以LinearLayoutManager为例： 1234567891011121314151617181920212223242526272829//child的测量 public void measureChildWithMargins(View child, int widthUsed, int heightUsed) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child); widthUsed += insets.left + insets.right; heightUsed += insets.top + insets.bottom; final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width, canScrollHorizontally()); final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom() + lp.topMargin + lp.bottomMargin + heightUsed, lp.height, canScrollVertically()); if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123; child.measure(widthSpec, heightSpec); &#125;&#125;//child的布局public void layoutDecoratedWithMargins(View child, int left, int top, int right,int bottom) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect insets = lp.mDecorInsets; child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin, right - insets.right - lp.rightMargin, bottom - insets.bottom - lp.bottomMargin);&#125; 可以看到都是把 mDecorInsets 考虑在里面了的，如果我们自定义LayoutManager,也需要考虑到对itemDecoration的支持，不然可能会出现显示问题。 关于 itemDecoration 的绘制，这个就在 RecyclerView 的 ondraw() 函数里面，非常简单： 12345678public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 如果有多个 ItemDecoration , 会依次绘制，这个需要每一个 ItemDecoration 自己计算好绘制的区域。 另外一个方法 getItemOffset() 的唯一调用处： 123456789101112131415161718192021222324Rect getItemDecorInsetsForChild(View child) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (!lp.mInsetsDirty) &#123; return lp.mDecorInsets; &#125; if (mState.isPreLayout() &amp;&amp; (lp.isItemChanged() || lp.isViewInvalid())) &#123; // changed/invalid items should not be updated until they are rebound. return lp.mDecorInsets; &#125; final Rect insets = lp.mDecorInsets; insets.set(0, 0, 0, 0); final int decorCount = mItemDecorations.size(); for (int i = 0; i &lt; decorCount; i++) &#123; mTempRect.set(0, 0, 0, 0); mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState); insets.left += mTempRect.left; insets.top += mTempRect.top; insets.right += mTempRect.right; insets.bottom += mTempRect.bottom; &#125; lp.mInsetsDirty = false; return insets;&#125; 这里仅仅是取了每一种 ItemDecoration 类的 getItemOffsets() 传进来的 rect 数据，然后依次叠加，只有一种 ItemDecoration 的时候，rect 其实就是 mDecorInsets 的值。","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[{"name":"列表控件","slug":"列表控件","permalink":"http://example.com/tags/%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6/"}],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"Android控件总结2","slug":"Android控件总结2","date":"2018-09-05T08:28:37.000Z","updated":"2018-11-05T14:17:06.200Z","comments":true,"path":"2018/09/05/Android控件总结2/","link":"","permalink":"http://example.com/2018/09/05/Android%E6%8E%A7%E4%BB%B6%E6%80%BB%E7%BB%932/","excerpt":"再上一篇中，分析了整体上的流程，这里来分析下细节性的问题。","text":"再上一篇中，分析了整体上的流程，这里来分析下细节性的问题。 onMeasure()中的 MeasureSpec 是怎么来的？ 在之前的流程中，通过requestLayout() 触发 performTravsals(),在 performTravsals() 里面会可能多次调用 performMeasure(...),而 performMeasure(...) 会调用mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);进入到view和它的子控件的层层调用中，这里的mView在Activity等中就是指DecoreView，在自己创建的window中就是setView()传的view，这里就是最初的源头了。 performMeasure中传入的参数来源 : 12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&#x27;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; 这里的 windowSize 是指wms计算后返回的window的大小，而rootDimension则是相应的window的windowManager.Layoutparam,(未验证)值是ViewGroup.LayoutParams.MATCH_PARENT(未验证)，对于Activity来说，这里得到的最初的参数应该是size = 分辨率大小减去状态栏，导航栏)，mode = MeasureSpec.EXACTLY。在ViewGroup中为子控件生成measureSpec的默认方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 这里返回的值最终会传给子view的 onMeasure()方法，可以看到，生成的值是受到父控件和子控件共同控制的。因此 MeasureSpec 最初是屏幕的分辨率，而后传给子控件的过程中会根据 父控件和子控件 的参数发生变化。","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"Android控件-RecyclerView","slug":"Android控件-RecyclerView","date":"2018-09-05T06:40:47.000Z","updated":"2018-11-05T14:15:30.368Z","comments":true,"path":"2018/09/05/Android控件-RecyclerView/","link":"","permalink":"http://example.com/2018/09/05/Android%E6%8E%A7%E4%BB%B6-RecyclerView/","excerpt":"RecyclerView 是谷歌官方推出的控件，可以完全取代listView,根据不同的layoutManager实现不同的显示效果。这里 有一个谷歌的RecyclerView视频介绍","text":"RecyclerView 是谷歌官方推出的控件，可以完全取代listView,根据不同的layoutManager实现不同的显示效果。这里 有一个谷歌的RecyclerView视频介绍 ，里面提到ListView的主要问题在于，它只是知道数据变了却不知道哪里变了，因此难以设置动画， RecyclerView 则很好的解决了这个问题。然后是listview生成view的时候还需要开发者去写contentView相关的代码，很麻烦，RecyclerView 中则不需要。 这里打算按照操作顺序来阅读。对RecyclerView的基本使用是: 12345678910111213141516171819202122RecyclerView recyclerView = new RecyclerView(this);recyclerView.setLayoutManager(new LinearLayoutManager(this));recyclerView.setAdapter(new RecyclerView.Adapter() &#123; @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; TextView textView = new TextView(parent.getContext()); textView.setText(&quot;123&quot;); return new RecyclerView.ViewHolder(textView) &#123; &#125;; &#125; @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123; &#125; @Override public int getItemCount() &#123; return 3; &#125;&#125;); 首先是调用了构造函数，构造函数里面初始化了一些变量，这个没什么好说的， 123456789public RecyclerView(...) &#123; super(context, attrs, defStyle); ... setWillNotDraw(getOverScrollMode() == View.OVER_SCROLL_NEVER); mItemAnimator.setListener(mItemAnimatorListener); initAdapterManager(); initChildrenHelper(); ...&#125; 其中，AdapterHelper主要用来处理Adapter的操作，入队，更新等并且通过callback回调回RecyclerView来。它还定义了一个内部类UpdateOp，用来封装数据的增删改和移动的操作，并且维护了一个UpdateOp的数组。 ChildHelper则主要帮助RecyclerView来管理子view,它内部维护了一个 List mHiddenViews 数组。 然后是setLayoutManager: 1234567891011121314151617181920212223242526272829public void setLayoutManager(LayoutManager layout) &#123; if (layout == mLayout) &#123; return; &#125; stopScroll(); // TODO We should do this switch a dispatchLayout pass and animate children. There is a good // chance that LayoutManagers will re-use views. if (mLayout != null) &#123; ... &#125; else &#123; mRecycler.clear(); &#125; // this is just a defensive measure for faulty item animators. mChildHelper.removeAllViewsUnfiltered(); mLayout = layout; if (layout != null) &#123; if (layout.mRecyclerView != null) &#123; throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout + &quot; is already attached to a RecyclerView:&quot; + layout.mRecyclerView.exceptionLabel()); &#125; mLayout.setRecyclerView(this); if (mIsAttached) &#123; mLayout.dispatchAttachedToWindow(this); &#125; &#125; mRecycler.updateViewCacheSize(); requestLayout();&#125; 这里就是把 mLayout 赋值给 RecyclerView ，同时也把 RecyclerView 的引用交给 mLayout 。需要注意的是如果这个时候RecyclerView已经attach到窗口了，会再分发一次dispatchAttachedToWindow()消息。最后调用了requestLayout() 然后是 recyclerView.setAdapter(): 1234567public void setAdapter(Adapter adapter) &#123; // bail out if layout is frozen setLayoutFrozen(false); setAdapterInternal(adapter, false, true); processDataSetCompletelyChanged(false); requestLayout();&#125; 这里主要的流程当然是setAdapterInternal(adapter, false, true),不过还是先看看setLayoutFrozen()和requestLayout(),后面会反复用到里面的变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//采用类似引用技术的方式来控制 requestLayout() 的调用，本身 requestLayout() 是有防止重复调用的机制的，这里为了提高效率减少刷新又增加了一层机制private int mInterceptRequestLayoutDepth = 0;// 如果 mInterceptRequestLayoutDepth == 0 并且 mLayoutFrozen是false，才真正requestLayout// 否则 仅仅是把标志位mLayoutWasDefered改成false@Overridepublic void requestLayout() &#123; if (mInterceptRequestLayoutDepth == 0 &amp;&amp; !mLayoutFrozen) &#123; super.requestLayout(); &#125; else &#123; mLayoutWasDefered = true; &#125;&#125;void startInterceptRequestLayout() &#123; mInterceptRequestLayoutDepth++; if (mInterceptRequestLayoutDepth == 1 &amp;&amp; !mLayoutFrozen) &#123; mLayoutWasDefered = false; &#125;&#125;void stopInterceptRequestLayout(boolean performLayoutChildren) &#123; if (mInterceptRequestLayoutDepth &lt; 1) &#123; //noinspection PointlessBooleanExpression if (DEBUG) &#123; throw new IllegalStateException(&quot;stopInterceptRequestLayout was called more &quot; + &quot;times than startInterceptRequestLayout.&quot; + exceptionLabel()); &#125; mInterceptRequestLayoutDepth = 1; &#125; if (!performLayoutChildren &amp;&amp; !mLayoutFrozen) &#123; // Reset the layout request eaten counter. // This is necessary since eatRequest calls can be nested in which case the other // call will override the inner one. // for instance: // eat layout for process adapter updates // eat layout for dispatchLayout // a bunch of req layout calls arrive mLayoutWasDefered = false; &#125; if (mInterceptRequestLayoutDepth == 1) &#123; // when layout is frozen we should delay dispatchLayout() if (performLayoutChildren &amp;&amp; mLayoutWasDefered &amp;&amp; !mLayoutFrozen &amp;&amp; mLayout != null &amp;&amp; mAdapter != null) &#123; dispatchLayout(); &#125; if (!mLayoutFrozen) &#123; mLayoutWasDefered = false; &#125; &#125; mInterceptRequestLayoutDepth--;&#125;/*** True if a call to requestLayout was intercepted and prevented from executing like normal and* we plan on continuing with normal execution later.* True表示一个requestLayout调用被拦截了，后面会在合适的时候执行 requestLayout*/boolean mLayoutWasDefered;// setAdapter的时候会调用 setLayoutFrozen(false)，其他地方暂时没看到。public void setLayoutFrozen(boolean frozen) &#123; if (frozen != mLayoutFrozen) &#123; assertNotInLayoutOrScroll(&quot;Do not setLayoutFrozen in layout or scroll&quot;); if (!frozen) &#123; mLayoutFrozen = false; if (mLayoutWasDefered &amp;&amp; mLayout != null &amp;&amp; mAdapter != null) &#123; requestLayout(); &#125; mLayoutWasDefered = false; &#125; else &#123; final long now = SystemClock.uptimeMillis(); MotionEvent cancelEvent = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); onTouchEvent(cancelEvent); mLayoutFrozen = true; mIgnoreMotionEventTillDown = true; stopScroll(); &#125; &#125;&#125; 总结一下， 上面这几步基本就是初始化一些变量，然后requestLayout()更新界面。接下来则会进入onMeasure()流程，中间的具体过程可以参考 Android控件总结 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879protected void onMeasure(int widthSpec, int heightSpec) &#123; if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec); return; &#125; if (mLayout.isAutoMeasureEnabled()) &#123; final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); /** * This specific call should be considered deprecated and replaced with * &#123;@link #defaultOnMeasure(int, int)&#125;. It can&#x27;t actually be replaced as it could * break existing third party code but all documentation directs developers to not * override &#123;@link LayoutManager#onMeasure(int, int)&#125; when * &#123;@link LayoutManager#isAutoMeasureEnabled()&#125; returns true. */ mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; if (measureSpecModeIsExactly || mAdapter == null) &#123; return; &#125; if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); &#125; // set dimensions in 2nd step. Pre-layout should happen with old dimensions for // consistency mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); // if RecyclerView has non-exact width and height and if there is at least one child // which also has non-exact width &amp; height, we have to re-measure. if (mLayout.shouldMeasureTwice()) &#123; mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); &#125; &#125; else &#123; ... &#125; void defaultOnMeasure(int widthSpec, int heightSpec) &#123; // calling LayoutManager here is not pretty but that API is already public and it is better // than creating another method since this is internal. final int width = LayoutManager.chooseSize(widthSpec, getPaddingLeft() + getPaddingRight(), ViewCompat.getMinimumWidth(this)); final int height = LayoutManager.chooseSize(heightSpec, getPaddingTop() + getPaddingBottom(), ViewCompat.getMinimumHeight(this)); setMeasuredDimension(width, height); &#125; public static int chooseSize(int spec, int desired, int min) &#123; final int mode = View.MeasureSpec.getMode(spec); final int size = View.MeasureSpec.getSize(spec); switch (mode) &#123; case View.MeasureSpec.EXACTLY: return size; case View.MeasureSpec.AT_MOST: return Math.min(size, Math.max(desired, min)); case View.MeasureSpec.UNSPECIFIED: default: return Math.max(desired, min); &#125; &#125;&#125; 因为 LinearLayoutManager 的 mLayout.isAutoMeasureEnabled()方法直接返回了true,因此这里只看这个分支。这里面首先是调用mLayout.onMeasure()得到 defaultOnMeasure()拿到一个默认值。然后是一个判断跳过的条件，如果RecyclerView的长宽measure mode 都是 MeasureSpec.EXACTLY，那么这个控件的大小就是跟child无关的，可以直接跳过。否则的话直接在这里走 dispatchLayoutStep()的流程，而 dispatchLayoutStep2() 中会添加 childView，添加了之后再次重新 mLayout.setMeasuredDimensionFromChildren().最后判断是不是需要再次测量，再次进行测量的条件是 RecyclerView的长宽 measure mode 都不是 MeasureSpec.EXACTLY 并且子view的长宽也没有指定具体数值。 看一下 dispatchLayoutStep1 和 dispatchLayoutStep2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * The first step of a layout where we; * - process adapter updates * - decide which animation should run * - save information about current views * - If necessary, run predictive layout and save its information */private void dispatchLayoutStep1() &#123; mState.assertLayoutStep(State.STEP_START); fillRemainingScrollValues(mState); mState.mIsMeasuring = false; startInterceptRequestLayout(); mViewInfoStore.clear(); onEnterLayoutOrScroll(); processAdapterUpdatesAndSetAnimationFlags(); // step 1 and step 2 saveFocusInfo(); mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged; mItemsAddedOrRemoved = mItemsChanged = false; mState.mInPreLayout = mState.mRunPredictiveAnimations; mState.mItemCount = mAdapter.getItemCount(); findMinMaxChildLayoutPositions(mMinMaxLayoutPositions); if (mState.mRunSimpleAnimations) &#123; // Step 0: Find out where all non-removed items are, pre-layout int count = mChildHelper.getChildCount(); for (int i = 0; i &lt; count; ++i) &#123; final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123; continue; &#125; final ItemHolderInfo animationInfo = mItemAnimator .recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads()); mViewInfoStore.addToPreLayout(holder, animationInfo); if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved() &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123; long key = getChangedHolderKey(holder); // This is NOT the only place where a ViewHolder is added to old change holders // list. There is another case where: // * A VH is currently hidden but not deleted // * The hidden item is changed in the adapter // * Layout manager decides to layout the item in the pre-Layout pass (step1) // When this case is detected, RV will un-hide that view and add to the old // change holders list. mViewInfoStore.addToOldChangeHolders(key, holder); &#125; &#125; &#125; if (mState.mRunPredictiveAnimations) &#123; // Step 1: run prelayout: This will use the old positions of items. The layout manager // is expected to layout everything, even removed items (though not to add removed // items back to the container). This gives the pre-layout position of APPEARING views // which come into existence as part of the real layout. // Save old positions so that LayoutManager can run its mapping logic. saveOldPositions(); final boolean didStructureChange = mState.mStructureChanged; mState.mStructureChanged = false; // temporarily disable flag because we are asking for previous layout mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = didStructureChange; for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123; final View child = mChildHelper.getChildAt(i); final ViewHolder viewHolder = getChildViewHolderInt(child); if (viewHolder.shouldIgnore()) &#123; continue; &#125; if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123; int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder); boolean wasHidden = viewHolder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (!wasHidden) &#123; flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; &#125; final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation( mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads()); if (wasHidden) &#123; recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo); &#125; else &#123; mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo); &#125; &#125; &#125; // we don&#x27;t process disappearing list because they may re-appear in post layout pass. clearOldPositions(); &#125; else &#123; clearOldPositions(); &#125; onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mState.mLayoutStep = State.STEP_LAYOUT;&#125;private void processAdapterUpdatesAndSetAnimationFlags() &#123; if (mDataSetHasChangedAfterLayout) &#123; // Processing these items have no value since data set changed unexpectedly. // Instead, we just reset it. mAdapterHelper.reset(); if (mDispatchItemsChangedEvent) &#123; mLayout.onItemsChanged(this); &#125; &#125; // simple animations are a subset of advanced animations (which will cause a // pre-layout step) // If layout supports predictive animations, pre-process to decide if we want to run them if (predictiveItemAnimationsEnabled()) &#123; mAdapterHelper.preProcess(); &#125; else &#123; mAdapterHelper.consumeUpdatesInOnePass(); &#125; boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged; mState.mRunSimpleAnimations = mFirstLayoutComplete &amp;&amp; mItemAnimator != null &amp;&amp; (mDataSetHasChangedAfterLayout || animationTypeSupported || mLayout.mRequestedSimpleAnimations) &amp;&amp; (!mDataSetHasChangedAfterLayout || mAdapter.hasStableIds()); mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations &amp;&amp; animationTypeSupported &amp;&amp; !mDataSetHasChangedAfterLayout &amp;&amp; predictiveItemAnimationsEnabled();&#125; dispatchLayoutStep1(),第一次在onMeasure()里面执行的时候，因为这个时候 childview 还没有添加进来，很多逻辑都会跳过，此时会把step设置成 STEP_LAYOUT ，后面再次执行 onMeasure() 的时候， dispatchLayoutStep1() 主要做了两件事，一个是处理adapter数据的变化，这个主要是通过 mAdapterHelper.preProcess()来完成的，主要是把操作队列中 item 的 MOVE 操作移到最后，然后就是生成一个 animationInfo 数据并且把它保存在 mViewInfoStore 中。 dispatchLayoutStep2()，这里则是layoutChild实际执行的地方，会对child 执行 measure ，addview 和 layout 操作 ,出于灵活性的考虑，这里RecyclerView并没有实现，而是交给了 layout.onLayoutChildren() 方法去实现它，这样子就可以有不同的显示效果。需要注意的是这个方法可能会被调用多次，因此如果是自定义实现LayoutManager的话需要考虑到这种情况避免重复添加和layout。 在onMeasure()执行完之后，接下来会进入到 onLayout() : 123456789101112131415161718192021222324252627282930313233343536protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; if (mAdapter == null) &#123; Log.e(TAG, &quot;No adapter attached; skipping layout&quot;); // leave the state in START return; &#125; if (mLayout == null) &#123; Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;); // leave the state in START return; &#125; mState.mIsMeasuring = false; if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; // First 2 steps are done in onMeasure but looks like we have to run again due to // changed size. mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3();&#125; onLayout() 里面首先是 更新 mIsMeasuring 的状态为false,然后是根据 mState.mLayoutStep 来决定是不是要重新执行 dispatchLayoutStep1() 和 dispatchLayoutStep2() , 因为 mState.mLayoutStep 在 dispatchLayoutStep3() 中会被重置为STEP_START，所以这里其实是为了保障1和3有序执行。如果layout里面保存的宽高和 RecyclerView当前的宽高不一致(意思是大小变化了)，则会重新进入dispatchLayoutStep2()再次执行 layout.onLayoutChildren() 方法。然后执行 dispatchLayoutStep3() ，最后更新 mFirstLayoutComplete 为true : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 private void dispatchLayoutStep3() &#123; mState.assertLayoutStep(State.STEP_ANIMATIONS); eatRequestLayout(); onEnterLayoutOrScroll(); mState.mLayoutStep = State.STEP_START; if (mState.mRunSimpleAnimations) &#123; // Step 3: Find out where things are now, and process change animations. // traverse list in reverse because we may call animateChange in the loop which may // remove the target view holder. for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123; ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore()) &#123; continue; &#125; long key = getChangedHolderKey(holder); final ItemHolderInfo animationInfo = mItemAnimator .recordPostLayoutInformation(mState, holder); ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key); if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123; // run a change animation // If an Item is CHANGED but the updated version is disappearing, it creates // a conflicting case. // Since a view that is marked as disappearing is likely to be going out of // bounds, we run a change animation. Both views will be cleaned automatically // once their animations finish. // On the other hand, if it is the same view holder instance, we run a // disappearing animation instead because we are not going to rebind the updated // VH unless it is enforced by the layout manager. final boolean oldDisappearing = mViewInfoStore.isDisappearing( oldChangeViewHolder); final boolean newDisappearing = mViewInfoStore.isDisappearing(holder); if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123; // run disappear animation instead of change mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; else &#123; final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout( oldChangeViewHolder); // we add and remove so that any post info is merged. mViewInfoStore.addToPostLayout(holder, animationInfo); ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder); if (preInfo == null) &#123; handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); &#125; else &#123; animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing); &#125; &#125; &#125; else &#123; mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; &#125; // Step 4: Process view info lists and trigger animations mViewInfoStore.process(mViewInfoProcessCallback); &#125; mLayout.removeAndRecycleScrapInt(mRecycler); mState.mPreviousLayoutItemCount = mState.mItemCount; mDataSetHasChangedAfterLayout = false; mState.mRunSimpleAnimations = false; mState.mRunPredictiveAnimations = false; mLayout.mRequestedSimpleAnimations = false; if (mRecycler.mChangedScrap != null) &#123; mRecycler.mChangedScrap.clear(); &#125; if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123; // Initial prefetch has expanded cache, so reset until next prefetch. // This prevents initial prefetches from expanding the cache permanently. mLayout.mPrefetchMaxCountObserved = 0; mLayout.mPrefetchMaxObservedInInitialPrefetch = false; mRecycler.updateViewCacheSize(); &#125; mLayout.onLayoutCompleted(mState); onExitLayoutOrScroll(); resumeRequestLayout(false); mViewInfoStore.clear(); if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123; dispatchOnScrolled(0, 0); &#125; recoverFocusFromState(); resetFocusInfo();&#125; step3 首先是重置 layoutStep为 State.STEP_START，这样下次可以进入step1()了，然后是保存当前的 animationInfo 信息(此时已经经过step2添加了childview,信息会有变化)，然后根据 状态信息的变化调用 animateChange() 触发动画的执行。之后是清理，重置相关的变量，为下一次 dispathLayout() 做准备。 最后是 onDraw() 方法，不过搜索 onDraw() 方法的时候却发现 RecyclerView 还重写了 draw() 方法,回顾一下控件的整个一般性流程： 结合 RecyclerView 中的代码: 123456789101112131415161718192021222324252627282930313233@Override public void draw(Canvas c) &#123; super.draw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDrawOver(c, this, mState); &#125; ... // If some views are animating, ItemDecorators are likely to move/change with them. // Invalidate RecyclerView to re-draw decorators. This is still efficient because children&#x27;s // display lists are not invalidated. if (!needsInvalidate &amp;&amp; mItemAnimator != null &amp;&amp; mItemDecorations.size() &gt; 0 &amp;&amp; mItemAnimator.isRunning()) &#123; needsInvalidate = true; &#125; if (needsInvalidate) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; @Override public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125; &#125; 可以看到，这里的调用顺序是 进入 draw(c) ,先调用 super.draw(c) 开始走 onDraw() 流程 , 然后 dispatchDraw() 分发给子view 去绘制自己， 最后再接着调用 onDrawOver() 进行回调。绘制的流程中主要是 ItemDecoration 的绘制，这个在下一篇说。","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[{"name":"列表控件","slug":"列表控件","permalink":"http://example.com/tags/%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6/"}],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"Android NestedScrolling","slug":"Android-NestedScrolling","date":"2018-09-03T02:27:57.000Z","updated":"2018-11-05T14:13:46.548Z","comments":true,"path":"2018/09/03/Android-NestedScrolling/","link":"","permalink":"http://example.com/2018/09/03/Android-NestedScrolling/","excerpt":"NestedScrolling 是谷歌推出的用于解决嵌套滑动的解决方案，在CoordinatorLayout中有使用。在 sdk api 21 之后，直接更新到了 View 和 ViewGroup源码里面，同时也在android.support.v4 包中提供了两个接口NestedScrollingChild和NestedScrollingParent, 还和两个辅助类 NestedScrollingChildHelper 和 NestedScrollingParentHelper 用来帮助开发者实现相关功能. 因此在 sdk21之后 系统原生控件是直接支持嵌套滑动的，如果自己需要实现，用那几个相关类就可以了。","text":"NestedScrolling 是谷歌推出的用于解决嵌套滑动的解决方案，在CoordinatorLayout中有使用。在 sdk api 21 之后，直接更新到了 View 和 ViewGroup源码里面，同时也在android.support.v4 包中提供了两个接口NestedScrollingChild和NestedScrollingParent, 还和两个辅助类 NestedScrollingChildHelper 和 NestedScrollingParentHelper 用来帮助开发者实现相关功能. 因此在 sdk21之后 系统原生控件是直接支持嵌套滑动的，如果自己需要实现，用那几个相关类就可以了。 原理在Android触摸事件的处理中，无论是父类还是子类，一旦拦截了 Action_DOWN ,后续的事件都会发给这个控件，出于兼容的目的，这个流程不会大改，想要在滑动的过程中父类和子类联动，于是新增了接口方法，在 ACITION_MOVE 中进行调用，并且不改变整个onInterceptTouchEvent()和onTouchEvent()的返回值，这样既不会影响到原有流程，又可以让父类和子类进行交互。对于 Fling 的处理则是在 ACTION_UP 中，这个应该很好理解~ 主要的过程则是子控件接收到滑动一段距离的请求时, 先询问父控件是否要滑动, 如果滑动了父控件就通知子控件它消耗了一部分滑动距离, 子控件就处理剩下的滑动距离, 然后子控件滑动完毕后再把剩余的滑动距离传给父控件.这个过程由子控件发起。 主要类和方法NestedScrollingChild startNestedScroll : 起始方法, 主要作用是找到接收滑动距离信息的父控件. dispatchNestedPreScroll : 在内控件处理滑动前把滑动信息分发给父控件. dispatchNestedScroll : 在内控件处理完滑动后把剩下的滑动距离信息分发给父控件. stopNestedScroll : 结束方法, 主要作用就是清空嵌套滑动的相关状态 NestedScrollingChildHelper是对NestedScrollingChild的方法的实现 NestedScrollingParent父控件接口主要是定义了一些响应子控件的方法，以onXXXXX命名和子控件的方法一一对应。 NestedScrollingParentHelper是对NestedScrollingParent的方法的实现 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Begin a nestable scroll operation along the given axes. * * &lt;p&gt;A view starting a nested scroll promises to abide by the following contract:&lt;/p&gt; * * &lt;p&gt;The view will call startNestedScroll upon initiating a scroll operation. In the case * of a touch scroll this corresponds to the initial &#123;@link MotionEvent#ACTION_DOWN&#125;. * In the case of touch scrolling the nested scroll will be terminated automatically in * the same manner as &#123;@link ViewParent#requestDisallowInterceptTouchEvent(boolean)&#125;. * In the event of programmatic scrolling the caller must explicitly call * &#123;@link #stopNestedScroll()&#125; to indicate the end of the nested scroll.&lt;/p&gt; * * &lt;p&gt;If &lt;code&gt;startNestedScroll&lt;/code&gt; returns true, a cooperative parent was found. * If it returns false the caller may ignore the rest of this contract until the next scroll. * Calling startNestedScroll while a nested scroll is already in progress will return true.&lt;/p&gt; * * &lt;p&gt;At each incremental step of the scroll the caller should invoke * &#123;@link #dispatchNestedPreScroll(int, int, int[], int[]) dispatchNestedPreScroll&#125; * once it has calculated the requested scrolling delta. If it returns true the nested scrolling * parent at least partially consumed the scroll and the caller should adjust the amount it * scrolls by.&lt;/p&gt; * * &lt;p&gt;After applying the remainder of the scroll delta the caller should invoke * &#123;@link #dispatchNestedScroll(int, int, int, int, int[]) dispatchNestedScroll&#125;, passing * both the delta consumed and the delta unconsumed. A nested scrolling parent may treat * these values differently. See &#123;@link ViewParent#onNestedScroll(View, int, int, int, int)&#125;. * &lt;/p&gt; * * @param axes Flags consisting of a combination of &#123;@link #SCROLL_AXIS_HORIZONTAL&#125; and/or * &#123;@link #SCROLL_AXIS_VERTICAL&#125;. * @return true if a cooperative parent was found and nested scrolling has been enabled for * the current gesture. * * @see #stopNestedScroll() * @see #dispatchNestedPreScroll(int, int, int[], int[]) * @see #dispatchNestedScroll(int, int, int, int, int[]) */ public boolean startNestedScroll(int axes) &#123; if (hasNestedScrollingParent()) &#123; // Already in progress return true; &#125; if (isNestedScrollingEnabled()) &#123; ViewParent p = getParent(); View child = this; while (p != null) &#123; try &#123; if (p.onStartNestedScroll(child, this, axes)) &#123; mNestedScrollingParent = p; p.onNestedScrollAccepted(child, this, axes); return true; &#125; &#125; catch (AbstractMethodError e) &#123; Log.e(VIEW_LOG_TAG, &quot;ViewParent &quot; + p + &quot; does not implement interface &quot; + &quot;method onStartNestedScroll&quot;, e); // Allow the search upward to continue &#125; if (p instanceof View) &#123; child = (View) p; &#125; p = p.getParent(); &#125; &#125; return false; &#125; 注释说的很清楚了。。axes: SCROLL_AXIS_HORIZONTAL和SCROLL_AXIS_VERTICAL的值之一。 返回值 : 如果父控件可以响应嵌套滑动并且是enabled状态就返回true 在Action_DWON和onInterceptTouchEvent中调用，表示嵌套滑动的开始，从代码来看，做的仅仅是一直getParent()，如果父类的onStartNestedScroll()返回true,就接着调用onNestedScrollAccepted()进行初始化，否则继续向上寻找，没找到返回false。 后续应该调用 dispatchNestedPreScroll() ,如果它返回 true 则表示父控件至少消耗的部分或者全部的滑动距离 接着应该调用 dispatchNestedScroll() , 自己处理后再返回给父控件去处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 在子控件消耗任何部分的滑动之前分发嵌套滑动，这个方法给父控件提供了预先处理的机会 * @param dx Horizontal scroll distance in pixels * @param dy Vertical scroll distance in pixels * @param consumed 用于输出的数组。如果不为空，consumed[0]会包含dx的消耗值，consumed[1]是dy的消耗值 * @param offsetInWindow 可选，如果不为空，则返回的值是view在这个方法操作前后的坐标的插值。View可能会用这个值来调整输入坐标值 * @return 只要父控件消耗了滑动的坐标就会返回true */ public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable @Size(2) int[] consumed, @Nullable @Size(2) int[] offsetInWindow) &#123; if (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != null) &#123; if (dx != 0 || dy != 0) &#123; int startX = 0; int startY = 0; if (offsetInWindow != null) &#123; getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; &#125; if (consumed == null) &#123; if (mTempNestedScrollConsumed == null) &#123; mTempNestedScrollConsumed = new int[2]; &#125; consumed = mTempNestedScrollConsumed; &#125; consumed[0] = 0; consumed[1] = 0; mNestedScrollingParent.onNestedPreScroll(this, dx, dy, consumed); if (offsetInWindow != null) &#123; getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; &#125; return consumed[0] != 0 || consumed[1] != 0; &#125; else if (offsetInWindow != null) &#123; offsetInWindow[0] = 0; offsetInWindow[1] = 0; &#125; &#125; return false; &#125; /** * 在子控件消耗任何部分的滑动的时候 分发嵌套滑动，这个方法给父控件提供了后处理的机会，逻辑和上面类似 */ public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable @Size(2) int[] offsetInWindow) &#123; if (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != null) &#123; if (dxConsumed != 0 || dyConsumed != 0 || dxUnconsumed != 0 || dyUnconsumed != 0) &#123; int startX = 0; int startY = 0; if (offsetInWindow != null) &#123; getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; &#125; mNestedScrollingParent.onNestedScroll(this, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (offsetInWindow != null) &#123; getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; &#125; return true; &#125; else if (offsetInWindow != null) &#123; // No motion, no dispatch. Keep offsetInWindow up to date. offsetInWindow[0] = 0; offsetInWindow[1] = 0; &#125; &#125; return false; &#125; 使用上面说的断断续续，其实用起来很容易。 NestedScrollingChild对于 NestedScrollingChild 来说，它需要做的是 ： setNestedScrollingEnabled()设置为true 在ACTION_DOWN中调用 startNestedScroll() 在ACTION_MOVE中调用 dispatchNestedPreScroll() 和 dispatchNestedScroll() 在ACTOPN_UP|ACTION_CANCEL 中看情况调用 stopNestedScroll() 在sdk21之后，View类里面 onTouchEvent() 默认实现了这些步骤，如果不需要重写 onTouchEvent() 的话，本身就是支持这个功能的，如果重写的话，则需要自己看情况加入这些流程的调用。具体的例子可以看 RecyclerView 。作为support包的类，为了兼容性它自己实现了NestedScrollingChild接口，其实也就是调用 NestedScrollingChildHelper 类的相关方法，逻辑和sdk21之后的View的默认实现是类似的。 NestedScrollingParent对于 NestedScrollingParent 来说，它需要做的就是 重写onXXXScroll()方法 ，这个根据不同的控件会有不同的效果，都需要自己去实现，对于sdk21之后的ViewGroup,提供了默认实现，就是直接调用 View的默认实现 dispatchNestedPreScroll() 和 dispatchNestedScroll() 继续向父控件分发，不满足条件则直接返回false,什么也不做。具体的例子可以看 ActionBarOverlayLayout 这个类，不过鉴于这个类不是很熟悉，可以看 ScrollView,SwipeRefreshLayout ，但这两个类都不仅仅可以作为 NestedScrollingParent，也可以作为NestedScrollingChild，看的时候不要弄混了。还有个 CoordinatorLayout，这个又做了一层封装，可以自己选择哪个类把。 后面有空可以自己实现一个来看看效果","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"Android控件-ListView阅读","slug":"Android控件-ListView阅读","date":"2018-09-01T02:32:16.000Z","updated":"2018-11-05T14:15:26.358Z","comments":true,"path":"2018/09/01/Android控件-ListView阅读/","link":"","permalink":"http://example.com/2018/09/01/Android%E6%8E%A7%E4%BB%B6-ListView%E9%98%85%E8%AF%BB/","excerpt":"ListView是早期版本时候的常用控件，虽然现在基本都不用了，但我觉得用来学习肯定会有收获。本来想自己写，但是看到别人已经有写的很好的版本了，鉴于郭神的博客应该不会404，所以这里直接贴链接了。Android ListView工作原理完全解析","text":"ListView是早期版本时候的常用控件，虽然现在基本都不用了，但我觉得用来学习肯定会有收获。本来想自己写，但是看到别人已经有写的很好的版本了，鉴于郭神的博客应该不会404，所以这里直接贴链接了。Android ListView工作原理完全解析 因为不知道内部类怎么画，所以这里用了虚线箭头表示 DataSetObserver 类可以调用到 AdapterView 中。这里 DataSetObservable 和 DataSetObserver 是Java提供的观察者模式的实现类。当我们调用 BaseAdapter.notifyDataSetChanged()的时候，就可以沿着箭头一路找到AdapterView，进而调用到它的子类中去。 AdapterView 和 AbsListView 都是虚基类，其中 AdapterView 提供了 emptyView 和 Adapter 等相关的机制，AbsListView 提供了View复用的 RecycleBin 的机制 。ListView则提供了具体的Layout方法和HeaderView,FooterView等机制。 这里通过观察者模式实现了View和数据的分离，View的操作如果修改了数据，则需要通过BaseAdapter的接口来处理，而BaseAdapter如果数据发生了变动，则通过notifyDataSetChanged()来通知View更新界面。 在ListView的代码中，有点意外的是添加子view的过程是在onLayout中调用的，在 onMeasure() 的时候 ListView 只能通过 Adapter的引用来拿到 itemView ，计算它们的大小。这也表示作为一个容器其实 子view 只是一个概念而已。 对于 Adapter提供的 count() 个数的view, ListView 仅仅添加在界面上显示出来的view作为子view,没有显示出来的甚至不是它的childView。 ListView 在使用 RecycleBin 缓存的时候，使用的是Viewgroup 的 attachview 和 detachView ,这两个方法和 addview ,removeView的区别在于它不会主动要求重绘。 在Listview中设置 emptyView的时候，根本没有把emptyView添加到控件树里面，只是根据 item 的数量来更新 emptyView 的visibility. 123456789/** * * RecycleBin 有两级缓存 ： ActiveViews 和 ScrapViews 。 ActiveViews 是指最初显示在屏幕上的布局中的那些view，layout结束阶* 段，所有的ActiveViews都会降级成 ScrapViews。 ScrapViews 表示旧的views，他们是可能被重用的view的集合。 * * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener) * @see android.widget.AbsListView.RecyclerListener */ class RecycleBin &#123; &#125;","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[{"name":"列表控件","slug":"列表控件","permalink":"http://example.com/tags/%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6/"}],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"Android SystemUI的相关类","slug":"Android-SystemUI的相关类","date":"2018-08-26T15:06:01.000Z","updated":"2018-11-05T14:14:17.363Z","comments":true,"path":"2018/08/26/Android-SystemUI的相关类/","link":"","permalink":"http://example.com/2018/08/26/Android-SystemUI%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B1%BB/","excerpt":"在Android系统中SystemUI是以应用的形式运行在Android系统当中，即编译SystemUI模块会生产APK文件，源代码路径在frameworks/base/packages/SystemUI/，安装路径system/priv-app/-SystemUI。它和普通apk不同的是，它是开机启动的并且不可退出，可以把它理解为一个模块。它为系统提供了基础的显示页面，比如 屏幕顶端的状态栏，屏幕底部的导航栏，壁纸，近期使用app列表，截屏操作，电量监控等功能。","text":"在Android系统中SystemUI是以应用的形式运行在Android系统当中，即编译SystemUI模块会生产APK文件，源代码路径在frameworks/base/packages/SystemUI/，安装路径system/priv-app/-SystemUI。它和普通apk不同的是，它是开机启动的并且不可退出，可以把它理解为一个模块。它为系统提供了基础的显示页面，比如 屏幕顶端的状态栏，屏幕底部的导航栏，壁纸，近期使用app列表，截屏操作，电量监控等功能。 状态栏的创建在Android开机流程的一部分，会调用到ams的systemReady()通知ams已经准备就绪。 以下代码基于android-27,SystemUI每个大版本都有比较大的重构和变化，比如在最新的9.0的master分支中， SERVICE 名单被配置到xml中去了，在看代码的时候千万不能看混了（血泪的代价=。= 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161mActivityManagerService.systemReady(() -&gt; &#123; Slog.i(TAG, &quot;Making services ready&quot;); ... try &#123; startSystemUi(context, windowManagerF); &#125; catch (Throwable e) &#123; reportWtf(&quot;starting System UI&quot;, e); &#125; ...&#125;static final void startSystemUi(Context context, WindowManagerService windowManager) &#123; Intent intent = new Intent(); intent.setComponent(new ComponentName(&quot;com.android.systemui&quot;, &quot;com.android.systemui.SystemUIService&quot;)); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); //Slog.d(TAG, &quot;Starting service: &quot; + intent); context.startServiceAsUser(intent, UserHandle.SYSTEM); windowManager.onSystemUiStarted();&#125;public class SystemUIService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); ((SystemUIApplication) getApplication()).startServicesIfNeeded(); ... &#125;&#125;public void startServicesIfNeeded() &#123; startServicesIfNeeded(SERVICES);&#125;private final Class&lt;?&gt;[] SERVICES = new Class[] &#123; Dependency.class, NotificationChannels.class, CommandQueue.CommandQueueStart.class, KeyguardViewMediator.class, Recents.class, VolumeUI.class, Divider.class, SystemBars.class, StorageNotification.class, PowerUI.class, RingtonePlayer.class, KeyboardUI.class, PipUI.class, ShortcutKeyDispatcher.class, VendorServices.class, GarbageMonitor.Service.class, LatencyTester.class, GlobalActionsComponent.class,&#125;;private void startServicesIfNeeded(Class&lt;?&gt;[] services) &#123; ... final int N = services.length; for (int i = 0; i &lt; N; i++) &#123; Class&lt;?&gt; cl = services[i]; if (DEBUG) Log.d(TAG, &quot;loading: &quot; + cl); try &#123; Object newService = SystemUIFactory.getInstance().createInstance(cl); mServices[i] = (SystemUI) ((newService == null) ? cl.newInstance() : newService); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException(ex); &#125; mServices[i].mContext = this; mServices[i].mComponents = mComponents; if (DEBUG) Log.d(TAG, &quot;running: &quot; + mServices[i]); mServices[i].start(); if (mBootCompleted) &#123; mServices[i].onBootCompleted(); &#125; &#125;&#125;public class SystemBars extends SystemUI &#123; // in-process fallback implementation, per the product config private SystemUI mStatusBar; @Override public void start() &#123; createStatusBarFromConfig(); &#125; private void createStatusBarFromConfig() &#123; if (DEBUG) Log.d(TAG, &quot;createStatusBarFromConfig&quot;); // R.string.config_statusBarComponent 的值是 com.android.systemui.statusbar.phone.StatusBar final String clsName = mContext.getString(R.string.config_statusBarComponent); if (clsName == null || clsName.length() == 0) &#123; throw andLog(&quot;No status bar component configured&quot;, null); &#125; Class&lt;?&gt; cls = null; try &#123; cls = mContext.getClassLoader().loadClass(clsName); &#125; catch (Throwable t) &#123; throw andLog(&quot;Error loading status bar component: &quot; + clsName, t); &#125; try &#123; mStatusBar = (SystemUI) cls.newInstance(); &#125; catch (Throwable t) &#123; throw andLog(&quot;Error creating status bar component: &quot; + clsName, t); &#125; mStatusBar.mContext = mContext; mStatusBar.mComponents = mComponents; mStatusBar.start(); if (DEBUG) Log.d(TAG, &quot;started &quot; + mStatusBar.getClass().getSimpleName()); &#125;&#125;public class StatusBar extends SystemUI implements ...&#123; public void start() &#123; ... mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); mWindowManagerService = WindowManagerGlobal.getWindowManagerService(); mBarService = IStatusBarService.Stub.asInterface( ServiceManager.getService(Context.STATUS_BAR_SERVICE)); mCommandQueue = getComponent(CommandQueue.class); createAndAddWindows(); mBarService.registerStatusBar(mCommandQueue,...); mCommandQueue.addCallbacks(this); ... &#125; public void createAndAddWindows() &#123; addStatusBarWindow(); &#125; private void addStatusBarWindow() &#123; makeStatusBarView(); mStatusBarWindowManager = Dependency.get(StatusBarWindowManager.class); mRemoteInputController = new RemoteInputController(mHeadsUpManager); mStatusBarWindowManager.add(mStatusBarWindow, getStatusBarHeight()); &#125; protected void makeStatusBarView() &#123; ... boolean showNav = mWindowManagerService.hasNavigationBar(); if (DEBUG) Log.v(TAG, &quot;hasNavigationBar=&quot; + showNav); if (showNav) &#123; createNavigationBar(); &#125; ... &#125; public int getStatusBarHeight() &#123; if (mNaturalBarHeight &lt; 0) &#123; final Resources res = mContext.getResources(); //其中 R.dimen.status_bar_height 的值为 24dp mNaturalBarHeight =res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height); &#125; return mNaturalBarHeight; &#125;&#125; 上面的过程简化成图就是这样： 值得提到的是，SERVICES里面的那些类，并不是真的Service,它们只是继承了 SystemUI 这个虚基类实现了 onstart()方法而已，可以理解为类似于WindowManager的一个本地服务类(仅仅是为了与wms,ams这些系统服务区分开来)，最后在addStatusBarWindow()方法里面创建了window并且把view添加上去完成了状态栏的创建。 在 StatusBar 的 启动过程中，会把 CommandQueue 对象传给 StatusBarManagerService 保存为mBar，类型为bp端，因此当客户端通过 ServiceManager 拿到 StatusBarManagerService 这个系统服务的接口时，就可以通过 mBar 来调用 CommandQueue 对象的方法，而 CommandQueue 则通过callback回调消息给 StatusBar ，这样子就可以更新状态栏了。 状态栏的xml视图整个View视图： 常规状态栏界面这个状态栏结构还是挺简单的，由 CollapsedStatusBarFragment 控制， 从左到右依次是 mNotificationIconArea(里面包含mNotificationIcons)用于显示通知图标，mSystemIconArea(好像没有发现有添加图标进去)，statusIcons，mSignalClusterView(信号)，BatteryMeterView(电池)，Clock(时间) 展开状态栏界面状态栏2的视图由 QSFragment 控制，有收起和展开状态。其中 QSPannel 区域则重叠了很多视图，包括点击 TileRecord.view 弹出的 mQSDetail，点击 FootImpl的edit按钮弹出的 Edit界面 (mQSCustomizer)，以及当前显示出来的界面，在收起状态下为 HeaderTileLayout ，展开状态下为 PagedTileLayout ，这两个View都实现了同一个接口。 其中 PagedTileLayout是一个ViewPager，它的页面是一个自定义View,TilePage。 下面的区域没有细看，应该是 NotificationStackScrollLayout ，用来显示通知详情的 锁屏状态栏界面略 发送通知消息的过程1234567891011121314151617181920212223242526272829// NotificationManager:: notify public void notify(int id, Notification notification) &#123; notify(null, id, notification); &#125; /** * Post a notification to be shown in the status bar. If a notification with * the same tag and id has already been posted by your application and has not yet been * canceled, it will be replaced by the updated information. * * @param tag A string identifier for this notification. May be &#123;@code null&#125;. * @param id An identifier for this notification. The pair (tag, id) must be unique * within your application. * @param notification A &#123;@link Notification&#125; object describing what to * show the user. Must not be null. */ public void notify(String tag, int id, Notification notification) &#123; notifyAsUser(tag, id, notification, new UserHandle(UserHandle.myUserId())); &#125; public void notifyAsUser(String tag, int id, Notification notification, UserHandle user) &#123; INotificationManager service = getService(); ... service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id,copy, user.getIdentifier()); ... &#125; 需要注意的是这里的 INotificationManager ， NotificationManagerService 并没有直接实现INotificationManager.Stub,而是继承了SystemService，包含了一个INotificationManager.Stub类型的成员变量，并且把它注册到了SystemService中，也就是说 NotificationManagerService 实际上是 INotificationManager.Stub 这个系统服务的管理类，当调用service.enqueueNotificationWithTag(...)的时候，会进入到这个成员变量类的方法里面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//NotificationManagerService::mService::enqueueNotificationWithTag()public void enqueueNotificationWithTag(String pkg, String opPkg, String tag, int id, Notification notification, int userId) throws RemoteException &#123; enqueueNotificationInternal(pkg, opPkg, Binder.getCallingUid(), Binder.getCallingPid(), tag, id, notification, userId);&#125;void enqueueNotificationInternal(final String pkg, final String opPkg, final int callingUid, final int callingPid, final String tag, final int id, final Notification notification, int incomingUserId) &#123; ... // 权限，pid，重复 等检查 mHandler.post(new EnqueueNotificationRunnable(userId, r)); &#125;protected class EnqueueNotificationRunnable implements Runnable &#123; ... @Override public void run() &#123; synchronized (mNotificationLock) &#123; ... // tell the assistant service about the notification if (mAssistants.isEnabled()) &#123; mAssistants.onNotificationEnqueued(r); mHandler.postDelayed(new PostNotificationRunnable(r.getKey()), DELAY_FOR_ASSISTANT_TIME); &#125; else &#123; mHandler.post(new PostNotificationRunnable(r.getKey())); &#125; &#125; &#125; &#125;&#125;protected class PostNotificationRunnable implements Runnable &#123; ... @Override public void run() &#123; synchronized (mNotificationLock) &#123; ... NotificationRecord old = mNotificationsByKey.get(key); final StatusBarNotification n = r.sbn; final Notification notification = n.getNotification(); int index = indexOfNotificationLocked(n.getKey()); if (index &lt; 0) &#123; mNotificationList.add(r); mUsageStats.registerPostedByApp(r); &#125; else &#123; old = mNotificationList.get(index); mNotificationList.set(index, r); mUsageStats.registerUpdatedByApp(r, old); // Make sure we don&#x27;t lose the foreground service state. notification.flags |= old.getNotification().flags &amp; Notification.FLAG_FOREGROUND_SERVICE; r.isUpdate = true; &#125; mNotificationsByKey.put(n.getKey(), r); // Ensure if this is a foreground service that the proper additional // flags are set. if ((notification.flags &amp; Notification.FLAG_FOREGROUND_SERVICE) != 0) &#123; notification.flags |= Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR; &#125; applyZenModeLocked(r); mRankingHelper.sort(mNotificationList); if (notification.getSmallIcon() != null) &#123; StatusBarNotification oldSbn = (old != null) ? old.sbn : null; mListeners.notifyPostedLocked(n, oldSbn); if (oldSbn == null || !Objects.equals(oldSbn.getGroup(), n.getGroup())) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mGroupHelper.onNotificationPosted( n, hasAutoGroupSummaryLocked(n)); &#125; &#125;); &#125; &#125; ... &#125; &#125;&#125; 这一路的Runnable跟下去，发现到最后只是添加通知到mNotificationList并排序，我们知道通知最后是会在状态栏显示一个图标的，从前面的分析和之前版本的Android源码来看，拿到 StatusBarManagerService 就可以更新状态栏，但找来找去没有发现 StatusBarManagerService 的踪影，最后，注意到 mListeners.notifyPostedLocked(n, oldSbn);, 发现mListener类型为NotificationListeners，接下来跟下去： 1234567891011121314151617181920212223public class NotificationListeners extends ManagedServices &#123; public void notifyPostedLocked(StatusBarNotification sbn, StatusBarNotification oldSbn) &#123; for (final ManagedServiceInfo info : getServices()) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; notifyPosted(info, sbnToPost, update); &#125; &#125;); &#125; &#125; private void notifyPosted(final ManagedServiceInfo info, final StatusBarNotification sbn, NotificationRankingUpdate rankingUpdate) &#123; final INotificationListener listener = (INotificationListener) info.service; StatusBarNotificationHolder sbnHolder = new StatusBarNotificationHolder(sbn); try &#123; listener.onNotificationPosted(sbnHolder, rankingUpdate); &#125; catch (RemoteException ex) &#123; Log.e(TAG, &quot;unable to notify listener (posted): &quot; + listener, ex); &#125; &#125;&#125; 这里又出来一个listener，是从ManagedServices.getServices()得到的， 在 ManagedServices 类中搜索，发现 mServices.add() 调用有多处，但都是从 registerService(…) 开始，于是在 NotificationManagerService 中搜索 ManagedServices类型的成员变量mListeners的registerService()方法，发现调用是在 INotificationManager.Stub.registerListener() 方法中: 123456789101112/** * Register a listener binder directly with the notification manager. * * Only works with system callers. Apps should extend * &#123;@link android.service.notification.NotificationListenerService&#125;. */ @Override public void registerListener(final INotificationListener listener, final ComponentName component, final int userid) &#123; enforceSystemOrSystemUI(&quot;INotificationManager.registerListener&quot;); mListeners.registerService(listener, component, userid); &#125; 这里提到 这个方法仅仅供系统直接调用，app应该通过继承 NotificationListenerService 来调用，那么去看 NotificationListenerService 这个类，发现它的registerAsSystemService()方法中刚好调用了INotificationManager.registerListener(),而它传过去的第一个参数是 NotificationListenerWrapper类型的实例mWrapper，也就是上面所找的 INotificationListener listener，原来 listener 的赋值是在这里。那么接着上面的通知发送流程，也就是listener.onNotificationPosted(...),我们看向 mWrapper 的 onNotificationPosted() 方法，发现最终调用到 NotificationListenerService.onNotificationPosted(…) ,而这个方法是空方法… 这个线索断了，我们继续回过头来找 NotificationListenerService.registerAsSystemService()的调用方法，右键 find usages 发现调用回到了 StatusBar.onStart()方法，这才发现 StatusBar有个成员变量 mNotificationListener ，类型为继承了 NotificationListenerService 类的 NotificationListenerWithPlugins类: 12345678910111213141516171819202122232425//StatusBar::Startpublic void start() &#123; ... try &#123; mNotificationListener.registerAsSystemService(...); &#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;Unable to register notification listener&quot;, e); &#125; ...&#125;public class NotificationListenerWithPlugins extends NotificationListenerService implements PluginListener&lt;NotificationListenerController&gt; &#123; private ArrayList&lt;NotificationListenerController&gt; mPlugins = new ArrayList&lt;&gt;(); private boolean mConnected; @Override public void registerAsSystemService(Context context, ComponentName componentName, int currentUser) throws RemoteException &#123; super.registerAsSystemService(context, componentName, currentUser); Dependency.get(PluginManager.class).addPluginListener(this, NotificationListenerController.class); &#125;&#125; 这里看到 registerAsSystemService() 除了调用父类的方法外，还调用了 addPluginListener() ,这里 addPluginListener() 先不看，从名字上看可能是 把notification的更新通知给所有的插件 。上面我们提到listener.onNotificationPosted(...)最终调用到了一个空方法，但是这里既然有了子类，那么就会调用到子类的 onNotificationPosted() 方法中: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private final NotificationListenerWithPlugins mNotificationListener = new NotificationListenerWithPlugins() &#123; @Override public void onListenerConnected() &#123; if (DEBUG) Log.d(TAG, &quot;onListenerConnected&quot;); onPluginConnected(); final StatusBarNotification[] notifications = getActiveNotifications(); if (notifications == null) &#123; Log.w(TAG, &quot;onListenerConnected unable to get active notifications.&quot;); return; &#125; final RankingMap currentRanking = getCurrentRanking(); mHandler.post(new Runnable() &#123; @Override public void run() &#123; for (StatusBarNotification sbn : notifications) &#123; try &#123; addNotification(sbn, currentRanking); &#125; catch (InflationException e) &#123; handleInflationException(sbn, e); &#125; &#125; &#125; &#125;); &#125; @Override public void onNotificationPosted(final StatusBarNotification sbn, final RankingMap rankingMap) &#123; if (DEBUG) Log.d(TAG, &quot;onNotificationPosted: &quot; + sbn); if (sbn != null &amp;&amp; !onPluginNotificationPosted(sbn, rankingMap)) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; processForRemoteInput(sbn.getNotification()); String key = sbn.getKey(); mKeysKeptForRemoteInput.remove(key); boolean isUpdate = mNotificationData.get(key) != null; // In case we don&#x27;t allow child notifications, we ignore children of // notifications that have a summary, since we&#x27;re not going to show them // anyway. This is true also when the summary is canceled, // because children are automatically canceled by NoMan in that case. if (!ENABLE_CHILD_NOTIFICATIONS &amp;&amp; mGroupManager.isChildInGroupWithSummary(sbn)) &#123; if (DEBUG) &#123; Log.d(TAG, &quot;Ignoring group child due to existing summary: &quot; + sbn); &#125; // Remove existing notification to avoid stale data. if (isUpdate) &#123; removeNotification(key, rankingMap); &#125; else &#123; mNotificationData.updateRanking(rankingMap); &#125; return; &#125; try &#123; if (isUpdate) &#123; updateNotification(sbn, rankingMap); &#125; else &#123; addNotification(sbn, rankingMap); &#125; &#125; catch (InflationException e) &#123; handleInflationException(sbn, e); &#125; &#125; &#125;); &#125; &#125; @Override public void onNotificationRemoved(StatusBarNotification sbn, final RankingMap rankingMap) &#123; if (DEBUG) Log.d(TAG, &quot;onNotificationRemoved: &quot; + sbn); if (sbn != null &amp;&amp; !onPluginNotificationRemoved(sbn, rankingMap)) &#123; final String key = sbn.getKey(); mHandler.post(() -&gt; removeNotification(key, rankingMap)); &#125; &#125; @Override public void onNotificationRankingUpdate(final RankingMap rankingMap) &#123; if (DEBUG) Log.d(TAG, &quot;onRankingUpdate&quot;); if (rankingMap != null) &#123; RankingMap r = onPluginRankingUpdate(rankingMap); mHandler.post(() -&gt; updateNotificationRanking(r)); &#125; &#125; &#125;; 这里终于看到了addNotification(sbn, rankingMap)的调用了。。。总结一下：类图 : 通知相关初始化 ： 发送通知的过程 : 在Android 8.0里面不仅状态栏的界面和交互发生了变化，连消息流向也变了。之前是直接查询SystemServer就可以拿到StatusBarManagerService,然后可以通知StatusBar去 addNotification() ,现在的版本则不再通过 StatusBarManagerService ，而是使用 NotificationListenerService 去创建一个内部类INotificationListener.Stub类型的成员变量并注册它到 NotificationManager Service，这样子 NotificationManager 就拿到了远程接口可以直接调用到内部类中，再调用到 NotificationListenerService 类中，而客户端通过 继承NotificationListenerService的子类，就等于可以直接接收到NotificationManagerService的回调。这里有个问题，为什么不像 mCommandQueue 一样直接把 INotificationListener.Stub 传给 NotificationListenerService 呢 ？在这里猜想是因为plug相关的操作，通知消息不仅仅要告诉StatusBar，也需要告诉一些plug，因此拿 NotificationListenerService 来进行adapt和管理。 在类图中，我们可以清晰的看到， StatusBarManagerService 比较直接， 它可以通过 IStatusBar 直接调用到 CommandQueue ，而 CommandQueue 则通过callback通知到 StatusBar 。而 NotificationManagerService 则是另外一种方法，它可以一路找到 INotificationListener，然后调用到 INotificationListener.Stub 所在的 StatusBar 类，这里是通过匿名内部类的机制直接调用到 StatusBar的方法。 不管是哪种方式，我们都可以大致的总结出一种 客户端 和 系统服务交互的简化模型，即 系统服务 &lt;===&gt; binder接口管理类 &lt;==&gt; 客户端 对于 StatusBarManagerService 来说，就是 StatusBarManagerService &lt;===&gt; CommandQueue &lt;==&gt; StatusBar，对于 NotificationManagerService 来说，就是 NotificationManagerService &lt;===&gt; NotificationListenerWithPlugins &lt;==&gt; StatusBar，在更多的功能模块中，我们也会看到这种模型，比如 wms &lt;===&gt; ViewRootImpl(包含mWindow) &lt;==&gt; PhoneWindow 等。 在 SystemService 的注释中我们也可以看到，以后Android会逐步转成这种方式，即 系统服务 都会继承 SystemService 类，SystemService类则定义了通用的一些回调方法。系统服务中则以Ixxx.Stub这种真正的服务作为成员变量，这么做的好处在于，可以把系统服务之间需要相互调用的方法剥离出来成一个内部类，叫做 xxxxInternal.class , 然后在 SystemService 类中会保存一个静态的hashmap，用来存储这种对应关系。因为系统服务大部分都是运行在同一个系统进程的不同线程，所以这个hashmap会对所有的系统服务可见，当 StatusBarManagerService 需要 NotificationManagerService 的功能的时候，就不需要通过binder调用来进行了，而是直接可以从 hashmap 取出 xxxxInternal 类，进而调用到 NotificationManagerService 的功能中去，提高了一些效率。 导航栏导航栏的添加和状态栏的添加在一起： 1234567891011121314151617181920212223242526272829303132333435363738394041protected void makeStatusBarView() &#123; ... createNavigationBar(); ...&#125;protected void createNavigationBar() &#123; mNavigationBarView = NavigationBarFragment.create(...);&#125;//NavigationBarFragment::create(...)public static View create(Context context, FragmentListener listener) &#123; WindowManager.LayoutParams lp = new WindowManager.LayoutParams( LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_NAVIGATION_BAR, WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_SLIPPERY, PixelFormat.TRANSLUCENT); lp.token = new Binder(); lp.setTitle(&quot;NavigationBar&quot;); lp.windowAnimations = 0; View navigationBarView = LayoutInflater.from(context).inflate( R.layout.navigation_bar_window, null); if (DEBUG) Log.v(TAG, &quot;addNavigationBar: about to add &quot; + navigationBarView); if (navigationBarView == null) return null; context.getSystemService(WindowManager.class).addView(navigationBarView, lp); FragmentHostManager fragmentHost = FragmentHostManager.get(navigationBarView); NavigationBarFragment fragment = new NavigationBarFragment(); fragmentHost.getFragmentManager().beginTransaction() .replace(R.id.navigation_bar_frame, fragment, TAG) .commit(); fragmentHost.addTagListener(TAG, listener); return navigationBarView; &#125; 这里 导航栏的window参数为LayoutParams.MATCH_PARENT，从之前 wms 的介绍可以知道， 在relayoutWindow()的时候，window的尺寸和位置最终都以 wms 的决定为准，而在 wms的 addWindow/在relayoutWindow 方法中，都可以看到 updateFocusedWindowLocked()的调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// wms ::updateFocusedWindowLocked()boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows) &#123; ... displayContent.performLayout(...); ...&#125;//DisplayContent::performLayout()void performLayout(boolean initial, boolean updateInputWindows) &#123; ... mService.mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mRotation,getConfiguration().uiMode); ...&#125;//PhoneWindowManager::beginLayoutLw()public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation, int uiMode) &#123; ... if (isDefaultDisplay) &#123; // For purposes of putting out fake window up to steal focus, we will // drive nav being hidden only by whether it is requested. final int sysui = mLastSystemUiFlags; boolean navVisible = (sysui &amp; View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0; boolean navTranslucent = (sysui &amp; (View.NAVIGATION_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSPARENT)) != 0; boolean immersive = (sysui &amp; View.SYSTEM_UI_FLAG_IMMERSIVE) != 0; boolean immersiveSticky = (sysui &amp; View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0; boolean navAllowedHidden = immersive || immersiveSticky; navTranslucent &amp;= !immersiveSticky; // transient trumps translucent boolean isKeyguardShowing = isStatusBarKeyguard() &amp;&amp; !mKeyguardOccluded; if (!isKeyguardShowing) &#123; navTranslucent &amp;= areTranslucentBarsAllowed(); &#125; boolean statusBarExpandedNotKeyguard = !isKeyguardShowing &amp;&amp; mStatusBar != null &amp;&amp; mStatusBar.getAttrs().height == MATCH_PARENT &amp;&amp; mStatusBar.getAttrs().width == MATCH_PARENT; // When the navigation bar isn&#x27;t visible, we put up a fake // input window to catch all touch events. This way we can // detect when the user presses anywhere to bring back the nav // bar and ensure the application doesn&#x27;t see the event. if (navVisible || navAllowedHidden) &#123; if (mInputConsumer != null) &#123; mHandler.sendMessage( mHandler.obtainMessage(MSG_DISPOSE_INPUT_CONSUMER, mInputConsumer)); mInputConsumer = null; &#125; &#125; else if (mInputConsumer == null) &#123; mInputConsumer = mWindowManagerFuncs.createInputConsumer(mHandler.getLooper(), INPUT_CONSUMER_NAVIGATION, (channel, looper) -&gt; new HideNavInputEventReceiver(channel, looper)); // As long as mInputConsumer is active, hover events are not dispatched to the app // and the pointer icon is likely to become stale. Hide it to avoid confusion. InputManager.getInstance().setPointerIconType(PointerIcon.TYPE_NULL); &#125; // For purposes of positioning and showing the nav bar, if we have // decided that it can&#x27;t be hidden (because of the screen aspect ratio), // then take that into account. navVisible |= !canHideNavigationBar(); boolean updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight, displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent, navAllowedHidden, statusBarExpandedNotKeyguard); if (DEBUG_LAYOUT) Slog.i(TAG, String.format(&quot;mDock rect: (%d,%d - %d,%d)&quot;, mDockLeft, mDockTop, mDockRight, mDockBottom)); updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing); if (updateSysUiVisibility) &#123; updateSystemUiVisibilityLw(); &#125; &#125;&#125;private boolean layoutNavigationBar(...) &#123; ... getNavigationBarHeight()/getNavigationBarWidth() ...&#125;private int getNavigationBarHeight(int rotation, int uiMode) &#123; if (ALTERNATE_CAR_MODE_NAV_SIZE &amp;&amp; (uiMode &amp; UI_MODE_TYPE_MASK) == UI_MODE_TYPE_CAR) &#123; return mNavigationBarHeightForRotationInCarMode[rotation]; &#125; else &#123; return mNavigationBarHeightForRotationDefault[rotation]; &#125;&#125; 在 PhoneWindowManager 类中可以看到这个值的默认值是 res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height) : 48dp 布局导航栏的布局比较简单： 1@layout&#x2F;navigation_bar_window --&gt; @layout&#x2F;navigation_bar --&gt; NavigationBarInflaterView|@layout&#x2F;navigation_layout 其中，每一个按钮是一个 KeyButtonView，继承了ImageView 并且定义了 KeyButtonRipple 用来显示按下效果。在onTouchEvent()里面里，对于home,back等有keycode的控件，会根据keycode，生成一个KeyEvent(),插入到inputManager去分发，这样客户端就可以收到事件了。对于recent等没有keycode的控件会直接触发onclickListener。","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"Android控件总结(显示流程，触摸事件派发)","slug":"Android控件总结","date":"2018-08-20T14:25:54.000Z","updated":"2018-11-05T14:15:54.437Z","comments":true,"path":"2018/08/20/Android控件总结/","link":"","permalink":"http://example.com/2018/08/20/Android%E6%8E%A7%E4%BB%B6%E6%80%BB%E7%BB%93/","excerpt":"在wms服务中，我们可以直接使用它的api来创建一个窗口，显示出来并且通过InputEventReceiver接收输入事件。但是这种方法太原始,并且存在以下一些问题: 需要完全的Android源码环境 需要自己去处理UI元素的测量，布局和绘制 还需要处理InputEventReceiver事件，分发到合适的窗口 wms来的各种回调","text":"在wms服务中，我们可以直接使用它的api来创建一个窗口，显示出来并且通过InputEventReceiver接收输入事件。但是这种方法太原始,并且存在以下一些问题: 需要完全的Android源码环境 需要自己去处理UI元素的测量，布局和绘制 还需要处理InputEventReceiver事件，分发到合适的窗口 wms来的各种回调 因此Android提供了控件系统来帮我们完成各种各样的控件的创建。更高级一点的创建方式是获取 WindowManager,然后通过addView()方法得到一个可以交互的有界面的窗口 关于WindowManager的一个类图,比较容易混乱的是context.getSystemService(WINDOW)拿到的其实只是一个WindowManagerImpl类，并不是wms服务。。 窗口添加view的过程然后是为窗口添加view所发生的调用过程 我们跟进WindManager.addView()过程，可以看到最终通过RootViewImpl.addView()调用到了PerformTraversals()。除此之外，requestLayout()也会导致 PerformTraversals() 被调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //在layout过程中会被设置为true checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; //屏蔽重复的调用 mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //即使performTraversals()执行比较快，在一次垂直同步的时间里最多只会调用performTraversals()一次 mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125;final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(&quot;ViewAncestor&quot;); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; performTraversals()主要经过了以下几个阶段： 预测量阶段，这里会对控件树第一次进行测量，计算出为了显示控件树所希望的窗口大小，将会依次调用view和子类的onMeasure()方法。 布局窗口阶段，这里会把上一步得到的数据发给wms，wms会对窗口进行重新布局，计算出系统实际上给客户端的窗口大小并返回。 最终测量阶段，这里只能接受wms给的窗口大小，并根据这个大小最终计算出控件树的实际大小，将会依次调用view和子类的onMeasure()方法。 布局控件树， 上一步得到测量结果这里就可以计算出控件的位置，将会依次调用View和子类的onLayout()方法 绘制。将会依次调用View和子类的onDraw()方法 需要注意的是， onMeasure和onLayout,onDraw都是可以跳过的 测量阶段(1,2,3)第一次测量的时候，使用的 desiredWindowWidth 和 desiredWindowHeight 就是屏幕的大小，后面再测量的时候使用的就是上次测量得出的窗口大小了。在measureHierarchy可以看到，如果performMeasure()的结果带有标记MEASURED_STATE_TOO_SMALL，performMeasure()有可能被调用多次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174performTraversals()&#123; ... //预测量阶段 if (mFirst) &#123; mFullRedrawNeeded = true; mLayoutRequested = true; final Configuration config = mContext.getResources().getConfiguration(); if (shouldUseDisplaySize(lp)) &#123; // NOTE -- system code, won&#x27;t try to do compat mode. ... &#125; else &#123; desiredWindowWidth = dipToPx(config.screenWidthDp); desiredWindowHeight = dipToPx(config.screenHeightDp); &#125; else&#123; desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123; if (DEBUG_ORIENTATION) Log.v(mTag, &quot;View &quot; + host + &quot; resized to: &quot; + frame); mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; &#125; &#125; //没有开始绘制的时候可能会有消息过来，这时候要存在一个队列里面，开始绘制了再执行 getRunQueue().executeActions(mAttachInfo.mHandler); boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw); if (layoutRequested) &#123; final Resources res = mView.getContext().getResources(); if (mFirst) &#123; // make sure touch mode code executes by setting cached value // to opposite of the added touch mode. mAttachInfo.mInTouchMode = !mAddedTouchMode; ensureTouchModeLocally(mAddedTouchMode); &#125; else &#123; ... &#125; // Ask host how big it wants to be windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; ... //布局窗口阶段 relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ... //最终测量阶段，如果wms返回的结果和客户端自己期望的结果不一样，则需要再次测量 if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()|| mHeight != host.getMeasuredHeight() || contentInsetsChanged ||updatedConfiguration) &#123; int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(mTag, &quot;Ooops, something changed! mWidth=&quot; + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth() + &quot; mHeight=&quot; + mHeight + &quot; measuredHeight=&quot; + host.getMeasuredHeight() + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... layoutRequested = true; &#125; //布局控件树 ...&#125;private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; int childWidthMeasureSpec; int childHeightMeasureSpec; boolean windowSizeMayChange = false; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(mTag, &quot;Measuring &quot; + host + &quot; in display &quot; + desiredWindowWidth + &quot;x&quot; + desiredWindowHeight + &quot;...&quot;); boolean goodMeasure = false; if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; // On large screens, we don&#x27;t want to allow dialogs to just // stretch to fill the entire width of the screen to display // one line of text. First try doing the layout at a smaller // size to see if it will fit. final DisplayMetrics packageMetrics = res.getDisplayMetrics(); res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, true); int baseSize = 0; if (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123; baseSize = (int)mTmpValue.getDimension(packageMetrics); &#125; if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: baseSize=&quot; + baseSize + &quot;, desiredWindowWidth=&quot; + desiredWindowWidth); if (baseSize != 0 &amp;&amp; desiredWindowWidth &gt; baseSize) &#123; childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot; + host.getMeasuredWidth() + &quot;,&quot; + host.getMeasuredHeight() + &quot;) from width spec: &quot; + MeasureSpec.toString(childWidthMeasureSpec) + &quot; and height spec: &quot; + MeasureSpec.toString(childHeightMeasureSpec)); if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == 0) &#123; goodMeasure = true; &#125; else &#123; // Didn&#x27;t fit in that size... try expanding a bit. baseSize = (baseSize+desiredWindowWidth)/2; if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: next baseSize=&quot; + baseSize); childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot; + host.getMeasuredWidth() + &quot;,&quot; + host.getMeasuredHeight() + &quot;)&quot;); if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == 0) &#123; if (DEBUG_DIALOG) Log.v(mTag, &quot;Good!&quot;); goodMeasure = true; &#125; &#125; &#125; &#125; if (!goodMeasure) &#123; childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123; windowSizeMayChange = true; &#125; &#125; if (DBG) &#123; System.out.println(&quot;======================================&quot;); System.out.println(&quot;performTraversals -- after measure&quot;); host.debug(); &#125; return windowSizeMayChange;&#125;private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; ... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...&#125;public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... if (forceLayout || needsLayout) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ... mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; //measure里面会对flag进行设置，所以不能直接重写measure()，而是写onMeasure() &#125; ...&#125; 布局控件树这里主要的工作内容是 performLayout() 和 mWindowSession.setTransparentRegion(). 整个窗口默认都是透明区域，当普通控件加入时，控件会把自己的区域从透明区域移除掉，而SurfaceView会把自己的区域添加到当前窗口的透明区域中。随后这个区域会被设置给wms,在surfaceFlinger对surface进行混合的时候，窗口的透明区域将会被忽略掉 需要注意的是在layout方法里面，会调用到setFrame来检查布局坐标是否变化，如果发生变化，就会调用invalidate(),此时一定会调用onDraw() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768performTraversals()&#123; ... //测量阶段(1,2,3) final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout|| mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout(lp, mWidth, mHeight); ... if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123; mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try &#123; mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; ... //绘制阶段&#125;private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,int desiredWindowHeight) &#123; ... final View host = mView; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125;public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ... //注意这里，setOpticalFrame和setFrame都会调用到setFrame，里面可能会调用invalidate(),此时一定会调用onDraw() boolean changed = isLayoutModeOptical(mParent) ?setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ////layout里面会对flag进行设置，所以不能直接重写layout()，而是写onLayout() ... &#125; ...&#125;protected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; ... boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); // Invalidate our old position invalidate(sizeChanged); ... if (sizeChanged) &#123; sizeChange(newWidth, newHeight, oldWidth, oldHeight); &#125; ... return changed;&#125; 绘制控件 如果view不可见，不需要绘制 如果surface是新创建的(比如从不可见到可见，此时会新创建surface)，不需要绘制，调用scheduleTraversals()下次再绘制。 绘制的时候仅仅会对需要重绘的区域进行绘制，这部分区域称为脏区域。如果mDirty为空，有可能不会进行绘制。在控件中表示为PFLAG_DIRTY和PFLAG_DIRTY_OPAQUE,表示这个控件中是否有需要重绘的区域。其中PFLAG_DIRTY_OPAQUE表示此区域是不透明的，如果是整个控件，那就是意思是可以不用控件的底层背景，提高绘制效率。 123456789101112131415161718192021222324252627282930313233343536373839404142performTraversals()&#123; ... //测量阶段(1,2,3) ... //布局阶段 boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible; if (!cancelDraw &amp;&amp; !newSurface) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw(); &#125; else &#123; if (isViewVisible) &#123; scheduleTraversals(); &#125; ... &#125;&#125;private void performDraw() &#123; if (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123; return; &#125; else if (mView == null) &#123; return; &#125; final boolean fullRedrawNeeded = mFullRedrawNeeded; mFullRedrawNeeded = false; mIsDrawing = true; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;draw&quot;); try &#123; draw(fullRedrawNeeded); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ... pendingDrawFinished(); ... &#125; 这里主要有两个步骤，其中pendingDrawFinished()用来通知 wms 控件绘制结束，wms收到消息后就会把窗口的surface显示出来。 12345678910111213141516171819 void pendingDrawFinished() &#123; if (mDrawsNeededToReport == 0) &#123; throw new RuntimeException(&quot;Unbalanced drawPending/pendingDrawFinished calls&quot;); &#125; mDrawsNeededToReport--; if (mDrawsNeededToReport == 0) &#123; reportDrawFinished(); &#125; &#125; private void reportDrawFinished() &#123; try &#123; mDrawsNeededToReport = 0; mWindowSession.finishDrawing(mWindow); &#125; catch (RemoteException e) &#123; // Have fun! &#125; &#125;&#125; 另一个则是 控件的绘制过程draw(fullRedrawNeeded);： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ... // 控件滚动的相关计算 final Rect dirty = mDirty; if (mSurfaceHolder != null) &#123; // The app owns the surface, we won&#x27;t draw. dirty.setEmpty(); if (animating &amp;&amp; mScroller != null) &#123; mScroller.abortAnimation(); &#125; return; &#125; if (fullRedrawNeeded) &#123; mAttachInfo.mIgnoreDirtyState = true; dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); &#125; ... if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123; ... &#125; else &#123; ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; ...&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; ... canvas = mSurface.lockCanvas(dirty); ... &#125; catch (Surface.OutOfResourcesException e) &#123; ... &#125; try &#123; ... mView.draw(canvas); ... &#125; finally &#123; surface.unlockCanvasAndPost(canvas); ... &#125; return true; &#125; public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&#x27; layers to prepare for fading * 3. Draw view&#x27;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; //如果不需要绘制 渐变边界，则进入简便流程，跳过2，5步骤 if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) &#123; debugDrawFocus(canvas); &#125; // we&#x27;re done... return; &#125; //完整流程 ... &#125; draw的draw()方法，简便流程主要有以下几步： 绘制背景 drawBackground() 绘制控件自身，onDraw(canvas)，默认空实现 绘制子控件 dispatchDraw(canvas);，默认空实现 绘制装饰(前景色，滚动条,etc.) onDrawForeground(canvas); Activity和PhoneWindow PhoneWindow通过 WindowManager ，ViewRootImpl 创建窗口的时候，我们仍然需要自行初始化 LayoutParams ，处理控件树的添加和删除等。 Android 在此之上又提供了一套机制，用于更简单的创建窗口和界面。而且 界面提供了预定义的样式，比如 标题栏，图标等，相比于自行创建符合Android规范的界面模板，进一步简化了开发者工作。这些工作是通过一个 com.view.Window 抽象类来实现的，目前它的唯一实现是PhoneWindow 类。我们仅仅需要通过setContentView()设置自己定义的控件树就可以得到一个带有标准模板的窗口界面，模板的样式取决于flag,theme等属性 DecorViewDecorView 继承了 FrameLayout , 是 PhoneWindow 类里面的 控件树的根。预定义的样式就是由它实现，在我们通过setContentView()设置自己定义的View的时候，仅仅是设置View到DecorView里面成为它的子view。 控件焦点 触摸模式(Touch_mode)：在触摸模式下，一些控件比如菜单项，按钮等将不再可以保持或获取焦点，文本框等依然可以获取焦点 非触摸模式： 在这个模式下，菜单项，按钮等都可以获取焦点，通过方向键使焦点在这些控件之间游走，从而进行选择和确认 控件能否获取焦点的策略： 当 NOT_FOCUSABLE 标记位于View.mViewFlags时，无法获取焦点 当控件的父控件的DescendantFocusability 取值为 FOCUS_BLOCK_DESCENDANTS 时，无法获取焦点。 当 FOCUSABLE 标记位于View.mViewFlags时，还有两种情况： 位于非触摸模式时，可以获取焦点 位于触摸模式的时候，View.mViewFlags 中存在 FUCUSABLE_IN_TOUCH_MODE标记可以获取焦点，否则不能获取焦点 获取到焦点的控件实际上只是增加了 PFLAG_FOCUSED 标记，而失去焦点则删除这个标记。对于获取到焦点的控件来说，它的父控件则会用 mFocused 变量来保存此控件，这样通过控件树的根节点可以迅速的一层层找到最终拥有焦点的控件。View类则提供两个方法来查询焦点的状态。 isFocused() 表示此控件是否含有PFLAG_FOCUSED标记，即焦点的持有者 hasFocused() 表示焦点是否在其内部，也就是自己或者子控件持有焦点 输入事件的派发在ViewRootImpl.setView()中，ViewRootImpl使用wms分配的 InputChannel 创建了 InputEventReceiver 来接收输入事件，它们通过 onInputEvent()回调来得到事件并且进行处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687void setview(...)&#123; ... mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,Looper.myLooper()); ... mSyntheticInputStage = new SyntheticInputStage(); InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage); InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,&quot;aq:native-post-ime:&quot; + counterSuffix); InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage); InputStage imeStage = new ImeInputStage(earlyPostImeStage,&quot;aq:ime:&quot; + counterSuffix); InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage); InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,&quot;aq:native-pre-ime:&quot; + counterSuffix); mFirstInputStage = nativePreImeStage; mFirstPostImeInputStage = earlyPostImeStage; mPendingInputEventQueueLengthCounterName = &quot;aq:pending:&quot; + counterSuffix;&#125;final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event, int displayId) &#123; enqueueInputEvent(event, this, 0, true); &#125; @Override public void onBatchedInputEventPending() &#123; if (mUnbufferedInputDispatch) &#123; super.onBatchedInputEventPending(); &#125; else &#123; scheduleConsumeBatchedInput(); &#125; &#125; @Override public void dispose() &#123; unscheduleConsumeBatchedInput(); super.dispose(); &#125;&#125;void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; adjustInputEventForCompatibility(event); QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); ... //输入事件加入到链表中 if (processImmediately) &#123; doProcessInputEvents(); &#125; else &#123; //稍后处理，通过handler还是会走到doProcessInputEvents()中 scheduleProcessInputEvents(); &#125;void doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; ... deliverInputEvent(q); &#125; ...&#125;private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, &quot;deliverInputEvent&quot;, q.mEvent.getSequenceNumber()); if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); &#125; InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; //做一些清理回收工作 finishInputEvent(q); &#125;&#125; 其中，输入事件在这里被定义成了几个类型： keyEvent 按键事件 PointerEvent 触摸事件 TrackballEvent 轨迹球事件 GenericMotionEvent 其他事件，比如悬浮(HOVER)事件，游戏手柄等 而 InputStage 是一个基类，通过Wrapper模式不断的调用apply和forward方法来进行链式调用，定义了6个state，在各个阶段会选择性处理感兴趣的事件，在任一阶段事件被消耗掉了都不会继续传递: nativePreImeStage : 这里会把输入事件传给native层看看是否要处理 viewPreImeStage ： 这里会把输入事件交给view去处理，对 keyEvent事件 调用 mView.dispatchKeyEventPreIme(event) imeStage : 这里会把输入事件交给输入法窗口去处理，调用imm.dispatchInputEvent(event, q, this, mHandler) earlyPostImeStage ：这里会进行一些状态记录，触摸模式的确认和退出等 nativePostImeStage ： 同1一样，只不过这里是在 输入法窗口处理 之后再次传给 native 层 viewPostImeStage ： 把输入事件交给view去处理 1234567891011121314protected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q); &#125; else &#123; final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q); &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; return processTrackballEvent(q); &#125; else &#123; return processGenericMotionEvent(q); &#125; &#125;&#125; 按键事件keyEvent 按键事件是基于焦点派发的，因为在非触摸模式下，输入法窗口无法获取到焦点，因此在这里会给输入法窗口一个处理的机会。对于view来说，处理的逻辑相对比较简单，如果自己拥有焦点，则调用自己的view.onKeyPreIme()方法去处理，否则调用mFocused.dispatchKeyEventPreIme(event) 触摸事件1234567891011121314151617// ViewRootImply::processPointerEventprivate int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; ... boolean handled = mView.dispatchPointerEvent(event); ... return handled ? FINISH_HANDLED : FORWARD;&#125;//View::dispatchPointerEvent()public final boolean dispatchPointerEvent(MotionEvent event) &#123; if (event.isTouchEvent()) &#123; return dispatchTouchEvent(event); &#125; else &#123; return dispatchGenericMotionEvent(event); &#125;&#125; 多点触摸 ：触摸事件被封装为一个 MotionEvent 类，在多点触摸的情况下，即使 MotionEvent 由一个触摸点触发，它也包含所有触控点的位置信息。这时候通过 MotionEvent.getAction()获取的是一个复合值，低8位描述了动作，高8位描述了触控点的索引号。我们可以通过MotionEvent.getActionMasked()和MotionEvent.getActionIndex()分别获取这两个值。MotionEvent.getX(index)和MotionEvent.getY(index)则接受索引号为参数返回此触摸点的位置。 索引号不是固定的，比如当我们使用 AB两个手指按下的时候，它们会分别获得的索引号是0和1，当A抬起后，B的索引号则变成了0。但是我们可以通过MotionEvent.getPointerId(index)来获取这个索引号对应的触控点的pointerId,这个值则是在不变的 123//ACTION_DOWN 是第一个手指按下 ，ACTION_UP 是最后一个手指抬起ACTION_DOWN --&gt; ACTION_POINTER_DOWN --&gt;ACTION_POINTER_DOWN --&gt; ACTION_POINTER_UP --&gt; ACTION_POINTER_UP --&gt; ACTION_UP 到这里ViewRootImpl把事件传递给了mView对象，而在实际的使用中，这个mView对象则是指 DecorView (参考WindowManagerGlobal::addView方法)，DecorView对dispatchTouchEvent进行了重写： 1234567//DecorView::dispatchTouchEvent public boolean dispatchTouchEvent(MotionEvent ev) &#123; final Window.Callback cb = mWindow.getCallback(); return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); &#125; 这里的mWindow 则是在 DecorView的构造函数中传入的 Activity的 PhoneWindow类，而它的 Callback ，是在 Activity::onAttach(...)方法中设置的： 1234567891011121314151617181920212223242526272829//Activity::onAttach(...)final void attach(...)&#123; ... mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); ... &#125; //Activity::dispatchTouchEventpublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125;//PhoneWindow::superDispatchTouchEventpublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125;//DecorView::superDispatchTouchEventpublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; 可以说是绕了一圈又回到了ViewGroup.dispatchTouchEvent中来了，这个过程中，主要是加入了Activity的介入。Activity可以重写dispatchTouchEvent()和onTouchEvent 来在View处理触摸事件之前和之后进行介入。 dispatchTouchEvent()有View和ViewGroup两种实现 : 1234567891011121314151617181920212223// View::dispatchTouchEvent()public boolean dispatchTouchEvent(MotionEvent event) &#123; ... boolean result = false; ... if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ... return result;&#125; 对于View来说， dispatchTouchEvent() 主要做了两件事， 先把事件给mOnTouchListener处理，如果mOnTouchListener没有消耗掉，则交给onTouchEvent(event)处理。 ViewGroup的 dispatchTouchEvent() 相对来说比较复杂，总体来说，分以下几个步骤： 准备工作： 过滤可能导致安全问题的触控事件 如果是ACTION_DOWN则清空之前留下的touchTarget和touchState 处理 ViewGroup 的拦截的问题 (FLAG_DISALLOW_INTERCEPT和onInterceptTouchEvent()两个条件) 如果事件没有被拦截或者取消掉，则寻找派发目标： 如果是 ACTION_DOWN,ACTION_POINTER_DOWN或者ACTION_HOVER_MOVE之一，则进入下面的处理流程 记下触摸事件的pointId 按照一定(PreOrder)的顺序遍历child，如果触摸点不在这个child的控件范围内，则排除掉，否则尝试在自己保存的TouchTarget链表中寻找是否已经保存了;如果找到这个child,那么确定这个child就是此次派发目标，跳出循环，把后续的事件都交给它，寻找派发目标结束;如果在自己保存的TouchTarget链表中没有找到,还是尝试调用 dispatchTransformedTouchEvent(...) 把此次触摸事件派发给这个child控件(如果子控件也是一个ViewGroup,则有可能会继续分发下去)，调用结果是True的时候，为这个child生成新的TouchTarget节点并使用头插法加入到保存的链表中，然后跳出循环；如果调用 dispatchTransformedTouchEvent(...)返回false,表示这个子控件没有处理这个触摸事件，继续遍历child 开始派发事件： 如果TouchTarget链表为空，表示子view已经遍历完了，都没有消耗掉这个事件，此时则发给自己处理 如果TouchTarget链表不为空，表示有子view消耗掉了触摸事件。遍历 TouchTarget 链表的节点，如果是ActionDown之类的事件，则已经在上面第二步中处理过了，结束派发，否则尝试调用dispatchTransformedTouchEvent(...)把此次触摸事件派发给它，如果取消了事件，则需要回收掉该节点。如果失败，则继续尝试下一个节点 这里没有太明白TouchTarget设计为链表的原因，即使是子view有重叠的情况，一个触摸点可能会落在多个view的范围内，此时会按照PreOrder的顺序去让它们依次处理，但是只要任意一个子view消耗了ActionDown事件，就会把它存TouchTarget中，后续的动作都不会再添加到TouchTarget了，TouchTarget只会add一次呀。。 派发的函数dispatchTransformedTouchEvent(...)如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don&#x27;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; // If the number of pointers is the same and we don&#x27;t need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled;&#125; 注释写的很清楚，这个函数的主要功能是： 把一个motionEvent转化为childview坐标下的坐标点位置。 过滤不感兴趣的pointerId触摸点 可能的情况下，修改Action的值。 如果传入的child为空，则派发给viewGroup自己(即super.dispatchTouchEvent调用到View的方法中去) 其中，比较复杂的则是 修改Action的值 ，这个涉及到多点触摸的原理和过程，需要另外分析。 在 ViewGroup 的处理中，有个比较神奇的操作，和常见的使用flags来记录一些预定义的值不一样： 1final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex): TouchTarget.ALL_POINTER_IDS; 它使用idBitsToAssign 这样一个int值来记录触摸点的信息，因为一个int值最多32bit,所以对于每一个TouchTarget，最多支持32个触摸点 更多的细节，会在下一篇中记下来","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"Android binder原理和设计","slug":"Android-binder原理和设计","date":"2018-08-18T00:54:24.000Z","updated":"2018-11-05T14:13:05.848Z","comments":true,"path":"2018/08/18/Android-binder原理和设计/","link":"","permalink":"http://example.com/2018/08/18/Android-binder%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1/","excerpt":"Binder驱动原理Binder驱动的核心是维护一个binder_proc类型的链表。里面记录了包括ServiceManager在内的所有Client信息，当Client去请求得到某个Service时，Binder驱动就去binder_proc中查找相应的Service返回给Client，同时增加当前Service的引用个数。","text":"Binder驱动原理Binder驱动的核心是维护一个binder_proc类型的链表。里面记录了包括ServiceManager在内的所有Client信息，当Client去请求得到某个Service时，Binder驱动就去binder_proc中查找相应的Service返回给Client，同时增加当前Service的引用个数。 Binder驱动是作为一个特殊字符型设备存在，设备节点为/dev/binder，遵循Linux设备驱动模型。在驱动实现过程中，主要通过binder_ioctl函数与用户空间的进程交换数据。BINDER_WRITE_READ用来读写数据，数据包中有个cmd用于区分不同的请求。在binder_thread_write函数中调用binder_transaction函数来转发请求并返回结果，而binder_thread_read函数用于读取结果。。当服务进程收到请求时，binder_transaction函数会通过对象的handle找到对象所在进程，如果handle为0，就认为请求的是ServiceManager进程。 整个Binder的流程： 对象的索引和映射Binder中有两种索引，一是本地进程地址空间的一个地址，另一个是一个抽象的32位句柄（HANDLE），它们之间是互斥的：所有的进程本地对象的索引都是本地进程的一个地址(address, ptr, binder)，所有的远程进程的对象的索引都是一个句柄（handle）。对于发送者进程来说，索引就是一个远端对象的一个句柄，当Binder对象数据被发送到远端接收进程时，远端接受进程则会认为索引是一个本地对象地址，因此从第三方的角度来说，尽管名称不同，对于一次Binder调用，两种索引指的是同一个对象，Binder驱动则负责两种索引的映射，这样才能把数据发送给正确的进程。 对于Android的Binder来说，对象的索引和映射是通过binder_node和binder_ref两个核心数据结构来完成的，对于Binder本地对象，对象的Binder地址保存在binder_node-&gt;ptr里，对于远程对象，索引就保存在binder_ref-&gt;desc里，每一个binder_node都有一个binder_ref对象与之相联系，他们就是是通过ptr和desc来做映射的，如下图： Binder句柄:句柄就是个简单的整数值，用来告诉Binder驱动我们想找的目标Binder实体是哪个。但是请注意，句柄只对发起端进程和Binder驱动有意义，A进程的句柄直接拿到B进程，是没什么意义的。也就是说，不同进程中指代相同Binder实体的句柄值可能是不同的。示意图如下： ServiceManagerService 记录了所有系统service所对应的Binder句柄，它的核心功能就是维护好这些句柄值。后续，当用户进程需要获取某个系统service的代理时，SMS就会在内部按service名查找到合适的句柄值，并“逻辑上”传递给用户进程，于是用户进程会得到一个新的合法句柄值，这个新句柄值可能在数值上和SMS所记录的句柄值不同，然而，它们指代的却是同一个Service实体。句柄的合法性是由Binder驱动保证的，这一点我们不必担心 flat_binder_object就是进程间传递的Binder对象，每一个flat_binder_object对象内都有一个唯一的binder_node对象或者binder_ref对象.他们之间的查找过程如下： 如果发送的flat_binder_object.type=BINDER, 在发送进程内查找flat_binder_object.binder对应的binder_node 如果找到则执行步骤4，否则执行步骤3 在发送进程内创建新的binder_node,binder_node.ptr=flat_binder_object.binder 在接收进程内查找binder_node对应的binder_ref,如果找到则执行步骤6，否则执行步骤5 在接收进程内创建新的binder_ref,binder_ref.node=binder_node,分配binder_ref.desc值 修改flat_binder_object.type=HANDLE（BINDER_TYPE_BINDER-&gt;BINER_TYPE_HANDLE；BINDER_TYPE_WEAK_BINDER-&gt;BINDER_TYPE_WEAK_HANDLE). 修改flat_binder_object.handle=binder_refs.desc 如果发送的flat_binder_object.type=HANDLE, 在发送进程内查找flat_binder_object.handle对应的binder_ref,如果找到，执行步骤3，否则执行步骤2 设置error为BR_FAILED_REPLY，执行步骤11（这里的设计，防止了Client通过蒙猜的方式进行非法通信 binder_ref.node.proc是否为接收进程，如果是，则执行步骤4，否则执行步骤7 设置flat_binder_obecjt.type=BINDER（BINDER_TYPE_HANDLE-&gt;BINDER_TYPE_BINDER; BINDER_TYPE_WEAK_HANDLE-&gt;BINDER_TYPE_WEAK_BINDER) 设置flat_binder_object.binder=binder_ref.node.binder. 设置flat_binder_object.cookies=binder_ref.node.cookies,执行步骤11 在接收进程内超找对应的binder_ref，如果未找到，执行步骤8，否则执行步骤10 在接收进程内创建新的binder_ref 设置binder_ref(接收进程）.node=binder_ref(发送进程）.node,并分配binder_refs（接收进程）.desc 设置flat_binder_object.handle=binder_ref（接收进程）.desc 结束 进程1的BpBinder在发起跨进程调用时，向binder驱动传入了自己记录的句柄值，binder驱动就会在“进程1对应的binder_proc结构”的引用树中查找和句柄值相符的binder_ref节点，一旦找到binder_ref节点，就可以通过该节点的node域找到对应的binder_node节点，这个目标binder_node当然是从属于进程2的binder_proc啦，不过不要紧，因为binder_ref和binder_node都处于binder驱动的地址空间中，所以是可以用指针直接指向的。目标binder_node节点的cookie域，记录的其实是进程2中BBinder的地址，binder驱动只需把这个值反映给应用层，应用层就可以直接拿到BBinder了。 传输机制的大体运作Binder IPC机制的大体思路是这样的，它将每次“传输并执行特定语义的”工作理解为一个小事务，既然所传输的数据是binder_transaction_data类型的，那么这种事务的类名可以相应地定为binder_transaction。系统中当然会有很多事务啦，那么发向同一个进程或线程的若干事务就必须串行化起来，因此binder驱动为进程节点（binder_proc）和线程节点（binder_thread）都设计了个todo队列。todo队列的职责就是“串行化地组织待处理的事务”。下图绘制了一个进程节点，以及一个从属于该进程的线程节点，它们各带了两个待处理的事务（binder_transaction）： 这样看来，传输动作的基本目标就很明确了，就是想办法把发起端的一个binder_transaction节点，插入到目标端进程或其合适子线程的todo队列去。可是，该怎么找目标进程和目标线程呢？基本做法是先从发起端的BpBinder开始，找到与其对应的binder_node节点，这个在前文阐述binder_proc的4棵红黑树时已经说过了，这里不再赘述。总之拿到目标binder_node之后，我们就可以通过其proc域，拿到目标进程对应的binder_proc了。如果偷懒的话，我们直接把binder_transaction节点插到这个binder_proc的todo链表去，就算完成传输动作了。当然，binder驱动做了一些更精细的调整。binder驱动希望能把binder_transaction节点尽量放到目标进程里的某个线程去，这样可以充分利用这个进程中的binder工作线程。比如一个binder线程目前正睡着，它在等待其他某个线程做完某个事情后才会醒来，而那个工作又偏偏需要在当前这个binder_transaction事务处理结束后才能完成，那么我们就可以让那个睡着的线程先去做当前的binder_transaction事务，这就达到充分利用线程的目的了。反正不管怎么说，如果binder驱动可以找到一个合适的线程，它就会把binder_transaction节点插到它的todo队列去。而如果找不到合适的线程，还可以把节点插入目标binder_proc的todo队列。 Binder 相关数据结构这一部分内容可以用到的时候再看,主要是数据的封装和解析 flat_binder_object进程间传输的数据被称为Binder对象（Binder Object），它是一个flat_binder_object，binder驱动接收和返回的数据中，如果有BpBinder或者BBinder，都会转成一个flat_binder_object对象，然后再进行赋值或者解析，它的定义如下： 12345678910111213141516171819/* * This is the flattened representation of a Binder object for transfer * between processes. The &#x27;offsets&#x27; supplied as part of a binder transaction * contains offsets into the data where these structures occur. The Binder * driver takes care of re-writing the structure type and data as it moves * between processes. */struct flat_binder_object &#123; /* 8 bytes for large_flat_header. */ unsigned long type; unsigned long flags; /* 8 bytes of data. */ union &#123; void *binder; /* local object */ signed long handle; /* remote object */ &#125;; /* extra data associated with local object */ void *cookie; &#125;; 其中type表示类型,flags描述了传输方式，比如同步、异步等。Android定义了五个（三大类）Binder类型，如下： 1234567891011121314 enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS(&#x27;s&#x27;, &#x27;b&#x27;, &#x27;*&#x27;, B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(&#x27;w&#x27;, &#x27;b&#x27;, &#x27;*&#x27;, B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS(&#x27;s&#x27;, &#x27;h&#x27;, &#x27;*&#x27;, B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE= B_PACK_CHARS(&#x27;w&#x27;, &#x27;h&#x27;, &#x27;*&#x27;, B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS(&#x27;f&#x27;, &#x27;d&#x27;, &#x27;*&#x27;, B_TYPE_LARGE), &#125;; enum transaction_flags &#123; TF_ONE_WAY = 0x01, /* this is a one-way call: async, no return */ TF_ROOT_OBJECT = 0x04, /* contents are the component&#x27;s root object */ TF_STATUS_CODE = 0x08, /* contents are a 32-bit status code */ TF_ACCEPT_FDS = 0x10, /* allow replies with file descriptors */ &#125;; 忽略强弱引用的差异，type可以分为三类BINDER、HANDLE、FD。 type为BINDER类型时，flat_binder_object代表binder_node,flat_binder_object.binder等于相应binder_node.ptr，指向Service用户空间的BBinder。 type为HANDLE类型时，flat_binder_object代表binder_ref,flat_binder_object.handle等于相应binder_refs.desc,也就是等于Client用户空间BpBinder.handle。 type为FD类型时，flat_binder_object代表文件Binder，flat_binder_object.handle是文件在进程内的文件号。 传输的数据是一个复用数据联合体，对于BINDER类型，数据就是一个binder本地对象，如果是HANDLE类型，这数据就是一个远程的handle对象。该如何理解本地binder对象和远程handle对象呢？其实它们都指向同一个对象，不过是从不同的角度来说。举例来说，假如A有个对象X，对于A来说，X就是一个本地的binder对象；如果B想访问A的X对象，这对于B来说，X就是一个handle。因此，从根本上来说handle和binder都指向X。本地对象还可以带有额外的数据，保存在cookie中。 binder_nodebinder_node 代表一个内核中的binder实体，每一个binder_node都关联到用户态的BBinder对象。Binder实体服务其实有两种，一是通过addService注册到ServiceManager中的服务，比如ActivityManagerService、PackageManagerService、PowerManagerService等，一般都是系统服务；还有一种是通过bindService拉起的一些服务，一般是开发者自己实现的服务。 1234567891011121314151617181920212223struct binder_node &#123; int debug_id; struct binder_work work;//work.type=BINDER_WORK_NODE union &#123; struct rb_node rb_node;//binder_node通过本节点，链入到binder_proc的nodes成员所指向的红黑树中 struct hlist_node dead_node; &#125;; struct binder_proc *proc;//binder_node所属进程的binder_proc struct hlist_head refs;//binder_ref列表，储存了所有引用本binder_node的binder_ref int internal_strong_refs;//指向本binder_node的强binder_ref计数 int local_weak_refs;//本地弱引用计数 int local_strong_refs;//本地强引用计数 void __user *ptr;//指向用户态Binder实例的指针，通常指向BBinder的弱引用 void __user *cookie;//自定义数据，通常为指向BBinder的指针 unsigned has_strong_ref : 1; unsigned pending_strong_ref : 1; unsigned has_weak_ref : 1; unsigned pending_weak_ref : 1; unsigned has_async_transaction : 1; unsigned accept_fds : 1; int min_priority : 8;//最低优先级 struct list_head async_todo;//异步binder&#125;; binder_refbinder_ref 代表内核中的binder引用，用户态每一个有效的BpBinder都关联到特定的binder_ref。同时binder_ref总是关联到一个binder_node 1234567891011121314151617struct binder_ref &#123; /* Lookups needed: */ /* node + proc =&gt; ref (transaction) */ /* desc + proc =&gt; ref (transaction, inc/dec ref) */ /* node =&gt; refs + procs (proc exit) */ int debug_id; struct rb_node rb_node_desc;//binder_ref通过本节点，链入到binder_proc的refs_by_desc所指向的红黑树中 struct rb_node rb_node_node;//同上，链入到binder_proc的refs_by_node所指向的红黑树中 struct hlist_node node_entry;//binder_ref通过本节点，链入到binder_node的refs成员所指向的双向链表中 struct binder_proc *proc;//所属的binder_proc struct binder_node *node;//所指向的binder_node uint32_t desc;//序号,等于BpBinder.mhandle int strong;//强引用计数 int weak;//弱引用计数 struct binder_ref_death *death;//Binder死亡通知&#125;; binder_procbinder_proc代表了使用binder driver的process，保存了process的相关信息。binder driver会为每一个调用过open函数打开“dev/binder”文件的进程创建一个binder_proc. 12345678910111213141516171819202122232425262728293031323334 //binder_proc的结构struct binder_proc &#123; struct hlist_node proc_node; //全局binder_proc列表，双向列表 struct rb_root threads; //binder_thread红黑树，process内使用binder driver的线程都会被保存在这颗红黑树中 struct rb_root nodes; //binder_node（binder实体）红黑树，process所持有的binder_node都保存在这颗红黑树中 struct rb_root refs_by_desc;//binder_ref（binder引用）红黑树，process所持有的biner_refs都会保存在颗红黑树中，红黑树以binder_ref.desc排序 struct rb_root refs_by_node;//同refs_by_desc，不过以binder_ref.node排序 int pid;//进程号 struct vm_area_struct *vma;//进程虚地址分配表 struct task_struct *tsk;//进程描述符 struct files_struct *files;//文件描述符列表 struct hlist_node deferred_work_node; int deferred_work; void *buffer;//binder缓冲区在内核态的地址 ptrdiff_t user_buffer_offset;//binder缓冲区在内核态地址与用户态地址的偏移量 struct list_head buffers;//binder_buffer列表 struct rb_root free_buffers;//空闲binder_buffer红黑树 struct rb_root allocated_buffers;//已分配binder_buffer红黑树 size_t free_async_space; struct page **pages;//内存分配页表 size_t buffer_size;//binder缓冲区到大小 uint32_t buffer_free;//空闲的binder缓冲区 struct list_head todo;//binder_work列表，等待被处理的binder_work wait_queue_head_t wait;//linux内核等待队列，参考函数wait_event&amp;wake_up struct binder_stats stats; struct list_head delivered_death; int max_threads;//最大线程数量 int requested_threads; int requested_threads_started; int ready_threads; long default_priority;&#125;; binder_procsbinder_procs结构的定义： 1static HLIST_HEAD(binder_procs); 展开后得到 1struct hlist_head binder_procs = &#123; .first = NULL &#125;; 随着后续不断向binder_procs表中添加节点，这个表会不断加长，示意图如下： binder_threadbinder_thread代表了binder_proc内的线程，保存了线程相关信息。binder driver会为每一个调用过ioctl函数操作“dev/binder”文件的线程创建binder_thread. 1234567891011121314struct binder_thread &#123; struct binder_proc *proc;//线程所属进程的binder_proc struct rb_node rb_node;//binder_thread通过rb_node链入到binder_proc的threads成员指向的红黑树中 int pid;//线程号,为什么线程号也叫pid呢？ int looper; struct binder_transaction *transaction_stack;//暂存binder_transaction struct list_head todo;//binder_work列表，等待被处理的binder_work uint32_t return_error; /* Write failed, return error code in read buf */ uint32_t return_error2; /* Write failed, return error code in read */ /* buffer. Used when sending a reply to a dead process that */ /* we are also waiting on */ wait_queue_head_t wait;//linux内核等待队列，参考函数wait_event&amp;wake_up struct binder_stats stats;&#125;; binder_write_readbinder_write_read为BINDER_WRITE_READ指定的数据类型，它的定义如下： 12345678struct binder_write_read &#123; signed long write_size; /* bytes to write */ signed long write_consumed; /* bytes consumed by driver */ unsigned long write_buffer; signed long read_size; /* bytes to read */ signed long read_consumed; /* bytes consumed by driver */ unsigned long read_buffer;&#125;; binder_transaction_databinder_transaction_data为写入协议BC_TRANSACTION、BC_REPLY以及读出协议BR_TRANSACTION、BR_REPLY所指定的数据类型，Binder驱动的使用者（e.i. Client、Service、Service Manager）通过binder_transaction_data和Binder driver进行数据交换。 12345678910111213141516171819202122232425262728293031struct binder_transaction_data &#123; /* The first two are only used for bcTRANSACTION and brTRANSACTION, * identifying the target and contents of the transaction. */ union &#123; size_t handle; /* target descriptor of command transaction */ void *ptr; /* target descriptor of return transaction */ &#125; target; void *cookie; /* target object cookie */ unsigned int code; /* transaction command */ //Service自定义的指令码，以SeviceManager的addService为函数例的话，code=ADD_SERVICE_TRANSACTION /* General information about the transaction. */ unsigned int flags; //TF_ACCEPT_FDS TF_ONE_WAY pid_t sender_pid; //发送方进程id uid_t sender_euid; //发送方用户id size_t data_size; /* number of bytes of data */ size_t offsets_size; /* number of bytes of offsets */ /* If this transaction is inline, the data immediately * follows here; otherwise, it ends with a pointer to * the data buffer. */ union &#123; struct &#123; /* transaction data */ const void *buffer; /* offsets from buffer to flat_binder_object structs */ const void *offsets; &#125; ptr; uint8_t buf[8]; &#125; data;&#125;; 就像注释中说明的那样，target成员和cookie成员仅在BC_TRANSACTION和BR_TRANSACTION协议中使用。通常，Client使用BC_TRANSACTION协议写入数据时，需要通过target.handle指定数据接收方。而Service读取到BR_TRANSACTION的binder_transaction_data.ptr成员保存了用户空间binder实体的地址（实际上，BBinder的弱引用地址），而cookie成员保存了用户数据（实际上，cookie才真正保存了BBinder的地址）。而使用BC_REPLY写入时，Binder driver忽略这两个参数，而读取到BR_REPLY的 binder_transaction_data的target和cookie成员则恒为空。 最后，也是对于理解binder_transaction_data最重要的一点，binder_transaction_data结构体，并不包含传输的数据，而是通过其ptr.buffer成员保存了数据的内存地址。而ptr.offsets成员则保存了Binder对象（或者说flat_binder_object）在ptr.buffer的偏移量数组的首地址。data_size成员则记录了数据的长度，offsets_size则是编译量数组的长度（以字节为单位，所以，编译量数组实际的长度是offsets_size/4)。 binder 用户接口 binder_open() 12345678910111213141516static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; . . . . . . proc = kzalloc(sizeof(*proc), GFP_KERNEL); get_task_struct(current); proc-&gt;tsk = current; . . . . . . hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); proc-&gt;pid = current-&gt;group_leader-&gt;pid; . . . . . . filp-&gt;private_data = proc; . . . . . .&#125; 主要做了以下几件事情： 首先，binder驱动分配内存以保存binder_proc数据结构。然后，binder填充binder_proc数据（初始化），增加当前线程/进程的引用计数并赋值给tsk 增加BINDER_STAT_PROC的对象计数，并把创建的binder_proc对象添加到全局的binder_procs中，这样任何一个进程就都可以访问到其他进程的binder_proc对象了。 把binder_proc对象指针赋值给filp的private_data域中，在后面每次执行binder_ioctl()，都会从filp-&gt;private_data域重新读取binder_proc。 binder_mmap() 内存的映射： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596static int binder_mmap(struct file *filp, struct vm_area_struct *vma) &#123; int ret; //需要映射的内核空间地址信息 struct vm_struct *area; //取出binder_open时保存的binder_proc数据 struct binder_proc *proc = filp-&gt;private_data; struct binder_buffer *buffer; //保证这块内存最多只有4M if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE; //申请一段内存空间给内核进程 area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); //得到映射的内核空间虚拟地址首地址 proc-&gt;buffer = area-&gt;addr; //计算用户空间与映射的内核空间的地址偏移量 proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer; //得到映射地址的页数 proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); //映射空间的大小 proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; vma-&gt;vm_ops = &amp;binder_vm_ops; vma-&gt;vm_private_data = proc; //为虚拟地址空间proc-&gt;buffer ~ proc-&gt;buffer + PAGE_SIZE 分配一个空闲的物理页面 if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123; ret = -ENOMEM; failure_string = &quot;alloc small buf&quot;; goto err_alloc_small_buf_failed; &#125; buffer = proc-&gt;buffer; INIT_LIST_HEAD(&amp;proc-&gt;buffers); list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); buffer-&gt;free = 1; binder_insert_free_buffer(proc, buffer); proc-&gt;free_async_space = proc-&gt;buffer_size / 2; barrier(); proc-&gt;files = get_files_struct(current); proc-&gt;vma = vma; return 0;err_alloc_small_buf_failed: kfree(proc-&gt;pages); proc-&gt;pages = NULL;err_alloc_pages_failed: vfree(proc-&gt;buffer); proc-&gt;buffer = NULL;err_get_vm_area_failed:err_already_mapped:err_bad_arg: return ret;&#125;static int binder_update_page_range(struct binder_proc *proc, int allocate, void *start, void *end, struct vm_area_struct *vma) &#123; void *page_addr; unsigned long user_page_addr; struct vm_struct tmp_area; struct page **page; struct mm_struct *mm; //以页为单位分配物理页面，由于此时的end=start+PAGE_SIZE，因此只会循环一次 for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123; int ret; struct page **page_array_ptr; page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE]; //分配物理页面 *page = alloc_page(GFP_KERNEL | __GFP_ZERO); if (*page == NULL) &#123; goto err_alloc_page_failed; &#125; tmp_area.addr = page_addr; tmp_area.size = PAGE_SIZE + PAGE_SIZE /* guard page? */; page_array_ptr = page; //把这个物理页面插入到内核空间去 ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr); if (ret) &#123; goto err_map_kernel_failed; &#125; user_page_addr = (uintptr_t)page_addr + proc-&gt;user_buffer_offset; //将这个物理页面插入到进程地址空间去 ret = vm_insert_page(vma, user_page_addr, page[0]); if (ret) &#123; goto err_vm_insert_page_failed; &#125; &#125; return 0;&#125; binder_ioctl() 这个函数是Binder的最核心部分，Binder的功能就是通过ioctl命令来实现的。Binder的ioctl命令共有7个，定义在ioctl.h头文件中： 1234567891011121314#define BINDER_WRITE_READ _IOWR(&#x27;b&#x27;, 1, struct binder_write_read)#define BINDER_SET_IDLE_TIMEOUT _IOW(&#x27;b&#x27;, 3, int64_t)#define BINDER_SET_MAX_THREADS _IOW(&#x27;b&#x27;, 5, size_t)#define BINDER_SET_IDLE_PRIORITY _IOW(&#x27;b&#x27;, 6, int)#define BINDER_SET_CONTEXT_MGR _IOW(&#x27;b&#x27;, 7, int)#define BINDER_THREAD_EXIT _IOW(&#x27;b&#x27;, 8, int)#define BINDER_VERSION _IOWR(&#x27;b&#x27;, 9, struct binder_version) 首先是BINDER_SET_IDLE_TIMEOUT 和 BINDER_SET_IDLE_PRIORITY在目前的Binder驱动中没有实现。 BINDER_SET_MAX_THREADS 这个ioctl命令用于设置进程的Biner对象所支持的最大线程数。设置的值保存在binder_proc结构的max_threads成员里。 BINDER_SET_CONTEXT_MGR 从功能上看，只有一个进程/线程能成功设置binder_context_mgr_node对象，这个进程被称为Context Manager（context_mgr）。当然，也只有创建binder_context_mgr_node对象的Binder上下文管理进程/线程才有权限重新设置这个对象。进程的权限（cred-&gt;euid）保存在binder_context_mgr_uid对象里。 从接口的角度来说，这是一个进程想要成为一个Context Manager的唯一接口。一个Context Manager进程需要为binder_proc创建一个binder_node类型的节点。节点是通过binder_new_node函数来创建的，我们在后面在详细讲解这个函数。节点创建成功后内核会初始化节点的部分数据（weak_ref和strong_ref） 对于ContextManager对象来说，binder_node是binder_context_mgr_node，这个是全局变量；这个binder对象的索引（handler）固定为0 BINDER_THREAD_EXIT 通过调用binder_free_thread终止并释放binder_thread对象及其binder_transaction事务。 BINDER_VERSION 读取当前Binder驱动支持的协议版本号。 BINDER_WRITE_READ 这个ioctl命令是Binder最核心的部分，Android Binder的IPC机制就是通过这个接口来实现的。 引用：听说你Binder机制学的不错，来面试下这几个问题Android进程间通信（IPC）机制Binder简要介绍和学习计划深入分析Android Binder 驱动红茶一杯话Binder","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[{"name":"binder","slug":"binder","permalink":"http://example.com/tags/binder/"}],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"Android-wms总结","slug":"Android-wms总结","date":"2018-08-14T10:40:04.000Z","updated":"2018-11-05T14:16:43.679Z","comments":true,"path":"2018/08/14/Android-wms总结/","link":"","permalink":"http://example.com/2018/08/14/Android-wms%E6%80%BB%E7%BB%93/","excerpt":"Android 中的窗口是屏幕上一块用于 显示各种视图 并且可以响应用户输出的 矩形区域。从原理上来说，窗口的是独占一个Surface实例的显示区域。而WindowsManagerService则是运行在系统进程中的用于 为窗口分配Surface,控制Surface的Z-order，位置，尺寸，窗口动画等功能的 一项重要服务，并且还是输入系统的一个中转站，负责转发输入系统的消息到具体的窗口进行响应。","text":"Android 中的窗口是屏幕上一块用于 显示各种视图 并且可以响应用户输出的 矩形区域。从原理上来说，窗口的是独占一个Surface实例的显示区域。而WindowsManagerService则是运行在系统进程中的用于 为窗口分配Surface,控制Surface的Z-order，位置，尺寸，窗口动画等功能的 一项重要服务，并且还是输入系统的一个中转站，负责转发输入系统的消息到具体的窗口进行响应。 Android中显示出一个窗口内容主要经过以下几个步骤： 获取wms服务：IWindowManager wms = IWindowManager.Stub.asInterface(ServiceManager.getService(Context.WINDOW_SERVICE)) 获取窗口的Session：mSession = WindowManagerGlobal.getWindowSession(Looper.myLooper) 添加窗口: wms.addWindowToken() ; mSession.add(...) 确定窗口大小，尺寸:mSession.relayout(...) renderFrames : mChoreographer.postCallback(renderRunnable,...) 在后面，我们分析RootView的时候会看到这些过程 Android的显示层次可以分为三层: UI框架层，这里是在surface上绘制的ui元素和相应输入事件 wms, 这里是管理surface的分配，层级顺序等 surfaceflinger , 负责将多个Suface混合并输出 wms的重要成员 mInputManager , InputManagerService的实例 mChoreographer , Choreographer的实例 mPolicy , WindowsPolicyManager的实例，目前只有PhoneWindowManager一个实现类。负责窗口的相关策略，比如告诉wms一个窗口的z-order是多少，为wms监听屏幕的旋转状态，矫正窗口属性，预处理Home,Back按键的默认行为等 mTokenMap , 一个Hashmap, 保存了窗口的令牌，一个窗口必须隶属于某个令牌。其中还有一些子集，比如有些是保存的windowToken,有些是保存的AppWindowToken等，其中AppWindowToken是有序的，和AMS中的mHistory列表保持一直，反映了系统中的Activity的顺序。和ams交互会用到 mWindowMap , 保存了 windowState 实例，用于窗口的管理，它也有一些自己，窗口在这个列表中的位置决定了窗口最终显示的Z序， windowState 主要用于wms通知客户端执行一些方法 mSessions , IWindowSession 的Bn端， IWindowSession 主要用于客户端通知wms执行一些方法 WindowToken WindowToken 具有令牌的作用，是对应用组件的行为进行规范管理的一个手段。应用组件再需要新窗口时，必须提供WindowToken表明自己的身份，wms也会检查WindowToken和窗口的type直接的关联，保证一致。比如，Wallpaper只能创建 Type_WALLPAPER 类型的窗口，并且只有当前的Wallpaper才能创建窗口，因为其他的窗口没有有效的token. WindowToken 将属于同一个应用组件的窗口组织在一起。比如在z-order排序的时候。 对于客户端而言，Token仅仅是一个任意的Binder实例，对于wms而言，会生成一个对应的WindowToken并存储在map中。 AppWindowToken , AppWindowToken是为了管理Activity而创建的，它继承WindowToken并增加了一些新的功能。 对于AMS来说，AMS会为每一个Activity创建一个ActivityStack,这其中则包含了一个类型为IApplicationToken.Stub的appToken对象，在启动的过程中会把这个对象传给wms，wms则为它创建一个AppWindowToken，其中包含了IApplicationToken对象，这个对象实际上是一个远程代理接口，因此，wms可以在窗口变化的时候通知ams,而ams也可以通过ActivityStack在wms中找到对应的AppWindowToken，进而控制这个窗口的绘制和排序 WindowState上面说到WindowToken是wms与ams交互的数据结构，这里WindowState就是wms通知客户端的数据结构。客户端addWindow时会传入IWindow的Bn端，wms则会拿到IWindow的Bp端，当wms有需要的时候，则可以通过Bp端去调用Bn端的方法控制客户端，比如尺寸变化，焦点变化等。 窗口的显示顺序Android系统会依据窗口的类型确定主序mBaseLayer,依据子窗口类型确定子序mSubLayer,最后根据一定的算法由主序子序以及其他参数（比如同类型的窗口出现的顺序，壁纸类型的窗口等）来计算出最终显示次序mLayer. 窗口的布局窗口的布局本身其实就是一个计算窗口尺寸和位置的过程，但是因为窗口之间的关系，层次等原因，导致计算涉及到的变量特别多，因此变的非常复杂。主要的过程是： 准备所需要的参数，比如屏幕尺寸，顶部状态栏/底部导航栏大小/可见性，屏幕旋转等 计算顶级窗口的属性，保存在WindowState 计算子窗口的属性，需要依赖第二步计算出的结果。 完成一次布局，清理变量和资源 在一次布局完成后，窗口的属性计算并没有结束，因为窗口还有flag 属性没有计算进去，但是窗口的flag属性会影响窗口尺寸的计算，反过来窗口尺寸的计算也会影响到flag的有效性，因此 一次布局完成后，还需要根据flag再次进行布局计算，直到flag和窗口的属性都能一致为止。","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"Java-线程池","slug":"Java-线程池","date":"2018-08-14T08:56:52.000Z","updated":"2021-01-24T09:16:44.680Z","comments":true,"path":"2018/08/14/Java-线程池/","link":"","permalink":"http://example.com/2018/08/14/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"最近遇到一个问题，如果Java线程池的设置是,coresize=0,队列为无界队列，maxSize=1，这个线程池会不会工作，会怎样工作？","text":"最近遇到一个问题，如果Java线程池的设置是,coresize=0,队列为无界队列，maxSize=1，这个线程池会不会工作，会怎样工作？ 之前对于线程池的使用和关注，基本上都只是看了下概念，没怎么去看一下源码的执行流程，遇到这个问题的时候，就难住了。后面翻了下源码，又在网上看了下资料，找到一篇写的挺好的资料，于是转过来，主要是怕文章不知道什么时候会404了。 其实问题的关键在于，大多数的书讲线程池的时候都没有提到线程池的状态。coresize=0,队列为无界队列，maxSize=1的时候，初次执行execute()，根据线程池状态和配置，会直接进入到 启动非核心线程来执行任务，后续的runnable都会加入到无界队列中，第一个runnable执行完毕后，worker会调用getTask从队列中获取任务产生新的worker，因此会实际上变成单线程执行任务的线程池。 Java线程池ThreadPoolExecutor使用和分析(二) - execute()原理 execute()是 java.util.concurrent.Executor接口中唯一的方法，JDK注释中的描述是“在未来的某一时刻执行命令command”，即向线程池中提交任务，在未来某个时刻执行，提交的任务必须实现Runnable接口，该提交方式不能获取返回值。下面是对execute()方法内部原理的分析，分析前先简单介绍线程池有哪些状态，在一系列执行过程中涉及线程池状态相关的判断。以下分析基于JDK 1.7 一、线程池的执行流程 如果线程池中的线程数量少于corePoolSize，就创建新的线程来执行新添加的任务 如果线程池中的线程数量大于等于corePoolSize，但队列workQueue未满，则将新添加的任务放到workQueue中 如果线程池中的线程数量大于等于corePoolSize，且队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务 如果线程池中的线程数量等于了maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略 二、线程池状态12345678910111213141516private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;// 合并 线程池的状态和工作线程的数量到一个整数private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 其中ctl这个AtomicInteger的功能很强大，其高3位用于维护线程池运行状态，低29位维护线程池中线程数量 RUNNING：-1&lt;&lt;COUNT_BITS，即 111 00000000000000000000000000000 ，该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务 SHUTDOWN：0&lt;&lt;COUNT_BITS，即 000 00000000000000000000000000000，该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务 STOP：1&lt;&lt;COUNT_BITS，即 001 00000000000000000000000000000，该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务 TIDYING：2&lt;&lt;COUNT_BITS，即 010 00000000000000000000000000000，所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法 TERMINATED：3&lt;&lt;COUNT_BITS，即 011 00000000000000000000000000000，terminated()方法调用完成后变成此状态 这些状态均由int型表示，大小关系为 RUNNING&lt;SHUTDOWN&lt;STOP&lt;TIDYING&lt;TERMINATED，这个顺序基本上也是遵循线程池从 运行 到 终止这个过程。 各个状态的转换过程 : RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的 (RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了 SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING STOP -&gt; TIDYING：当任务队列清空后，发生这个转换 TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后 三、任务提交内部原理execute() – 提交任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Executes the given task sometime in the future. The task * may execute in a new thread or in an existing pooled thread. * 在未来的某个时刻执行给定的任务。这个任务用一个新线程执行，或者用一个线程池中已经存在的线程执行 * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;. * 如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理 * * @param command the task to execute * @throws RejectedExecutionException at discretion of * &#123;@code RejectedExecutionHandler&#125;, if the task * cannot be accepted for execution RejectedExecutionException是一个RuntimeException * @throws NullPointerException if &#123;@code command&#125; is null */public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn&#x27;t, by returning false. * 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务 * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * 如果任务成功放入队列，我们仍需要一个双重校验去确认是否应该新建一个线程（因为可能存在有些线程在我们上次检查后死了） 或者 从我们进入这个方法后，pool被关闭了 * 所以我们需要再次检查state，如果线程池停止了需要回滚入队列，如果池中没有线程了，新开启 一个线程 * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. * 如果无法将任务入队列（可能队列满了），需要新开一个线程（自己：往maxPoolSize发展） * 如果失败了，说明线程池shutdown 或者 饱和了，所以我们拒绝任务 */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; //addWorker()成功，返回 if (addWorker(command, true)) return; /** * 没有成功addWorker()，再次获取c（凡是需要再次用ctl做判断时，都会再次调用ctl.get()） * 失败的原因可能是： * 1、线程池已经shutdown，shutdown的线程池不再接收新任务 * 2、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize */ c = ctl.get(); &#125; /** * 如果线程池RUNNING状态，并且入队列成功，入队成功还不是表示这个任务能执行 */ if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); /** * 再次校验放入workerQueue中的任务是否能被执行 * 1、如果线程池不是运行状态了，应该拒绝添加新任务，从workQueue中删除任务 * 2、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了） */ if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 如果线程不说running状态了，或者入队失败（意思是队列满了），尝试添加新的工作线程，失败则执行拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; execute(Runnable command) 参数： command 提交执行的任务，不能为空执行流程：1、如果线程池当前线程数量少于corePoolSize，则addWorker(command, true)创建新worker线程，如创建成功返回，如没创建成功，则执行后续步骤； addWorker(command, true)失败的原因可能是： A、线程池已经shutdown，shutdown的线程池不再接收新任务 B、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize2、如果线程池还在running状态，将task加入workQueue阻塞队列中，如果加入成功，进行double-check，如果加入失败（可能是队列已满），则执行后续步骤； double-check主要目的是判断刚加入workQueue阻塞队列的task是否能被执行 A、如果线程池已经不是running状态了，应该拒绝添加新任务，从workQueue中删除任务 B、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了）3、如果线程池不是running状态 或者 无法入队列，尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command addWorker() – 添加worker线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/*** 判断是不是要创建新的工作线程，如果可以创建就创建，如果不能创建，返回false*/private boolean addWorker(Runnable firstTask, boolean core) &#123; //这个循环有三个出口，但是如果符合创建条件却创建失败的话（CAS冲突），会一直尝试直到成功，跳出循环，开始创建worker,或者线程池状态改变到不允许状态了，直接返回false了 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //状态 // Check if queue empty only if necessary. /** * 线程池的state越小越是运行状态，runnbale=-1，shutdown=0,stop=1,tidying=2，terminated=3 * 1、如果线程池state已经至少是shutdown状态了 * 2、并且以下3个条件任意一个是false * rs == SHUTDOWN 假如这里是false，意思是线程池状态已经超过shutdown，可能是stop、tidying、terminated其中一个，此时不允许再添加工作线程 * firstTask == null 假如这里是false，意思是线程池已经shutdown了，还要添加新的任务，拒绝 * ! workQueue.isEmpty() 假如这里是false，意思是 线程池已经shutdown了，不添加新的任务，但是还要处理阻塞队列里面的任务，如果workQueue已经为空，那么就没有添加新worker线程的必要了 * return false，即无法addWorker() */ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()) ) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //调用unsafe CAS操作，使得worker数量+1，成功则跳出整个retry循环，准备创建新worker,否则 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); //如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断 if (runStateOf(c) != rs) continue retry; &#125; &#125; /** * worker数量+1成功的后续操作 * 添加到workers Set集合，并启动worker线程 */ boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; final ReentrantLock mainLock = this.mainLock; w = new Worker(firstTask); //1、设置worker这个AQS锁的同步状态state=-1 //2、将firstTask设置给worker的成员变量firstTask //3、使用worker自身这个runnable，调用ThreadFactory创建一个线程，并设置给worker的成员变量thread final Thread t = w.thread; if (t != null) &#123; mainLock.lock(); try &#123; //--------------------------------------------这部分代码是上锁的 // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 当获取到锁后，再次检查 int c = ctl.get(); int rs = runStateOf(c); //如果线程池在运行running&lt;shutdown 或者 线程池已经shutdown，且firstTask==null（可能是workQueue中仍有未执行完成的任务，创建没有初始任务的worker线程执行） //worker数量-1的操作在addWorkerFailed() if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable 线程已经启动，抛非法线程状态异常 throw new IllegalThreadStateException(); workers.add(w);//workers是一个HashSet&lt;Worker&gt; //设置最大的池大小largestPoolSize，workerAdded设置为true int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; //-------------------------------------------- &#125; finally &#123; mainLock.unlock(); &#125; //如果往HashSet中添加worker成功，启动线程 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; //如果启动线程失败 if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; addWorker(Runnable firstTask, boolean core)参数： firstTask： worker线程的初始任务，可以为空 core： true：将corePoolSize作为上限，false：将maximumPoolSize作为上限addWorker方法有4种传参的方式： 1、addWorker(command, true) 2、addWorker(command, false) 3、addWorker(null, false) 4、addWorker(null, true) 在execute方法中就使用了前3种，结合这个核心方法进行以下分析 第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false 第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false 第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务 第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行执行流程： 判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以return false： A、线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程 B、线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务 C、线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义 线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步 在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这一切都成功了，return true，如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑 内部类Worker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * Class Worker mainly maintains interrupt control state for * threads running tasks, along with other minor bookkeeping. * This class opportunistically extends AbstractQueuedSynchronizer * to simplify acquiring and releasing a lock surrounding each * task execution. This protects against interrupts that are * intended to wake up a worker thread waiting for a task from * instead interrupting a task being run. We implement a simple * non-reentrant mutual exclusion lock rather than use * ReentrantLock because we do not want worker tasks to be able to * reacquire the lock when they invoke pool control methods like * setCorePoolSize. Additionally, to suppress interrupts until * the thread actually starts running tasks, we initialize lock * state to a negative value, and clear it upon start (in * runWorker). * * Worker类大体上管理着运行线程的中断状态 和 一些指标 * Worker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁 * 这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程 * 解释： * 为什么不直接执行execute(command)提交的command，而要在外面包一层Worker呢？？ * 主要是为了控制中断 * 用什么控制？？ * 用AQS锁，当运行时上锁，就不能中断，TreadPoolExecutor的shutdown()方法中断前都要获取worker锁 * 只有在等待从workQueue中获取任务getTask()时才能中断 * worker实现了一个简单的不可重入的互斥锁，而不是用ReentrantLock可重入锁 * 因为我们不想让在调用比如setCorePoolSize()这种线程池控制方法时可以再次获取锁(重入) * 解释： * setCorePoolSize()时可能会interruptIdleWorkers()，在对一个线程interrupt时会要w.tryLock() * 如果可重入，就可能会在对线程池操作的方法中中断线程，类似方法还有： * setMaximumPoolSize() * setKeppAliveTime() * allowCoreThreadTimeOut() * shutdown() * 此外，为了让线程真正开始后才可以中断，初始化lock状态为负值(-1)，在开始runWorker()时将state置为0，而state&gt;=0才可以中断 * * * Worker继承了AQS，实现了Runnable，说明其既是一个可运行的任务，也是一把锁（不可重入） */private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; //利用ThreadFactory和 Worker这个Runnable创建的线程对象 /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; //设置AQS的同步状态private volatile int state，是一个计数器，大于0代表锁已经被获取 setState(-1); // inhibit interrupts until runWorker // 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;=0 this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); //根据当前worker创建一个线程对象 //当前worker本身就是一个runnable任务，也就是不会用参数的firstTask创建线程，而是调用当前worker.run()时调用firstTask.run() &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; runWorker(this); //runWorker()是ThreadPoolExecutor的方法 &#125; // Lock methods // // The value 0 represents the unlocked state. 0代表“没被锁定”状态 // The value 1 represents the locked state. 1代表“锁定”状态 protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; /** * 尝试获取锁 * 重写AQS的tryAcquire()，AQS本来就是让子类来实现的 */ protected boolean tryAcquire(int unused) &#123; //尝试一次将state从0设置为1，即“锁定”状态，但由于每次都是state 0-&gt;1，而不是+1，那么说明不可重入 //且state==-1时也不会获取到锁 if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); //设置exclusiveOwnerThread=当前线程 return true; &#125; return false; &#125; /** * 尝试释放锁 * 不是state-1，而是置为0 */ protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; /** * 中断（如果运行） * shutdownNow时会循环对worker线程执行 * 且不需要获取worker锁，即使在worker运行时也可以中断 */ void interruptIfStarted() &#123; Thread t; //如果state&gt;=0、t!=null、且t没有被中断 //new Worker()时state==-1，说明不能中断 if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125; Worker类Worker类本身既实现了Runnable，又继承了AbstractQueuedSynchronizer（以下简称AQS），所以其既是一个可执行的任务，又可以达到锁的效果new Worker()1、将AQS的state置为-1，在runWoker()前不允许中断2、待执行的任务会以参数传入，并赋予firstTask3、用Worker这个Runnable创建Thread 之所以Worker自己实现Runnable，并创建Thread，在firstTask外包一层，是因为要通过Worker控制中断，而firstTask这个工作任务只是负责执行业务Worker控制中断主要有以下几方面：1、初始AQS状态为-1，此时不允许中断interrupt()，只有在worker线程启动了，执行了runWoker()，将state置为0，才能中断 不允许中断体现在： A、shutdown()线程池时，会对每个worker tryLock()上锁，而Worker类这个AQS的tryAcquire()方法是固定将state从0-&gt;1，故初始状态state==-1时tryLock()失败，没法interrupt() B、shutdownNow()线程池时，不用tryLock()上锁，但调用worker.interruptIfStarted()终止worker，interruptIfStarted()也有state&gt;0才能interrupt的逻辑2、为了防止某种情况下，在运行中的worker被中断，runWorker()每次运行任务时都会lock()上锁，而shutdown()这类可能会终止worker的操作需要先获取worker的锁，这样就防止了中断正在运行的线程 Worker实现的AQS为不可重入锁，为了是在获得worker锁的情况下再进入其它一些需要加锁的方法 Worker和Task的区别：Worker是线程池中的线程，而Task虽然是runnable，但是并没有真正执行，只是被Worker调用了run方法，后面会看到这部分的实现。 runWorker() – 执行任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * Main worker run loop. Repeatedly gets tasks from queue and * executes them, while coping with a number of issues: * 重复的从队列中获取任务并执行，同时应对一些问题： * * 1. We may start out with an initial task, in which case we * don&#x27;t need to get the first one. Otherwise, as long as pool is * running, we get tasks from getTask. If it returns null then the * worker exits due to changed pool state or configuration * parameters. Other exits result from exception throws in * external code, in which case completedAbruptly holds, which * usually leads processWorkerExit to replace this thread. * 我们可能使用一个初始化任务开始，即firstTask为null * 然后只要线程池在运行，我们就从getTask()获取任务 * 如果getTask()返回null，则worker由于改变了线程池状态或参数配置而退出 * 其它退出因为外部代码抛异常了，这会使得completedAbruptly为true，这会导致在processWorkerExit()方法中替换当前线程 * * 2. Before running any task, the lock is acquired to prevent * other pool interrupts while the task is executing, and * clearInterruptsForTaskRun called to ensure that unless pool is * stopping, this thread does not have its interrupt set. * 在任何任务执行之前，都需要对worker加锁去防止在任务运行时，其它的线程池中断操作 * clearInterruptsForTaskRun保证除非线程池正在stoping，线程不会被设置中断标示 * * 3. Each task run is preceded by a call to beforeExecute, which * might throw an exception, in which case we cause thread to die * (breaking loop with completedAbruptly true) without processing * the task. * 每个任务执行前会调用beforeExecute()，其中可能抛出一个异常，这种情况下会导致线程die（跳出循环，且completedAbruptly==true），没有执行任务 * 因为beforeExecute()的异常没有cache住，会上抛，跳出循环 * * 4. Assuming beforeExecute completes normally, we run the task, * gathering any of its thrown exceptions to send to * afterExecute. We separately handle RuntimeException, Error * (both of which the specs guarantee that we trap) and arbitrary * Throwables. Because we cannot rethrow Throwables within * Runnable.run, we wrap them within Errors on the way out (to the * thread&#x27;s UncaughtExceptionHandler). Any thrown exception also * conservatively causes thread to die. * 假定beforeExecute()正常完成，我们执行任务 * 汇总任何抛出的异常并发送给afterExecute(task, thrown) * 因为我们不能在Runnable.run()方法中重新上抛Throwables，我们将Throwables包装到Errors上抛（会到线程的UncaughtExceptionHandler去处理） * 任何上抛的异常都会导致线程die * * 5. After task.run completes, we call afterExecute, which may * also throw an exception, which will also cause thread to * die. According to JLS Sec 14.20, this exception is the one that * will be in effect even if task.run throws. * 任务执行结束后，调用afterExecute()，也可能抛异常，也会导致线程die * 根据JLS Sec 14.20，这个异常（finally中的异常）会生效 * * The net effect of the exception mechanics is that afterExecute * and the thread&#x27;s UncaughtExceptionHandler have as accurate * information as we can provide about any problems encountered by * user code. * * @param w the worker */final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts // new Worker()是state==-1，此处是调用Worker类的tryRelease()方法，将state置为0， 而interruptIfStarted()中只有state&gt;=0才允许调用中断 boolean completedAbruptly = true; //是否“突然完成”，如果是由于异常导致的进入finally，那么completedAbruptly==true就是突然完成的 try &#123; /** * 如果task不为null，或者从阻塞队列中getTask()不为null */ while (task != null || (task = getTask()) != null) &#123; w.lock(); //上锁，不是为了防止并发执行任务，为了在shutdown()时不终止正在运行的worker // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt /** * clearInterruptsForTaskRun操作 * 确保只有在线程stoping时，才会被设置中断标示，否则清除中断标示 * 1、如果线程池状态&gt;=stop，且当前线程没有设置中断状态，wt.interrupt() * 2、如果一开始判断线程池状态&lt;stop，但Thread.interrupted()为true，即线程已经被中断，又清除了中断标示，再次判断线程池状态是否&gt;=stop * 是，再次设置中断标示，wt.interrupt() * 否，不做操作，清除中断标示后进行后续步骤 */ if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); //当前线程调用interrupt()中断 try &#123; //执行前（子类实现） beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //执行后（子类实现） afterExecute(task, thrown); //这里就考验catch和finally的执行顺序了，因为要以thrown为参数 &#125; &#125; finally &#123; task = null; //task置为null w.completedTasks++; //完成任务数+1 w.unlock(); //解锁 &#125; &#125; completedAbruptly = false; &#125; finally &#123; //处理worker的退出 processWorkerExit(w, completedAbruptly); &#125;&#125; runWorker(Worker w)执行流程：1、Worker线程启动后，通过Worker类的run()方法调用runWorker(this)2、执行任务之前，首先worker.unlock()，将AQS的state置为0，允许中断当前worker线程3、开始执行firstTask，调用task.run()，在执行任务前会上锁wroker.lock()，在执行完任务后会解锁，为了防止在任务运行时被线程池一些中断操作中断4、在任务执行前后，可以根据业务场景自定义beforeExecute() 和 afterExecute()方法5、无论在beforeExecute()、task.run()、afterExecute()发生异常上抛，都会导致worker线程终止，进入processWorkerExit()处理worker退出的流程6、如正常执行完当前task后，会通过getTask()从阻塞队列中获取新任务，当队列中没有任务，且获取任务超时，那么当前worker也会进入退出流程 getTask() – 获取任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * Performs blocking or timed wait for a task, depending on * current configuration settings, or returns null if this worker * must exit because of any of: 以下情况会返回null * 1. There are more than maximumPoolSize workers (due to * a call to setMaximumPoolSize). * 超过了maximumPoolSize设置的线程数量（因为调用了setMaximumPoolSize()） * 2. The pool is stopped. * 线程池被stop * 3. The pool is shutdown and the queue is empty. * 线程池被shutdown，并且workQueue空了 * 4. This worker timed out waiting for a task, and timed-out * workers are subject to termination (that is, * &#123;@code allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;) * both before and after the timed wait. * 线程等待任务超时 * * @return task, or null if the worker must exit, in which case * workerCount is decremented * 返回null表示这个worker要结束了，这种情况下workerCount-1 */private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? /** * 外层循环 * 用于判断线程池状态 */ retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. /** * 对线程池状态的判断，两种情况会workerCount-1，并且返回null * 线程池状态为shutdown，且workQueue为空（反映了shutdown状态的线程池还是要执行workQueue中剩余的任务的） * 线程池状态为stop（shutdownNow()会导致变成STOP）（此时不用考虑workQueue的情况） */ if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); //循环的CAS减少worker数量，直到成功 return null; &#125; boolean timed; // Are workers subject to culling? // 是否需要定时从workQueue中获取 /** * 内层循环 * 要么break去workQueue获取任务 * 要么超时了，worker count-1 */ for (;;) &#123; int wc = workerCountOf(c); timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //allowCoreThreadTimeOut默认为false //如果allowCoreThreadTimeOut为true，说明corePoolSize和maximum都需要定时 //如果当前执行线程数&lt;maximumPoolSize，并且timedOut 和 timed 任一为false，跳出循环，开始从workQueue获取任务 if (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)) break; /** * 如果到了这一步，说明要么线程数量超过了maximumPoolSize（可能maximumPoolSize被修改了） * 要么既需要计时timed==true，也超时了timedOut==true * worker数量-1，减一执行一次就行了，然后返回null，在runWorker()中会有逻辑减少worker线程 * 如果本次减一失败，继续内层循环再次尝试减一 */ if (compareAndDecrementWorkerCount(c)) return null; //如果减数量失败，再次读取ctl c = ctl.get(); // Re-read ctl //如果线程池运行状态发生变化，继续外层循环 //如果状态没变，继续内层循环 if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; try &#123; //poll() - 使用 LockSupport.parkNanos(this, nanosTimeout) 挂起一段时间，interrupt()时不会抛异常，但会有中断响应 //take() - 使用 LockSupport.park(this) 挂起，interrupt()时不会抛异常，但会有中断响应 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : //大于corePoolSize workQueue.take(); //小于等于corePoolSize //如获取到了任务就返回 if (r != null) return r; //没有返回，说明超时，那么在下一次内层循环时会进入worker count减一的步骤 timedOut = true; &#125; /** * blockingQueue的take()阻塞使用LockSupport.park(this)进入wait状态的，对LockSupport.park(this)进行interrupt不会抛异常，但还是会有中断响应 * 但AQS的ConditionObject的await()对中断状态做了判断，会报告中断状态 reportInterruptAfterWait(interruptMode) * 就会上抛InterruptedException，在此处捕获，重新开始循环 * 如果是由于shutdown()等操作导致的空闲worker中断响应，在外层循环判断状态时，可能return null */ catch (InterruptedException retry) &#123; timedOut = false; //响应中断，重新开始，中断状态会被清除 &#125; &#125;&#125; getTask()执行流程：1、首先判断是否可以满足从workQueue中获取任务的条件，不满足return null A、线程池状态是否满足： （a）shutdown状态 + workQueue为空 或 stop状态，都不满足，因为被shutdown后还是要执行workQueue剩余的任务，但workQueue也为空，就可以退出了 （b）stop状态，shutdownNow()操作会使线程池进入stop，此时不接受新任务，中断正在执行的任务，workQueue中的任务也不执行了，故return null返回 B、线程数量是否超过maximumPoolSize 或 获取任务是否超时 （a）线程数量超过maximumPoolSize可能是线程池在运行时被调用了setMaximumPoolSize()被改变了大小，否则已经addWorker()成功不会超过maximumPoolSize （b）如果 当前线程数量&gt;corePoolSize，才会检查是否获取任务超时，这也体现了当线程数量达到maximumPoolSize后，如果一直没有新任务，会逐渐终止worker线程直到corePoolSize2、如果满足获取任务条件，根据是否需要定时获取调用不同方法： A、workQueue.poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，返回null B、workQueue.take()：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务3、在阻塞从workQueue中获取任务时，可以被interrupt()中断，代码中捕获了InterruptedException，重置timedOut为初始值false，再次执行第1步中的判断，满足就继续获取任务，不满足return null，会进入worker退出的流程 processWorkerExit() – worker线程退出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970** * Performs cleanup and bookkeeping for a dying worker. Called * only from worker threads. Unless completedAbruptly is set, * assumes that workerCount has already been adjusted to account * for exit. This method removes thread from worker set, and * possibly terminates the pool or replaces the worker if either * it exited due to user task exception or if fewer than * corePoolSize workers are running or queue is non-empty but * there are no workers. * * @param w the worker * @param completedAbruptly if the worker died due to user exception */private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; /** * 1、worker数量-1 * 如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1 * 如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了 */ if (completedAbruptly) // If abrupt, then workerCount wasn&#x27;t adjusted 代码和注释正好相反啊 decrementWorkerCount(); /** * 2、从Workers Set中移除worker */ final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks; //把worker的完成任务数加到线程池的完成任务数 workers.remove(w); //从HashSet&lt;Worker&gt;中移除 &#125; finally &#123; mainLock.unlock(); &#125; /** * 3、在对线程池有负效益的操作时，都需要“尝试终止”线程池 * 主要是判断线程池是否满足终止的状态 * 如果状态满足，但还有线程池还有线程，尝试对其发出中断响应，使其能进入退出流程 * 没有线程了，更新状态为tidying-&gt;terminated */ tryTerminate(); /** * 4、是否需要增加worker线程 * 线程池状态是running 或 shutdown * 如果当前线程是突然终止的，addWorker() * 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker() * 故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程 */ int c = ctl.get(); //如果状态是running、shutdown，即tryTerminate()没有成功终止线程池，尝试再添加一个worker if (runStateLessThan(c, STOP)) &#123; //不是突然完成的，即没有task任务可以获取而完成的，计算min，并根据当前worker数量判断是否需要addWorker() if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //allowCoreThreadTimeOut默认为false，即min默认为corePoolSize //如果min为0，即不需要维持核心线程数量，且workQueue不为空，至少保持一个线程 if (min == 0 &amp;&amp; ! workQueue.isEmpty()) min = 1; //如果线程数量大于最少数量，直接返回，否则下面至少要addWorker一个 if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; //添加一个没有firstTask的worker //只要worker是completedAbruptly突然终止的，或者线程数量小于要维护的数量，就新添一个worker线程，即使是shutdown状态 addWorker(null, false); &#125;&#125; processWorkerExit(Worker w, boolean completedAbruptly)参数： worker： 要结束的worker completedAbruptly： 是否突然完成（是否因为异常退出）执行流程：1、worker数量-1 A、如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1 B、如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了2、从Workers Set中移除worker，删除时需要上锁mainlock3、tryTerminate()：在对线程池有负效益的操作时，都需要“尝试终止”线程池，大概逻辑： 判断线程池是否满足终止的状态 A、如果状态满足，但还有线程池还有线程，尝试对其发出中断响应，使其能进入退出流程 B、没有线程了，更新状态为tidying-&gt;terminated4、是否需要增加worker线程，如果线程池还没有完全终止，仍需要保持一定数量的线程 线程池状态是running 或 shutdown A、如果当前线程是突然终止的，addWorker() B、如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker() 故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程 Android中的线程池Android中的线程池都是之间或间接通过配置ThreadPoolExecutor来实现不同特性的线程池.Android中最常见的四类具有不同特性的线程池分别为FixThreadPool、CachedThreadPool、SingleThreadPool、ScheduleThreadExecutor. FixThreadPool只有核心线程,并且数量固定的,也不会被回收,所有线程都活动时,因为队列没有限制大小,新任务会等待执行.优点:更快的响应外界请求. SingleThreadPool只有一个核心线程,确保所有的任务都在同一线程中按顺序完成.因此不需要处理线程同步的问题. CachedThreadPool只有非核心线程,最大线程数非常大,所有线程都活动时,会为新任务创建新线程,否则会利用空闲线程(60s空闲时间,过了就会被回收,所以线程池中有0个线程的可能)处理任务.优点:任何任务都会被立即执行(任务队列SynchronousQueue相当于一个空集合);比较适合执行大量的耗时较少的任务. ScheduledThreadPool核心线程数固定,非核心线程(闲着没活干会被立即回收)数没有限制.优点:执行定时任务以及有固定周期的重复任务 扩展：深度解读 java 线程池设计思想及源码实现","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"Android-binder-c++层","slug":"Android-binder-c++层","date":"2018-08-09T07:55:12.000Z","updated":"2018-11-05T14:12:55.919Z","comments":true,"path":"2018/08/09/Android-binder-c++层/","link":"","permalink":"http://example.com/2018/08/09/Android-binder-c++%E5%B1%82/","excerpt":"这里主要是native端的流程","text":"这里主要是native端的流程 主要涉及到的目录是 android / platform / frameworks / native / master / . / libs android / platform / frameworks / base / master / . / core / jniNative端 ServiceManager 启动过程 原本列了一大串，后来发现详细内容还不如直接看这个把。Binder系列3—启动ServiceManager 提炼出关键步骤就是 binder_open(driver, 128*1024) ,内部调用为 : 打开/dev/binder文件：bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);,这个方法会进入到binder驱动程序，保存线程上下文信息，生成多个红黑树，用于保存服务端binder实体信息，客户端binder引用信息等; 记下映射内存大小:bs-&gt;mapsize = mapsize; 建立128K内存映射:bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);,这个方法也会进入到binder驱动程序,使用进程虚拟地址空间和内核虚拟地址空间来映射同一个物理页面。这样，进程和内核之间就可以减少一次内存拷贝了，提到了进程间通信效率。举个例子如，Client要将一块内存数据传递给Server，一般的做法是，Client将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到Server的进程空间，这样，Server就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作，而采用我们上面提到的方法，只需要把Client进程空间的数据拷贝一次到内核空间，然后Server与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。 这里用到一个数据结构 binder_state 把它们存起来 123456struct binder_state&#123; int fd; //驱动的文件描述符 void *mapped; //映射内存的起始地址 unsigned mapsize; //映射内存的大小&#125;; 通知Binder驱动程序它是守护进程： 1234int binder_become_context_manager(struct binder_state *bs)&#123; return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);&#125; 这里通过调用ioctl文件操作函数来通知Binder驱动程序自己是守护进程，cmd是BINDER_SET_CONTEXT_MGR，没有参数。在驱动程序内部的调用为: 初始化binder_context_mgr_uid为current-&gt;cred-&gt;euid，binder_context_mgr_uid表示Service Manager守护进程的uid,这样使当前线程成为Binder机制的守护进程 通过binder_new_node()来创建binder实体,binder_context_mgr_node用来表示Service Manager的binder实体 进入循环等待请求的到来：binder_loop(bs, svcmgr_handler),并且使用 svcmgr_handler 函数来处理binder请求,没有请求时，在binder_ioctl()函数中通过wait_event_interruptible_exclusive()阻塞 Native端获取 ServiceManager 远程接口的过程Binder系列4—获取ServiceManager Service Manager在Binder机制中既充当守护进程的角色，同时它也充当着Server角色，然而它又与一般的Server不一样。 对于普通的Server来说，Client如果想要获得Server的远程接口，那么必须通过Service Manager远程接口提供的getService接口来获得，getService是一个使用Binder机制来进行进程间通信的过程(需要通过名字查询得到相应的Server端binder实体对应的binder引用句柄，用于生成BpBinder)； 而对于Service Manager这个Server来说，Client如果想要获得Service Manager远程接口，却不必通过进程间通信机制来获得，因为Service Manager远程接口是一个特殊的Binder引用，它的引用句柄一定是0。 获取Service Manager远程接口的函数是 123456789101112131415sp&lt;IServiceManager&gt; defaultServiceManager()&#123; if (gDefaultServiceManager != NULL) return gDefaultServiceManager; &#123; AutoMutex _l(gDefaultServiceManagerLock); if (gDefaultServiceManager == NULL) &#123; gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); &#125; &#125; return gDefaultServiceManager;&#125; 一个相关的类继承关系图:从图中可以看到： BpServiceManager类继承了BpInterface类，BpInterface是个模板类，又继承了IServiceManager和BpRefBase,它的构造函数需要一个IBinder类 123456789template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; IServiceManager类继承了IInterface类，而IInterface类和BpRefBase类又继承了RefBase类。在BpRefBase类中，有一个成员变量mRemote，它的类型是IBinder*，实现类为BpBinder，它表示一个Binder引用，引用句柄值保存在BpBinder类的mHandle成员变量中。因此IServiceManager也有mRemote的指针，可以和binder通信 创建Service Manager远程接口主要是下面语句,主要是三个步骤: 1gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL)); 首先是ProcessState::self(): 12345678sp&lt;ProcessState&gt; ProcessState::self()&#123; if (gProcess != NULL) return gProcess; AutoMutex _l(gProcessMutex); if (gProcess == NULL) gProcess = new ProcessState; return gProcess;&#125; 这里仅仅是创建一个单例，它的构造函数 123456789101112131415161718192021222324252627282930ProcessState::ProcessState(): mDriverFD(open_driver()), mVMStart(MAP_FAILED), mManagesContexts(false), mBinderContextCheckFunc(NULL), mBinderContextUserData(NULL), mThreadPoolStarted(false), mThreadPoolSeq(1)&#123; if (mDriverFD &gt;= 0) &#123; // XXX Ideally, there should be a specific define for whether we // have mmap (or whether we could possibly have the kernel module // availabla).#if !defined(HAVE_WIN32_IPC) // mmap the binder, providing a chunk of virtual address space to receive transactions. mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) &#123; // *sigh* LOGE(&quot;Using /dev/binder failed: unable to mmap transaction memory.\\n&quot;); close(mDriverFD); mDriverFD = -1; &#125;#else mDriverFD = -1;#endif &#125; if (mDriverFD &lt; 0) &#123; // Need to run without the driver, starting our own thread pool. &#125;&#125; 主要做了三件事： 调用open()，打开/dev/binder驱动设备； 再利用mmap()，创建大小为BINDER_VM_SIZE(1M-8K)的内存地址空间； 设定当前进程最大的最大并发Binder线程个数为16。 ProcessState::self()-&gt;getContextObject(NULL),这个函数的返回值，是一个句柄值为0的Binder引用，即BpBinder:new BpBinder(0) interface_cast&lt;IServiceManager&gt;()函数,这是一个模板函数，最终调用到了IServiceManager::asInterface(): 123456789101112131415161718template&lt;typename INTERFACE&gt;inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)&#123;return INTERFACE::asInterface(obj); &#125;android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj) &#123; android::sp&lt;IServiceManager&gt; intr; if (obj != NULL) &#123; intr = static_cast&lt;IServiceManager*&gt;( obj-&gt;queryLocalInterface(IServiceManager::descriptor).get()); if (intr == NULL) &#123; intr = new BpServiceManager(obj); &#125; ｝ return intr; &#125; 因此实际的过程为: 1gDefaultServiceManager = new BpServiceManager(new BpBinder(0)); 即获取的Service Manager远程接口，本质上是一个BpServiceManager，包含了一个句柄值为0的Binder引用，这个过程不涉及到跨进程调用 Native端普通 Service 的初始化，注册在上一节里面我们看到了 ServiceManager 的远程接口端的类图，实际上是一个BpServiceManager。这里我们以MediaPlayerService为例，看一下服务端的类图 可以看到，这个结构和Bp端很类似，不同的地方在于，MediaPlayerService继承于BnMediaPlayerService,而BnMediaPlayerService继承于BnInterface，BnInterface继承了BBinder接口， IBinder 的实现类则是BBinder其他部分则是类似的 12345678910template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const; protected: virtual IBinder* onAsBinder();&#125;; MediaPlayerService的启动过程： 123456789101112int main(int argc, char** argv)&#123; sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); LOGI(&quot;ServiceManager: %p&quot;, sm.get()); AudioFlinger::instantiate(); MediaPlayerService::instantiate(); CameraService::instantiate(); AudioPolicyService::instantiate(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool();&#125; 主要步骤是： sp&lt;ProcessState&gt; proc(ProcessState::self()); , 在上一节已经分析过这句过程。主要是打开binder设备和映射内存 sp&lt;IServiceManager&gt; sm = defaultServiceManager(),获取ServiceManager接口，上一节也已经分析过 MediaPlayerService::instantiate()： 1234void MediaPlayerService::instantiate() &#123;defaultServiceManager()-&gt;addService( String16(&quot;media.player&quot;), new MediaPlayerService());&#125; addService函数传入了两个参数，一个是服务的名字，一个是服务的实现类。这里首先看一下defaultServiceManager返回的BpServiceManager定义: 1234567891011121314151617181920212223242526272829class BpServiceManager : public BpInterface&lt;IServiceManager&gt;&#123;public: BpServiceManager(const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IServiceManager&gt;(impl) &#123; &#125; ...... virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service) &#123; Parcel data, reply; //IServiceManager::getInterfaceDescriptor()返回来的是一个字符串，即&quot;android.os.IServiceManager&quot;，写入一个字符串 data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); // name 即 &quot;media.player&quot;，写入一个字符串 data.writeString16(name); data.writeStrongBinder(service); status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); return err == NO_ERROR ? reply.readExceptionCode() &#125; ...... &#125;;status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123; return flatten_binder(ProcessState::self(), val, this);&#125; 这里 flatten_binder(ProcessState::self(), val, this)会把传入进来的 IBinder实现类service转成一个flat_binder_object对象，然后序列化到Parcel 里面 。 每一个Binder实体或者引用，都通过 flat_binder_object 来表示，成员变量里面 binder表示这是一个Binder实体，handle表示这是一个Binder引用，当这是一个Binder实体时，cookie才有意义，表示附加数据，由进程自己解释。： 1234567891011121314151617181920212223242526272829status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; proc,const sp&lt;IBinder&gt;&amp; binder, Parcel* out)&#123; flat_binder_object obj; obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS; if (binder != NULL) &#123; IBinder *local = binder-&gt;localBinder(); if (!local) &#123; BpBinder *proxy = binder-&gt;remoteBinder(); if (proxy == NULL) &#123; LOGE(&quot;null proxy&quot;); &#125; const int32_t handle = proxy ? proxy-&gt;handle() : 0; obj.type = BINDER_TYPE_HANDLE; obj.handle = handle; obj.cookie = NULL; &#125; else &#123; //此次会进入到这里，因为是BBinder，服务实体 obj.type = BINDER_TYPE_BINDER; obj.binder = local-&gt;getWeakRefs(); obj.cookie = local; &#125; &#125; else &#123; obj.type = BINDER_TYPE_BINDER; obj.binder = NULL; obj.cookie = NULL; &#125; return finish_flatten_binder(binder, obj, out); //序列化，把flat_binder_object写入out。&#125; writeStrongBinder的过程，在这里就是，把parcel data 转成 flat_binder_object ,然后写入到parcel out。 回到上面去，writeStrongBinder结束后，就开始调用status_t err = remote()-&gt;tra nsact(ADD_SERVICE_TRANSACTION, data, &amp;reply);, 因为这里是BpServiceManager，所以remote()成员函数来自于BpRefBase类，它返回一个BpBinder指针，也就是BpBinder(0)。后面是一连串的调用链： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// android / platform / frameworks / native / master / . / libs / binder / BpBinder.cppstatus_t BpBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; ... //IPCThreadState::self() 里面会初始化自己的成员变量mIn,mOut status_t status = IPCThreadState::self()-&gt;transact(mHandle, code, data, reply, flags); ...&#125;status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; flags |= TF_ACCEPT_FDS; . . . . . . // 把data数据整理进内部的mOut包中 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); . . . . . . if ((flags &amp; TF_ONE_WAY) == 0) &#123; . . . . . . if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; . . . . . . &#125; else &#123; //oneway，则不需要等待reply的场景 err = waitForResponse(NULL, NULL); &#125; return err;&#125;status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; //把数据封装成 binder_transaction_data binder_transaction_data tr; tr.target.handle = handle; // handle = 0 tr.code = code; // code = ADD_SERVICE_TRANSACTION tr.flags = binderFlags; // data为记录Media服务信息的Parcel对象 const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; .... mOut.writeInt32(cmd); //cmd = BC_TRANSACTION mOut.write(&amp;tr, sizeof(tr)); //写入 binder_transaction_data 数据 return NO_ERROR;&#125;//在waitForResponse过程, 首先回复之前的ADD_SERVICE信息，执行BR_TRANSACTION_COMPLETE；另外，在目标进程收到事务后，处理BR_TRANSACTION事务。 然后发送给当前进程，再执行BR_REPLY命令。status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; ... // talkWithDriver()内部会完成跨进程事务 if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... // 事务的回复信息被记录在mIn中，所以需要进一步分析这个 cmd = mIn.readInt32(); switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: if (!reply &amp;&amp; !acquireResult) goto finish; break; ...&#125;status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; //把mOut数据和mIn的数据处理后构造一个binder_write_read对象 binder_write_read bwr; bwr.write_size = outAvail; bwr.write_buffer = (long unsigned int)mOut.data(); // This is what we&#x27;ll read. if (doReceive &amp;&amp; needRead) &#123; //接收数据缓冲区信息的填充。如果以后收到数据，就直接填在mIn中了。 bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (long unsigned int)mIn.data(); &#125; else &#123; bwr.read_size = 0; &#125; ... do &#123; if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) // 这里设置收到的回复数据 if (bwr.read_consumed &gt; 0) &#123; mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; &#125; while (err == -EINTR); //当被中断，则继续执行 ...&#125; 短暂的总结一下流程: 这里开始是 binder驱动内容，其实只需要知道这个talkWithDriver()结果是 mIn 得到数据，waitForResponse()中reply-&gt;ipcSetDataReferenc()设置返回数据即可。///驱动这里我也好多没看懂。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294//内核驱动程序，static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct binder_proc *proc = filp-&gt;private_data; void __user *ubuf = (void __user *)arg; struct binder_write_read bwr; //这里已经是驱动内容了，将用户空间bwr结构体拷贝到内核空间 copy_from_user(&amp;bwr, ubuf, sizeof(bwr)); ... switch (cmd) &#123; case BINDER_WRITE_READ: &#123; ... if (bwr.write_size &gt; 0) &#123; //写数据 ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... &#125; if (bwr.read_size &gt; 0) &#123; //读取自己队列的数据 ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... &#125; ... break; &#125; //将内核空间bwr结构体拷贝到用户空间 copy_to_user(ubuf, &amp;bwr, sizeof(bwr)); ......&#125;binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,void __user *buffer, int size, signed long *consumed)&#123; ... uint32_t cmd; void __user *buffer = (void __user *)(uintptr_t)binder_buffer; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; //拷贝用户空间的cmd命令，此时为BC_TRANSACTION if (get_user(cmd, (uint32_t __user *)ptr)) -EFAULT; ptr += sizeof(uint32_t); switch (cmd) &#123; case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; //拷贝用户空间的binder_transaction_data，复制数据 if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; ... &#125; *consumed = ptr - buffer; &#125; return 0;&#125;//binder_transaction函数主要负责的工作：//新建binder_transaction对象，并插入到自己的binder_transaction堆栈中//新建binder_work对象，插入到目标进程的todo队列//Binder与Handle的转换 (flat_binder_object)static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread,struct binder_transaction_data *tr, int reply)&#123; ...... //根据handle找到node,这里handle是0，因此找到binder_context_mgr_node if (tr-&gt;target.handle) &#123; ...... &#125; else &#123; target_node = binder_context_mgr_node; &#125; if (target_thread) &#123; ... &#125; else &#123; //找到servicemanager进程的todo队列 target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; ...... t-&gt;sender_euid = task_euid(proc-&gt;tsk); t-&gt;to_proc = target_proc; //此次通信目标进程为servicemanager进程 t-&gt;to_thread = target_thread; t-&gt;code = tr-&gt;code; //此次通信code = ADD_SERVICE_TRANSACTION t-&gt;flags = tr-&gt;flags; // 此次通信flags = 0 t-&gt;priority = task_nice(current); ... //分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到内核 copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size); copy_from_user(offp, (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size); off_end = (void *)offp + tr-&gt;offsets_size; ... for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); off_min = *offp + sizeof(struct flat_binder_object); switch (fp-&gt;type) &#123; //注册服务的时候，传递的是 BBinder,type是BINDER_TYPE_BINDER case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct binder_ref *ref; struct binder_node *node = binder_get_node(proc, fp-&gt;binder); if (node == NULL) &#123; //请求所在进程(也就是这个MediaService进程)创建binder_node实体 node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); ... &#125; //目标进程(也就是ServiceManager进程)创建binder_ref ref = binder_get_ref_for_node(target_proc, node); ... //调整type为HANDLE类型 if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; fp-&gt;binder = 0; fp-&gt;handle = ref-&gt;desc; //设置handle值 fp-&gt;cookie = 0; ... &#125; ... &#125; &#125; //将BINDER_WORK_TRANSACTION添加到目标队列，本次通信的目标队列为target_proc-&gt;todo t-&gt;work.type = BINDER_WORK_TRANSACTION; list_add_tail(&amp;t-&gt;work.entry, target_list); //将BINDER_WORK_TRANSACTION_COMPLETE添加到请求线程的todo队列 tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); //唤醒等待队列，本次通信的目标队列为target_proc-&gt;wait if (target_wait) wake_up_interruptible(target_wait); return;&#125;// 第一次执行完这个函数后会返回到waitForResponse继续执行，由于当前线程的todo队列有任务了，进入binder_thread_read来处理相关的事务.接下来进入到第二次执行到这里的时候 MediaPlayerService 会休眠static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread,void __user *buffer, int size, signed long *consumed, int non_block)&#123; //当已使用字节数为0时，将BR_NOOP响应码放入指针ptr if (*consumed == 0) &#123; if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125; retry: //binder_transaction()已设置transaction_stack不为空，则wait_for_proc_work为false. wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING; if (wait_for_proc_work) proc-&gt;ready_threads++; //进程中空闲binder线程加1 //只有当前线程todo队列为空，并且transaction_stack也为空，才会开始处于当前进程的事务 if (wait_for_proc_work) &#123; if (non_block) &#123; ... &#125; else //当进程todo队列没有数据,则进入休眠等待状态 ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); &#125; else &#123; if (non_block) &#123; ... &#125; else //当线程todo队列有数据则执行往下执行；当线程todo队列没有数据，则进入休眠等待状态 ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread)); &#125; if (wait_for_proc_work) proc-&gt;ready_threads--; //退出等待状态, 则进程中空闲binder线程减1 thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING; ... while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; //先从线程todo队列获取事务数据 if (!list_empty(&amp;thread-&gt;todo)) &#123; w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); // 线程todo队列没有数据, 则从进程todo对获取事务数据 &#125; else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123; w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry); &#125; else &#123; //没有数据,则返回retry if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) goto retry; break; &#125; switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: //获取transaction数据 t = container_of(w, struct binder_transaction, work); break; case BINDER_WORK_TRANSACTION_COMPLETE: cmd = BR_TRANSACTION_COMPLETE; //将BR_TRANSACTION_COMPLETE写入*ptr，并跳出循环。 put_user(cmd, (uint32_t __user *)ptr)； list_del(&amp;w-&gt;entry); kfree(w); break; case BINDER_WORK_NODE: ... break; case BINDER_WORK_DEAD_BINDER: case BINDER_WORK_DEAD_BINDER_AND_CLEAR: case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: ... break; &#125; //只有BINDER_WORK_TRANSACTION命令才能继续往下执行 if (!t) continue; if (t-&gt;buffer-&gt;target_node) &#123; //获取目标node struct binder_node *target_node = t-&gt;buffer-&gt;target_node; tr.target.ptr = target_node-&gt;ptr; tr.cookie = target_node-&gt;cookie; //设置cookie t-&gt;saved_priority = task_nice(current); ... cmd = BR_TRANSACTION; //设置命令为BR_TRANSACTION &#125; else &#123; tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; //设置命令为BR_REPLY &#125; tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) &#123; struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; //当非oneway的情况下,将调用者进程的pid保存到sender_pid tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); &#125; else &#123; //当oneway的的情况下,则该值为0 tr.sender_pid = 0; &#125; tr.data_size = t-&gt;buffer-&gt;data_size; tr.offsets_size = t-&gt;buffer-&gt;offsets_size; tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); //将cmd和数据写回用户空间 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; t-&gt;to_parent = thread-&gt;transaction_stack; t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; &#125; else &#123; t-&gt;buffer-&gt;transaction = NULL; kfree(t); //通信完成,则运行释放 &#125; break; &#125; done: *consumed = ptr - buffer; //当满足请求线程加已准备线程数等于0，已启动线程数小于最大线程数(15)， //且looper状态为已注册或已进入时创建新的线程。 if (proc-&gt;requested_threads + proc-&gt;ready_threads == 0 &amp;&amp; proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp; (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED))) &#123; proc-&gt;requested_threads++; // 生成BR_SPAWN_LOOPER命令，用于创建新的线程 put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)； &#125; return 0; 这里到了服务进程了 ServiceManager在 `binder_loop`的`ioctl()`函数中由于`binder_thread_read()`的`wait_event_interruptible_exclusive()`而进入阻塞状态，在这里被驱动通过 wake_up_interruptible 唤醒了，： 123456789101112131415161718192021222324252627282930313233343536void binder_loop(struct binder_state *bs, binder_handler func)&#123; int res; struct binder_write_read bwr; unsigned readbuf[32]; bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(unsigned)); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); if (res &lt; 0) &#123; LOGE(&quot;binder_loop: ioctl failed (%s)\\n&quot;, strerror(errno)); break; &#125; res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); if (res == 0) &#123; LOGE(&quot;binder_loop: unexpected reply?!\\n&quot;); break; &#125; if (res &lt; 0) &#123; LOGE(&quot;binder_loop: io error %d %s\\n&quot;, res, strerror(errno)); break; &#125; &#125;&#125; 被唤醒后，会在binder_thread_read()中读取binder传过来的数据，赋值到本地局部变量struct binder_transaction_data tr中，接着把tr的内容拷贝到用户传进来的缓冲区 ，返回后再把binder_ioctl()中的本地变量struct binder_write_read bwr的内容拷贝回到用户传进来的缓冲区中，最后从binder_ioctl()函数返回(有任务就break跳出循环返回了)，接着执行binder_parse(): 12345678910111213141516171819202122232425262728293031323334int binder_parse(struct binder_state *bs, struct binder_io *bio, uint32_t *ptr, uint32_t size, binder_handler func)&#123; int r = 1; uintptr_t end = ptr + (uintptr_t) size; while (ptr &lt; end) &#123; uint32_t cmd = *(uint32_t *) ptr; ptr += sizeof(uint32_t); switch(cmd) &#123; case BR_TRANSACTION: &#123; struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr; ... binder_dump_txn(txn); if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); //从txn解析出binder_io信息 // 收到Binder事务 res = func(bs, txn, &amp;msg, &amp;reply); // 向binder驱动发送reply事件 binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); &#125; ptr += sizeof(*txn); break; &#125; case : ... &#125; return r;&#125; 这个函数传入的函数指针是svcmgr_handler，因此会进入到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int svcmgr_handler(struct binder_state *bs, struct binder_transaction_data *txn, struct binder_io *msg, struct binder_io *reply)&#123; struct svcinfo *si; uint16_t *s; unsigned len; void *ptr; uint32_t strict_policy; if (txn-&gt;target != svcmgr_handle) return -1; // Equivalent to Parcel::enforceInterface(), reading the RPC // header with the strict mode policy mask and the interface name. // Note that we ignore the strict_policy and don&#x27;t propagate it // further (since we do no outbound RPCs anyway). strict_policy = bio_get_uint32(msg); s = bio_get_string16(msg, &amp;len); // &quot;android.os.IServiceManager&quot; if ((len != (sizeof(svcmgr_id) / 2)) || memcmp(svcmgr_id, s, sizeof(svcmgr_id))) &#123; fprintf(stderr,&quot;invalid id %s\\n&quot;, str8(s)); return -1; &#125; switch(txn-&gt;code) &#123; ...... case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); // &quot;media.player&quot; ptr = bio_get_ref(msg); // new MediaPlayerService() if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid)) return -1; break; ...... &#125; bio_put_uint32(reply, 0); //reply返回0 return 0;//ServiceManager中的flat_binder_object被改为了BINDER_TYPE_HANDLE，句柄值写到一个struct svcinfo结构体中，//然后插入到链接svclist的头部去int do_add_service(struct binder_state *bs, uint16_t *s, unsigned len, void *ptr, unsigned uid)&#123; struct svcinfo *si;// LOGI(&quot;add_service(&#x27;%s&#x27;,%p) uid=%d\\n&quot;, str8(s), ptr, uid); if (!ptr || (len == 0) || (len &gt; 127)) return -1; if (!svc_can_register(uid, s)) &#123; LOGE(&quot;add_service(&#x27;%s&#x27;,%p) uid=%d - PERMISSION DENIED\\n&quot;, str8(s), ptr, uid); return -1; &#125; si = find_svc(s, len); //根据名字查找引用，这里是 &quot;media.player&quot; if (si) &#123; if (si-&gt;ptr) &#123; LOGE(&quot;add_service(&#x27;%s&#x27;,%p) uid=%d - ALREADY REGISTERED\\n&quot;, str8(s), ptr, uid); return -1; &#125; si-&gt;ptr = ptr; &#125; else &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); if (!si) &#123; LOGE(&quot;add_service(&#x27;%s&#x27;,%p) uid=%d - OUT OF MEMORY\\n&quot;, str8(s), ptr, uid); return -1; &#125; si-&gt;ptr = ptr; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = &#x27;\\0&#x27;; si-&gt;death.func = svcinfo_death; si-&gt;death.ptr = si; si-&gt;next = svclist; svclist = si; &#125; binder_acquire(bs, ptr); binder_link_to_death(bs, ptr, &amp;si-&gt;death); return 0;&#125; 最后，执行binder_send_reply()函数，再次进入到ioctl()函数中，把数据再次封装成一个事务，唤醒 MediaPlayerService去处理， 对于ServiceManager来说，到这里就结束了。IServiceManager::addService执行完毕. 数据流向： BBinder+name 序列化到 Parcel里， 然后加上 target= 0和code=ADD_SERVICE 转成 binder_transation_data 对象， 加上cmd = BC_TRANSACTION 写入到IPC_ThreadState的mOut 里面 mOut和mIn 构造一个 binder_write_read 对象， 发送给 binder 驱动 binder 驱动拷贝这个数据到内核，构造一个 binder_transaction_data 发送给服务进程的todo队列，同时向用户进程回复BR_COMPLETE(为什么要拷贝，之前传指针不是很方便吗？因为那里是客户进程，内核可以访问，但是服务进程访问不了，指针没法跨进程使用。) 服务进程构造 binder_transaction_data 和 BC_REPLY 回复给 binder 驱动 上面描述了 service_manager 的 binder_loop 循环，对于其他的服务来说，binder线程的启动是通过下面两句来启动的： 12ProcessState::self()-&gt;startThreadPool();IPCThreadState::self()-&gt;joinThreadPool(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void IPCThreadState::joinThreadPool(bool isMain) &#123; mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER); set_sched_policy(mMyThreadId, SP_FOREGROUND); status_t result; do &#123; processPendingDerefs(); //处理对象引用 result = getAndExecuteCommand();//获取并执行命令 if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) &#123; ALOGE(&quot;getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting&quot;, mProcess-&gt;mDriverFD, result); abort(); &#125; //对于binder非主线程不再使用，则退出 if(result == TIMED_OUT &amp;&amp; !isMain) &#123; break; &#125; &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF); mOut.writeInt32(BC_EXIT_LOOPER); talkWithDriver(false); &#125; status_t IPCThreadState::getAndExecuteCommand() &#123; status_t result; int32_t cmd; result = talkWithDriver(); //该Binder Driver进行交互 if (result &gt;= NO_ERROR) &#123; size_t IN = mIn.dataAvail(); if (IN &lt; sizeof(int32_t)) return result; cmd = mIn.readInt32(); //读取命令 pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock); mProcess-&gt;mExecutingThreadsCount++; pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock); result = executeCommand(cmd); pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock); mProcess-&gt;mExecutingThreadsCount--; pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement); pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock); set_sched_policy(mMyThreadId, SP_FOREGROUND); &#125; return result; &#125; 上文中的分析可以知道，talkWithDriver()会把数据封装成一个事务发送给服务端 ，服务端处理请求后会把数据封装成事务返回，talkWithDriver()则解析返回的事务得到数据并返回。因此这里返回数据后接着调用executeCommand() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111status_t IPCThreadState::executeCommand(int32_t cmd)&#123; BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch (cmd) &#123; ...... case BR_TRANSACTION: &#123; binder_transaction_data tr; result = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(result == NO_ERROR, &quot;Not enough command data for brTRANSACTION&quot;); if (result != NO_ERROR) break; //Record the fact that we&#x27;re in a binder call. mIPCThreadStateBase-&gt;pushCurrentState( IPCThreadStateBase::CallState::BINDER); Parcel buffer; buffer.ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); const pid_t origPid = mCallingPid; const uid_t origUid = mCallingUid; const int32_t origStrictModePolicy = mStrictModePolicy; const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags; mCallingPid = tr.sender_pid; mCallingUid = tr.sender_euid; mLastTransactionBinderFlags = tr.flags; //ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\\n&quot;, mCallingPid, mCallingUid); Parcel reply; status_t error; IF_LOG_TRANSACTIONS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;BR_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / obj &quot; &lt;&lt; tr.target.ptr &lt;&lt; &quot; / code &quot; &lt;&lt; TypeCode(tr.code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; buffer &lt;&lt; dedent &lt;&lt; endl &lt;&lt; &quot;Data addr = &quot; &lt;&lt; reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer) &lt;&lt; &quot;, offsets addr=&quot; &lt;&lt; reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl; &#125; if (tr.target.ptr) &#123; // We only have a weak reference on the target object, so we must first try to // safely acquire a strong reference before doing anything else with it. if (reinterpret_cast&lt;RefBase::weakref_type*&gt;( tr.target.ptr)-&gt;attemptIncStrong(this)) &#123; error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this); &#125; else &#123; error = UNKNOWN_TRANSACTION; &#125; &#125; else &#123; error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; mIPCThreadStateBase-&gt;popCurrentState(); //ALOGI(&quot;&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\\n&quot;, // mCallingPid, origPid, origUid); if ((tr.flags &amp; TF_ONE_WAY) == 0) &#123; LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid); if (error &lt; NO_ERROR) reply.setError(error); sendReply(reply, 0); &#125; else &#123; LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid); &#125; mCallingPid = origPid; mCallingUid = origUid; mStrictModePolicy = origStrictModePolicy; mLastTransactionBinderFlags = origTransactionBinderFlags; IF_LOG_TRANSACTIONS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;BC_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / obj &quot; &lt;&lt; tr.target.ptr &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl; &#125; &#125; break; ....... &#125; if (result != NO_ERROR) &#123; mLastError = result; &#125; return result;&#125;status_t BBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; data.setDataPosition(0); status_t err = NO_ERROR; switch (code) &#123; case PING_TRANSACTION: reply-&gt;writeInt32(pingBinder()); break; default: err = onTransact(code, data, reply, flags); break; &#125; if (reply != NULL) &#123; reply-&gt;setDataPosition(0); &#125; return err;&#125; 因为服务端继承了BBinder，因此这里实际上会调用服务端的onTransact()，也就是MediaPlayerService的onTransact()函数，执行相应的动作。这样子就从客户端跨进程调用到了服务端。 Native端 客户端获取服务端接口的过程：在上一节里面分析了BpServiceManager.addService(),这一节来看 getService(string) 12345678910111213141516171819202122232425262728class BpServiceManager : public BpInterface&lt;IServiceManager&gt;&#123; ...... virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const &#123; //如果服务没有准备好，就休眠1秒，循环5次，还没有获取到就返回null，避免ANR unsigned n; for (n = 0; n &lt; 5; n++)&#123; sp&lt;IBinder&gt; svc = checkService(name); if (svc != NULL) return svc; LOGI(&quot;Waiting for service %s...\\n&quot;, String8(name).string()); sleep(1); &#125; return NULL; &#125; virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const &#123; Parcel data, reply; data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply); return reply.readStrongBinder(); &#125; ......&#125;; 这里的调用链大部分都在上一节说过了。因此这里简单描述下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);status_t BpBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags);status_t IPCThreadState::transact(int32_t handle,uint32_t code, const Parcel&amp; data,Parcel* reply, uint32_t flags)status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)status_t IPCThreadState::talkWithDriver(bool doReceive)long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,void __user *buffer, int size, signed long *consumed)static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread,struct binder_transaction_data *tr, int reply)//唤醒 ServiceManagerwake_up_interruptible(target_wait);static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread,void __user *buffer, int size, signed long *consumed, int non_block)IPCThreadState::talkWithDriver::ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)//当前线程休眠，等待ServiceManager返回操作结果ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));//ServiceManager 被唤醒后static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread,void __user *buffer, int size, signed long *consumed, int non_block)//得到事务tt = container_of(w, struct binder_transaction, work);int binder_parse(struct binder_state *bs, struct binder_io *bio,uint32_t *ptr, uint32_t size, binder_handler func)void bio_init(struct binder_io *bio, void *data,uint32_t maxdata, uint32_t maxoffs)void bio_init_from_txn(struct binder_io *bio, struct binder_txn *txn)int svcmgr_handler(struct binder_state *bs,struct binder_txn *txn,struct binder_io *msg,struct binder_io *reply)void *do_find_service(struct binder_state *bs, uint16_t *s, unsigned len)struct svcinfo *find_svc(uint16_t *s16, unsigned len)void bio_put_ref(reply, ptr);void bio_put_ref(struct binder_io *bio, void *ptr)&#123; struct binder_object *obj; if (ptr) obj = bio_alloc_obj(bio); else obj = bio_alloc(bio, sizeof(*obj)); if (!obj) return; obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS; obj-&gt;type = BINDER_TYPE_HANDLE; obj-&gt;pointer = ptr; obj-&gt;cookie = 0;&#125;void binder_send_reply(struct binder_state *bs,struct binder_io *reply,void *buffer_to_free,int status)int binder_write(struct binder_state *bs, void *data, unsigned len)long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,void __user *buffer, int size, signed long *consumed)static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread,struct binder_transaction_data *tr, int reply)struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);//旧的句柄是ServiceManager进程里面的，这里需要给它一个新的句柄值返回给客户端进程用new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);//清理，休眠...//唤醒请求的客户端线程...static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) copy_to_user(ubuf, &amp;bwr, sizeof(bwr))reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),tr.data_size, reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(size_t),freeBuffer, this); //android / platform / frameworks / native / master / . / libs / binder / Parcel.cppstatus_t Parcel::readStrongBinder(sp&lt;IBinder&gt;* val) const&#123; status_t status = readNullableStrongBinder(val); if (status == OK &amp;&amp; !val-&gt;get()) &#123; status = UNEXPECTED_NULL; &#125; return status;&#125;//android / platform / frameworks / native / master / . / libs / binder / Parcel.cppstatus_t Parcel::readNullableStrongBinder(sp&lt;IBinder&gt;* val) const&#123; return unflatten_binder(ProcessState::self(), *this, val);&#125;//android / platform / frameworks / native / master / . / libs / binder / Parcel.cppstatus_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc, const Parcel&amp; in, sp&lt;IBinder&gt;* out)&#123; const flat_binder_object* flat = in.readObject(false); if (flat) &#123; switch (flat-&gt;hdr.type) &#123; case BINDER_TYPE_BINDER: *out = reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie); return finish_unflatten_binder(nullptr, *flat, in); case BINDER_TYPE_HANDLE: *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle); return finish_unflatten_binder( static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in); &#125; &#125; return BAD_TYPE;&#125;//根据句柄生成BpBinder()sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); handle_entry* e = lookupHandleLocked(handle); if (e != NULL) &#123; // We need to create a new BpBinder if there isn&#x27;t currently one, OR we // are unable to acquire a weak reference on this current one. See comment // in getWeakProxyForHandle() for more info about this. IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; b = new BpBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; // This little bit of nastyness is to allow us to add a primary // reference to the remote proxy when this team doesn&#x27;t have one // but another team is sending the handle to us. result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125;android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj) 最终得到一个BpMediaPlayerService对象 总结一下(c++部分) 获取 ServiceManager 远程接口的时候，不需要跨进程，因为ServiceManger的binder实体固定句柄为0，只需要new BpBinder(0) 就可以得到binder引用，拿到 BpServieManager 获取普通服务的远程接口的时候，需要跨进程调用，因为需要通过 BpServieManager 向ServiceManger请求，ServiceManager会返回名字对应的服务的Binder实体的句柄给驱动程序，驱动程序读出来后序列化后返回给客户端，客户端拿到以后就可以new BpBinder(handle)拿到普通服务的远程代理对象了。 调用 ServiceManager 的功能的时候(比如addservice，getService), ServiceManager 是在binder_loop函数中解析 驱动传过来的数据后，直接处理，然后返回数据给驱动程序。 而 调用普通服务的功能的时候，拿到 驱动传过来的数据后会调用到BBinder的虚函数去处理 IPCThreadState类借助ProcessState类来负责与Binder驱动程序交 需要注意的是，比如我们在addService中传入一个BBinder对象，会通过writeStrongBinder()序列化成一个flat_binder_object后传给驱动，而在getService()的时候,驱动返回的也是一个包含服务端句柄的 flat_binder_object对象，这个对象会被readStrongBinder()函数解析成一个BpBinder对象返回给调用方。 流程总结: 参考：《深入理解Android 卷1》《深入理解Android 卷3》Android进程间通信（IPC）机制Binder简要介绍和学习计划深入分析Android Binder 驱动红茶一杯话Binder深入理解Binder原理Parcel数据传输过程，简要分析Binder流程","categories":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}],"tags":[{"name":"binder","slug":"binder","permalink":"http://example.com/tags/binder/"}],"keywords":[{"name":"android_framework","slug":"android-framework","permalink":"http://example.com/categories/android-framework/"}]},{"title":"《java并发编程的艺术》outline","slug":"《java并发编程的艺术》outline","date":"2018-08-07T03:30:58.000Z","updated":"2018-08-20T14:18:20.904Z","comments":true,"path":"2018/08/07/《java并发编程的艺术》outline/","link":"","permalink":"http://example.com/2018/08/07/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8Boutline/","excerpt":"最近几天把618在京东买的《java并发编程的艺术》看完了，感觉挺不错的，很多东西都是第一次看到这么详细的内容，可以和《深入理解Java虚拟机(第2版)》配合看，推荐先看后面这一本","text":"最近几天把618在京东买的《java并发编程的艺术》看完了，感觉挺不错的，很多东西都是第一次看到这么详细的内容，可以和《深入理解Java虚拟机(第2版)》配合看，推荐先看后面这一本 Java并发编程的限制 上下文切换 死锁 资源限制 底层实现原理volatile 插入了汇编的lock指令，由处理器实现 synchronized 锁对象： 普通同步方法的锁是当前实例，静态同步方法的锁是当前类的class对象 jvm使用Monitor对象来实现锁，包括 monitorenter 和 monitorexit 指令 锁的升级和对比： 无锁状态 偏向锁：java对象头和栈帧简单记录线程id，对比确定线程锁状态 轻量级锁 重量级锁 原子操作的实现原理 处理器实现原子操作: 总线锁定 缓存锁定 Java实现原子操作: CAS，CAS的底层实现是处理器提供的指令 Java内存模型(这部分很多地方都有了)Java中，实例域，静态域和数组都存在堆内存中，堆内存在线程之间共享。局部变量不会共享，不存在内存可见性问题。 内存模型抽象图：线程，线程本地内存，主存 结构图 Java涉及的重排序： 编译器优化的重排序 指令级并行的重排序 内存系统的重排序：主要是内存的加载和存储的顺序 内存屏障： 123load&#x2F;store code load&#x2F;store 确保在执行code的前后，先读取主存中的最新值/存储最新值到主存 volatile内存语义： 可见性 ： 对于一个volatile变量的读，总是能看到任意线程堆这个volatile变量的最后的写入。通过插入内存屏障来实现，从结局上看是限制了指令的重排序。 写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主存 读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程将从主存中读取变量的值 原子性 ： 对于一个voloatile变量的读/写具有原子性，但是对于volatile++ 这种复合操作不保证原子性 CAS ： CAS操作同时具有volatile读和写的内存语义，这个是通过java底层代码获取的编译器的功能 final 变量的内存语义： 构造函数内对final域写入，和随后把这个对象的引用赋值给变量，这两个操作不能重排序 读一个包含final域的对象的引用，和随后初次读这个final域的值，这两个操作不能重排序 happens-before 的定义和规则: 双重检查锁使用volatile变量的原因: 为对象分配内存和引用与对象的初始化之间可能会有重排序，导致判断空值出错，加volatile来防止这种错误 Java并发基础终止线程： 中断操作 使用布尔变量 线程通信： volatile和synchronized关键字 wait/notify pipe 输入输出流 Thread.join() Java锁AQS ：同步队列器的原理和使用： 维护一个同步队列 独占式同步状态获取和释放 共享式同步状态获取和释放 重入锁的实现: 读写锁的实现： Condition接口： Java并发容器和框架 ConcurrentHashmap的实现: ConcurrtntLinkedQueue的实现: 7种阻塞队列： ， 阻塞队列的实现： 基于Condition的等待通知模式 Fork/Join 框架 原子操作类共有13个： 1AtomicXXX: Java并发工具类 CountDownLatch CyclicBarrier: 一个线程到达屏障时被阻塞，等最后一个线程到达才打开屏障，继续运行 Semaphore : Exchanger : 线程池Executor框架和 FutureTaskRunnable和Callable： FutureTask: 目前Future接口的唯一实现类，可用于异步任务的取消，获取返回值等","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"关于unicode,utf,gbk","slug":"关于unicode-utf-gbk","date":"2018-08-02T10:55:44.000Z","updated":"2018-08-20T14:18:20.935Z","comments":true,"path":"2018/08/02/关于unicode-utf-gbk/","link":"","permalink":"http://example.com/2018/08/02/%E5%85%B3%E4%BA%8Eunicode-utf-gbk/","excerpt":"Unicode与UCS的历史Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。它从0开始，为每个符号指定一个编号，这叫做”码点”（code point）。比如，码点0的符号就是null（表示所有二进制位都是0）。","text":"Unicode与UCS的历史Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。它从0开始，为每个符号指定一个编号，这叫做”码点”（code point）。比如，码点0的符号就是null（表示所有二进制位都是0）。 Unicode的另一个设计目标，对今天影响深远，那就是对所有字符都采用16位编码（即用一个大小不超过2的16次方的整数数字给每个字符编号，注意从这个意义上也可以看出，Unicode是一种编码字符集，而非字符集编码）。但到后来连Unicode的设计者也发现，16位编码仅有65536个码位，远远不能容纳世界上所有的字符，但当意识到这个问题的时候，Unicode大部分的规范已经制定完毕，也有相当程度的普及，完全推倒重来是不现实的。这成了一个遗留问题，也是代理对（surrogate pair）这种蹩脚解决方案的发端。 无独有偶，在1984年，喜欢以繁多的编号糊弄群众的国际标准化组织ISO也开始着手制定解决不同语言字符数量太大问题的解决方案，这一方案被称为Universal Character Set（UCS），正式的编号是ISO-10646（记得么，ASCII是ISO-646，不知这种安排是否是故意的）。UCS-2用两个字节编码，UCS-4用4个字节编码。还是ISO高瞻远瞩，一开始就确定了UCS是一个31位的编码字符集（即用一个大小不超过2的31次方的整数数字为每个字符编号），这回真的足以容纳古往今来所有国家，所有语言所包含的字符了。虽然后来他们意识到，2的31次方个码位又实在太多了…… 1991年，Unicode联盟与ISO的工作组终于开始讨论Unicode与UCS的合并问题。最终，两者统一了抽象字符集（即任何一个在Unicode中存在的字符，在UCS中也存在），且最靠前的65535个字符也统一了字符的编码。对于码空间，两者同意以一百一十万为限（即两者都认为虽然65536不够，但2的31次方又太大，一百一十万是个双方都可接受的码空间大小，也够用，当然，这里说的一百一十万只是个约数），Unicode将码空间扩展到了一百一十万，而UCS将永久性的不使用一百一十万以后的码位。也就是说，现在再讲Unicode只包含65536个字符是不对的。除了对已经定义的字符进行统一外，Unicode联盟与ISO工作组也同意今后任何的扩展工作两者均保持同步，因此虽然从历史的意义上讲Unicode与UCS不是一回事（甚至细节上说也不是一回事），但现在提起Unicode，指代两者均无不妥。 GBK早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。 GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。在这个编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。 从ASCII、GB2312到GBK，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK都属于双字节字符集 (DBCS)。 2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。从汉字字汇上说，GB18030在GB13000.1的20902个汉字的基础上增加了CJK扩展A的6582个汉字（Unicode码0x3400-0x4db5），一共收录了27484个汉字。 CJK就是中日韩的意思。Unicode为了节省码位，将中日韩三国语言中的文字统一编码。GB13000.1就是ISO/IEC 10646-1的中文版，相当于Unicode 1.1。 GB18030的编码采用单字节、双字节和4字节方案。其中单字节、双字节和GBK是完全兼容的。4字节编码的码位就是收录了CJK扩展A的6582个汉字。 例如：UCS的0x3400在GB18030中的编码应该是8139EF30，UCS的0x3401在GB18030中的编码应该是8139EF31。 Unicode转换格式（Uniform Transformation Format, UTF）UCS-4根据最高位为0的最高字节分成27=128个group。每个group再根据次高字节分为256个平面（plane）。每个平面根据第3个字节分为256行 （row），每行有256个码位（cell）。group 0的平面0被称作BMP（Basic Multilingual Plane），其余的称为辅助平面（缩写SMP）。如果UCS-4的前两个字节为全零，那么将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。每个平面有216=65536个码位。Unicode计划使用了17个平面，一共有17×65536=1114112个码位。在Unicode 5.0.0版本中，已定义的码位只有238605个，分布在平面0、平面1、平面2、平面14、平面15、平面16。 Unicode只规定了每个字符的码点，现在，码点的范围是 0 至 0x10FFFF，码点又通常记作 U+XXXX，当中 XXXX 为 16 进位数字。Unicode没有规定这个二进制代码应该如何存储，现时流行的 UTF 为 UTF-8、UTF-16 和 UTF-32。每种 UTF 会把一个码点储存为一至多个编码单元（code unit）。例如 UTF-8 的编码单元是 8 位的字节、UTF-16 为 16 位、UTF-32 为 32 位。除 UTF-32 外，UTF-8 和 UTF-16 都是可变长度编码。 至于为什么要用utf,如果直接以原始码点来传输，每一个字符都将是两个字节以上，这对于英文为主的互联网来说，是非常浪费的，因为英文字母仅仅需要一个字节表示。 utf-32最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做UTF-32。比如，码点0就用四个字节的0表示，码点597D就在前面加两个字节的0。 123U+0000 &#x3D; 0x0000 0000U+597D &#x3D; 0x0000 597D UTF-32的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。 utf-16UTF-16编码介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。 它的编码规则很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。 于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？ 在基本平面内，从U+D800到U+DFFF是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。对应这些字符至少需要20个二进制位。 为什么是20个二进制位？辅助平面 的最大码位是0x10FFFF，减去0x10000后，最大值是0xFFFFF，所以肯定可以用20个二进制位表示 UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小210），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 Unicode码点转成UTF-16的时候，首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。 1U+597D &#x3D; 0x597D 如果是辅助平面字符，Unicode 3.0版给出了转码公式。 123H &#x3D; Math.floor((c-0x10000) &#x2F; 0x400)+0xD800L &#x3D; (c - 0x10000) % 0x400 + 0xDC00 以字符为例，它是一个辅助平面字符，码点为U+1D306，将其转为UTF-16的计算过程如下。 123H &#x3D; Math.floor((0x1D306-0x10000)&#x2F;0x400)+0xD800 &#x3D; 0xD834L &#x3D; (0x1D306-0x10000) % 0x400+0xDC00 &#x3D; 0xDF06 所以，字符的UTF-16编码就是0xD834 0xDF06，长度为四个字节。 相应的，如果第一个码点是 U+D800 至 U+DBFF，我们便知道它的代码对的高代理项（high surrogate），之后应该伴随一个 U+DC00 至 U+DFFF 的低代理项（low surrogate）。然后，我们用下列公式把代理对 (H, L) 变换成真实的码点： 1codepoint &#x3D; 0x10000 + (H − 0xD800) × 0x400 + (L − 0xDC00) 举个例子，高音谱号字符 𝄞 → U+1D11E 不是 BMP 之内的字符。在 JSON 中可写成转义序列 \\uD834\\uDD1E，我们解析第一个 \\uD834 得到码点 U+D834，我们发现它是 U+D800 至 U+DBFF 内的码点，所以它是高代理项。然后我们解析下一个转义序列 \\uDD1E 得到码点 U+DD1E，它在 U+DC00 至 U+DFFF 之内，是合法的低代理项。我们计算其码点： 123456H &#x3D; 0xD834, L &#x3D; 0xDD1Ecodepoint &#x3D; 0x10000 + (H − 0xD800) × 0x400 + (L − 0xDC00) &#x3D; 0x10000 + (0xD834 - 0xD800) × 0x400 + (0xDD1E − 0xDC00) &#x3D; 0x10000 + 0x34 × 0x400 + 0x11E &#x3D; 0x10000 + 0xD000 + 0x11E &#x3D; 0x1D11E utf-8UTF-8 的编码单元是 8 位字节，每个码点编码成 1 至 4 个字节。它的编码方式很简单，按照码点的范围，把码点的二进位分拆成 1 至最多 4 个字节： 12345码点范围 码点位数 字节1 字节2 字节3 字节4U+0000 ~ U+007F 7 0xxxxxxx U+0080 ~ U+07FF 11 110xxxxx 10xxxxxx U+0800 ~ U+FFFF 16 1110xxxx 10xxxxxx 10xxxxxx U+10000 ~ U+10FFFF 21 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 这个编码方法的好处之一是，码点范围 U+0000 ~ U+007F 编码为一个字节，与 ASCII 编码兼容。这范围的 Unicode 码点也是和 ASCII 字符相同的。因此，一个 ASCII 文本也是一个 UTF-8 文本。 我们举一个例子解析多字节的情况，欧元符号 € → U+20AC： U+20AC 在 U+0800 ~ U+FFFF 的范围内，应编码成 3 个字节。 U+20AC 的二进位为 10000010101100 3 个字节的情况我们要 16 位的码点，所以在前面补两个 0，成为 0010000010101100 按上表把二进位分成 3 组：0010, 000010, 101100 加上每个字节的前缀：11100010, 10000010, 10101100 用十六进位表示即：0xE2, 0x82, 0xAC 最后，是一个例子 作者：uuspider链接：https://www.zhihu.com/question/23374078/answer/65352538 举一个例子：It’s 知乎日报 你看到的unicode字符集是这样的编码表： 123456789I 0049t 0074&#39; 0027s 0073 0020知 77e5乎 4e4e日 65e5报 62a5 每一个字符对应一个十六进制数字。计算机只懂二进制，因此，严格按照unicode的方式(UCS-2)，应该这样存储： 123456789I 00000000 01001001t 00000000 01110100&#39; 00000000 00100111s 00000000 01110011 00000000 00100000知 01110111 11100101乎 01001110 01001110日 01100101 11100101报 01100010 10100101 这个字符串总共占用了18个字节，但是对比中英文的二进制码，可以发现，英文前9位都是0！浪费啊，浪费硬盘，浪费流量。怎么办？UTF。UTF-8是这样做的： 单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同； n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。 这样就形成了如下的UTF-8标记位： 12345670xxxxxxx110xxxxx 10xxxxxx1110xxxx 10xxxxxx 10xxxxxx11110xxx 10xxxxxx 10xxxxxx 10xxxxxx111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx... ... 于是，”It’s 知乎日报“就变成了： 123456789I 01001001t 01110100&#39; 00100111s 01110011 00100000知 11100111 10011111 10100101乎 11100100 10111001 10001110日 11100110 10010111 10100101报 11100110 10001010 10100101 和上边的方案对比一下，英文短了，每个中文字符却多用了一个字节。但是整个字符串只用了17个字节，比上边的18个短了一点点。 参考资料: https://baike.baidu.com/item/UNICODE https://www.zhihu.com/question/23374078 http://www.ruanyifeng.com/blog/2014/12/unicode.html","categories":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}],"tags":[],"keywords":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}]},{"title":"RSA加解密算法原理","slug":"RSA加解密算法原理","date":"2018-07-29T17:10:13.000Z","updated":"2018-11-04T06:05:35.250Z","comments":true,"path":"2018/07/30/RSA加解密算法原理/","link":"","permalink":"http://example.com/2018/07/30/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/","excerpt":"原文链接已经失效了。所以这里重新发一遍RSA加密算法详解","text":"原文链接已经失效了。所以这里重新发一遍RSA加密算法详解 RSA ： 1976年以前，所有的加密方法都是同一种模式： （1）甲方选择某一种加密规则，对信息进行加密； （2）乙方使用同一种规则，对信息进行解密。由于加密和解密使用同样规则（简称”密钥”），这被称为”对称加密算法”（Symmetric-key algorithm）。这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。 1976年，两位美国计算机学家Whitfield Diffie 和 Martin、Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为”Diffie-Hellman密钥交换算法”。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。这种新的加密模式被称为”非对称加密算法”。 （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 （2）甲方获取乙方的公钥，然后用它对信息加密。 （3）乙方得到加密后的信息，用私钥解密。如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。下面，我就进入正题，解释RSA算法的原理。文章共分成两部分，今天是第一部分，介绍要用到的四个数学概念。你可以看到，RSA算法并不难，只需要一点数论知识就可以理解。 理论基础 这里介绍一点理论基础，都是比较简单的，小学的数学知识。看我细细道来~ 什么是“素数”？素数是这样的整数，它除了能表示为它自己和1的乘积以外，不能表示为任何其它两个整数的乘积。例如，15＝3＊5，所以15不是素数；又如，12＝6＊2＝4＊3，所以12也不是素数。另一方面，13除了等于13＊1以外，不能表示为其它任何两个整数的乘积，所以13是一个素数。素数也称为“质数”。 什么是“互质数”（或“互素数”）？小学数学教材对互质数是这样定义的：“公约数只有1的两个数，叫做互质数。”这里所说的“两个数”是指自然数。 判别方法主要有以下几种（不限于此）：（1）两个质数一定是互质数。例如，2与7、13与19。（2）一个质数如果不能整除另一个合数，这两个数为互质数。例如，3与10、5与 26。（3）1不是质数也不是合数，它和任何一个自然数在一起都是互质数。如1和9908。（4）相邻的两个自然数是互质数。如 15与 16。（5）相邻的两个奇数是互质数。如 49与 51。（6）大数是质数的两个数是互质数。如97与88。（7）小数是质数，大数不是小数的倍数的两个数是互质数。如 7和 16。（8）两个数都是合数（二数差又较大），小数所有的质因数，都不是大数的约数，这两个数是互质数。如357与715，357=3×7×17，而3、7和17都不是715的约数，这两个数为互质数。等等。 什么是模指数运算？指数运算谁都懂，不必说了，先说说模运算。模运算是整数运算，有一个整数m，以n为模做模运算，即m mod n。怎样做呢？让m去被n整除，只取所得的余数作为结果，就叫做模运算。例如，10 mod 3=1；26 mod 6=2；28 mod 2 =0等等。 模指数运算就是先做指数运算，取其结果再做模运算。如2^3 mod 5 = 3什么是同余式 表示同余关系的数学表达式，与等式相似。将等式中的等号“=”换成同余符号“≡”，必要时在式尾缀以(mod m) 注明模m（即除数），就是同余式。含有未知数的同余式叫做同余方程，通常要求整数解。如果两个正整数 a和 b之差能被 n整除，那么我们就说 a和 b对模n同余，记作：a ≡b (mod n) 什么是费马定理若p是素数，a与p互素，则a^(p-1）≡1 (mod p）什么是欧拉定理 欧拉函数φ(n)表示不大于n且与n互素的正整数的个数。当n是素数，φ(n)=n-1。n=pq,p,q均为素数时，则φ(n)= φ(p)φ(q)=(p-1)(q-1)。对于互素的a和n，有a^φ(n)≡1(mod n)什么是模反元素？ 如果两个正整数a和n互质，那么一定可以找到整数b，使得ab-1被n整除或者说ab被n除的余数是1。这时，b就叫做a的”模反元素”。比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。欧拉定理可以用来证明模反元素必然存在。密钥生成步骤 这里通过实例来说明。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？ 第一步，随机选择两个不相等的质数p和q。爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。） 第二步，计算p和q的乘积n。爱丽丝就把61和53相乘。 n = 61×53 = 3233n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。 第三步，计算n的欧拉函数φ(n)。根据公式： φ(n) = (p-1)(q-1)爱丽丝算出φ(3233)等于60×52，即3120。 第四步，随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。） 第五步，计算e对于φ(n)的模反元素d。所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。 ed ≡ 1 (mod φ(n))这个式子等价于 ed - 1 = kφ(n)于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。 ex + φ(n)y = 1已知 e=17, φ(n)=3120， 17x + 3120y = 1这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。至此所有计算完成。 第六步，将n和e封装成公钥，n和d封装成私钥。在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。实际应用中，公钥和私钥的数据都采用ASN.1格式表达。如下： 比如上面显示的这个公钥，那么怎么看出加密指数和模数呢？ 下面是我随便从IE里导出的一个证书的公钥 130 81 89 02 81 81 00 ee fa 1f c9 b0 43 df 7e 75 81 4e 31 71 91 0b fc 15 9d d9 4a 8a 51 f5 09 18 c6 7c c5 f1 27 c4 01 62 fc bf fc 84 29 a6 2f e6 1e 02 06 0b 96 89 d3 42 b1 73 9f 02 ae 75 62 09 3f 83 80 34 46 60 39 0a e3 21 4e e7 04 42 d5 7e 5e 98 45 27 5d 04 b9 27 32 c0 65 a4 94 85 13 25 db 16 f2 fb 51 c7 ff 28 62 d1 83 31 4f a9 a4 f4 c5 4f 9d 00 2e 14 3f 95 16 9c 4e 25 07 1b d5 7d 38 71 d8 40 f8 aa 71 02 03 01 00 01 在PKCS#1中的RSA的公钥的标准格式为 PKCS#1 :An RSA public key should be represented with the ASN.1 type RSAPublickey: 1234RSAPublickey ::&#x3D; SEQUENCE &#123; modulus INTEGER, -- n publicExponent INTEGER -- e&#125; 然后按照ASN的标准编码，所以说： 12345630 81 89 02 81 81 00 ee fa 1f c9 b0 43 df 7e 75 81 4e 31 71 91 0b fc 15 9d d9 4a 8a 51 f5 09 18 c6 7c c5 f1 27 c4 01 62 fc bf fc 84 29 a6 2f e6 1e 02 06 0b 96 89 d3 42 b1 73 9f 02 ae 75 62 09 3f 83 80 34 46 60 39 0a e3 21 4e e7 04 42 d5 7e 5e 98 45 27 5d 04 b9 27 32 c0 65 a4 94 85 13 25 db 16 f2 fb 51 c7 ff 28 62 d1 83 31 4f a9 a4 f4 c5 4f 9d 00 2e 14 3f 95 16 9c 4e 25 07 1b d5 7d 38 71 d8 40 f8 aa 71 02 03 01 00 01 0x30 0x81 0x89 是一个标识头，整个编码应该是： 12345602 81 81 00 ee fa 1f c9 b0 43 df 7e 75 81 4e 31 71 91 0b fc 15 9d d9 4a 8a 51 f5 09 18 c6 7c c5 f1 27 c4 01 62 fc bf fc 84 29 a6 2f e6 1e 02 06 0b 96 89 d3 42 b1 73 9f 02 ae 75 62 09 3f 83 80 34 46 60 39 0a e3 21 4e e7 04 42 d5 7e 5e 98 45 27 5d 04 b9 27 32 c0 65 a4 94 85 13 25 db 16 f2 fb 51 c7 ff 28 62 d1 83 31 4f a9 a4 f4 c5 4f 9d 00 2e 14 3f 95 16 9c 4e 25 07 1b d5 7d 38 71 d8 40 f8 aa 71 02 03 01 00 01 而 12345602 81 81 00 ee fa 1f c9 b0 43 df 7e 75 81 4e 31 71 91 0b fc 15 9d d9 4a 8a 51 f5 09 18 c6 7c c5 f1 27 c4 01 62 fc bf fc 84 29 a6 2f e6 1e 02 06 0b 96 89 d3 42 b1 73 9f 02 ae 75 62 09 3f 83 80 34 46 60 39 0a e3 21 4e e704 42 d5 7e 5e 98 45 27 5d 04 b9 27 32 c0 65 a4 94 85 13 25 db 16 f2 fb 51 c7 ff 28 62 d1 83 31 4f a9 a4 f4 c5 4f 9d 00 2e 14 3f 95 16 9c 4e 25 07 1b d5 7d 38 71 d8 40 f8 aa 71 是n的编码。 0x02 0x03 0x01 0x00 0x01是e的编码，不过你还是看不出来这什么整数，举个例子对于上面的0x02,0x03,0x01,0x00,0x01 其中0x02,0x03是e的编码的标识头e的表示是0x01,0x00,0x01，所以e就是0x01256^2+0x00256^1+1=65537 同理n就是 12345681 00 ee fa 1f c9 b0 43 df 7e 75 81 4e 31 71 91 0b fc 15 9d d9 4a 8a 51 f5 09 18 c6 7c c5 f1 27 c4 01 62 fc bf fc 84 29 a6 2f e6 1e 02 06 0b 96 89 d3 42 b1 73 9f 02 ae 75 62 09 3f 83 80 34 46 60 39 0a e3 21 4e e7 04 42 d5 7e 5e 98 45 27 5d 04 b9 27 32 c0 65 a4 94 85 13 25 db 16 f2 fb 51 c7 ff 28 62 d1 83 31 4f a9 a4 f4 c5 4f 9d 00 2e 14 3f 95 16 9c 4e 25 07 1b d5 7d 38 71 d8 40 f8 aa 71 02 03 01 00 01 注意，这个是一个整数的编码，也要像e,那样解码。RSA算法的可靠性 回顾上面的密钥生成步骤，一共出现六个数字： 123456 p q n φ(n) e d 这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。那么，有无可能在已知n和e的情况下，推导出d？ （1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 （2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 （3）n=pq。只有将n因数分解，才能算出p和q。结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道： “对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。 假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。 只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。”举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。 123456789 12301866845301177551304949 58384962720772853569595334 79219732245215172640050726 36575187452021997864693899 56474942774063845925192557 32630345373154826850791702 61221429134616704292143116 02221240479274737794080665 351419597459856902143413 它等于这样两个质数的乘积： 1234567891011 33478071698956898786044169 84821269081770479498371376 85689124313889828837938780 02287614711652531743087737 814467999489 × 36746043666799590428244633 79962795263227915816434308 76426760322838157396665112 79233373417143396810270092 798736308917 事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。加密和解密 有了公钥和密钥，就能进行加密和解密了。（1）加密要用公钥 (n,e)假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。所谓”加密”，就是算出下式的c： me ≡ c (mod n) 爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式： 6517 ≡ 2790 (mod 3233) 于是，c等于2790，鲍勃就把2790发给了爱丽丝。（2）解密要用私钥(n,d)爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立： cd ≡ m (mod n) 也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出 27902753 ≡ 65 (mod 3233) 因此，爱丽丝知道了鲍勃加密前的原文就是65。至此，”加密–解密”的整个过程全部完成。我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。 私钥解密的证明 最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子： c^d ≡ m (mod n) 因为，根据加密规则 m^e ≡ c (mod n) 于是，c可以写成下面的形式： c = m^e - kn 将c代入要我们要证明的那个解密规则： (m^e - kn)^d ≡ m (mod n) 它等同于求证 m^ed ≡ m (mod n) 由于 ed ≡ 1 (mod φ(n)) 所以 ed = hφ(n)+1 将ed代入： m^(hφ(n)+1) ≡ m (mod n) 接下来，分成两种情况证明上面这个式子。（1）m与n互质。根据欧拉定理，此时 m^φ(n) ≡ 1 (mod n) 得到 (m^φ(n))^h × m ≡ m (mod n) 原式得到证明。 （2）m与n不是互质关系。此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立： (kp)^q-1 ≡ 1 (mod q) 进一步得到 [(kp)^q-1]^h(p-1) × kp ≡ kp (mod q) 即 (kp)^ed ≡ kp (mod q) 将它改写成下面的等式 (kp)^ed = tq + kp 这时t必然能被p整除，即 t=t’p (kp)^ed = t&#39;pq + kp 因为 m=kp，n=pq，所以 m^ed ≡ m (mod n) 原式得到证明。 RSA缺陷 当p和q是一个大素数的时候，从它们的积pq去分解因子p和q，这是一个公认的数学难题。比如当pq大到1024位时，迄今为止还没有人能够利用任何计算工具去完成分解因子的任务。因此，RSA从提出到现在已近二十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。 然而，虽然RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难度与大数分解难度等价。即RSA的重大缺陷是无法从理论上把握它的保密性能如何。 此外，RSA的缺点还有： A)产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。 B)分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。因此，使用RSA只能加密少量数据，大量的数据加密还要靠对称密码算法。","categories":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"}],"keywords":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}]},{"title":"python中的RSA相关用法","slug":"python中的RSA相关用法","date":"2018-07-23T18:03:20.000Z","updated":"2018-11-04T06:05:31.656Z","comments":true,"path":"2018/07/24/python中的RSA相关用法/","link":"","permalink":"http://example.com/2018/07/24/python%E4%B8%AD%E7%9A%84RSA%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/","excerpt":"工作需要，用到了RSA算法，因为是python+flask搭建的服务器，所以也需要使用RSA相关的功能，但是网上搜了一圈，大都是在说 rsa 和 pycryptodome 这两个库。主要问题在于，我拿到的是string格式的公匙，而不是.pem文件，卡在了生产public key这个阶段。。","text":"工作需要，用到了RSA算法，因为是python+flask搭建的服务器，所以也需要使用RSA相关的功能，但是网上搜了一圈，大都是在说 rsa 和 pycryptodome 这两个库。主要问题在于，我拿到的是string格式的公匙，而不是.pem文件，卡在了生产public key这个阶段。。 虽然 RSA原理 大致看了一遍，但是实际使用的时候还涉及到key的生成和解析，加解密数据的填充等等，实际的使用中需要客户端和服务器统一RSA加密所用的填充方式。 RSA加密常用的填充方式有下面3种： 1.RSA_PKCS1_PADDING 填充模式，最常用的模式 在BouncyCastle实现RSA的PKCS1V1.5模式中，如果是公钥加密信息（forEncryption=true)，密钥长度为1024位，那么输出的密文块长度为128个字节，输入的明文块长度为127-10,即输入的明文块最大是117位，如果输入的明文块小于117位，比如输入的明文块长度为64位，那么会对这个明文块进行补位，在明文块前添加一位的0x02字节（代表公钥加密）然后后面的52位为随机的字节，在补位的最后一位，{即52（117-64-1），从零开始的},添加一位的字节0x00,在补位的后面添加实际的明文块。 这样做的目的就是使得明文块转化成与module差不多的大整数。 如果是私钥加密（forPrivateKey=true),密钥长度为1024位，那么输出 的密文块长度也是128字节，输入的明文块的长度为127-10，即输入的明文块最大是117位，如果输入的明文块小于117位，比如输入的明文块长度为64位，那么对这个明文块进行补位，在明文块前添加一位的0x01字节（代表私钥加密），然后在后面的52位为字节0xff，在最后一位｛即52（117-64-1）,从零开始)，添加一位的字节0x00，在补位的后面添加时间的明文块。 根据这个要求，对于512bit的密钥， block length = 512/8 – 11 = 53 字节 2.RSA_PKCS1_OAEP_PADDING 输入：RSA_size(rsa) – 41 输出：和modulus一样长 3.for RSA_NO_PADDING 不填充 输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割， 然后填充 输出：和modulus一样长 跟DES，AES一样， RSA也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。 但跟AES等不同的是， block length是跟key length有关的。 每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是key length。 需要注意： 假如你选择的秘钥长度为1024bit共128个byte： 1.当你在客户端选择RSA_NO_PADDING填充模式时，如果你的明文不够128字节 加密的时候会在你的明文前面，前向的填充零。解密后的明文也会包括前面填充的零，这是服务器需要注意把解密后的字段前向填充的 零去掉，才是真正之前加密的明文。 2.当你选择RSA_PKCS1_PADDING填充模式时，如果你的明文不够128字节 加密的时候会在你的明文中随机填充一些数据，所以会导致对同样的明文每次加密后的结果都不一样。 对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。 3.RSA_PKCS1_OAEP_PADDING填充模式没有使用过， 他是PKCS#1推出的新的填充方式，安全性是最高的， 和前面RSA_PKCS1_PADDING的区别就是加密前的编码方式不一样。 回到string类型公匙的问题上来。虽然加密密匙有多种格式，比如jar包里面的校验文件，中间还有什么乱七八糟的RSA PKCS#1,PKCS#8,X.509之类的东西与这里说的内容无关，暂时忽略掉。但我们在RSA里面通常遇到的公匙通常有两种类型，一种是.pem的文件，另外一种是纯string类型的公匙。大致的看过文档之后(官方文档的代码也有错误跑不起来，非常误导….), pycryptodome 和 rsa 库的getting started文档并没有很明确的说明， pem文件类型的公匙的两种格式： 123456789-----BEGIN RSA PUBLIC KEY-----MIIBCgKCAQEAhU9EQ3z&#x2F;zNCH+68tTN6Vkhnq8jaCx+9iT+zfq6rmwGzdNcErkt8xgqD5iuuQmpnFtF0fM3aKyCdztbYcJcscggceg9Wf14Nu5xitWsG47Mpd4M13RIGX0p5lMuE2zI4x5YCUSsTLV9vNtRK73tnUq8HYcHrRCK+RmylRcXvyIDjpVcGbwT37MebFuufCGqo0rYfZl7bb4kDMgKk5gULGBDxc5tz7YktMXQ0FOa7g9WXsxIWmoy0qOUMZVyHY+55b8vGUT2EevqrpusrnUJvwYRTtTiHHU+ftSV3VwY+1g38CWTk148LgUL0pIrnVxjPKUbUuoHA+YNbLL&#x2F;BLpJr7jwIDAQAB-----END RSA PUBLIC KEY----- 上面是一种类型的pem文件公匙的内容(这里可以叫做 标准pem 格式)，到具体的库来说，就是rsa库所产出的公匙： 12345678910import rsa(pubkey, privkey) = rsa.newkeys(2048)# 保存密钥with open(&#x27;public.pem&#x27;,&#x27;w+&#x27;) as f: f.write(pubkey.save_pkcs1().decode())with open(&#x27;private.pem&#x27;,&#x27;w+&#x27;) as f: f.write(privkey.save_pkcs1().decode()) 而crypto库产生的.pem文件格式为:(这里可以叫做 openssl 格式) 123456789-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA59JFc2huRupfSvTmI96eVuAWRAIziNG&#x2F;sTm0Z+XvWqWFMk4s9WIAu9Pi1d1VKhhwJoUSZKdFvMtKxQ2nACOUu01ykiqKmxYpU2jgKrKdAuM4R9hMnp5eqN7ql1zg5PA&#x2F;cF07AM0nG&#x2F;Z2y6XZUSz8mnAv7F0ePf0Ba1CmUAk2r+VwxA2rvpR0HM87T2Qq8b3ZieUuCyp0bxtQmHcbSAEVALHSucFxPVHKQ7b&#x2F;cjp5Teh4yWJnyhAOU8rphFY0fGehQpWsKTWTZFlxm+TEcH7c9mlFu290z0DE4xzYHv7kKWhConqJAphcNAExm7j&#x2F;qhvQF27DT90tj0oWtjz&#x2F;tCNjGQIDAQAB-----END PUBLIC KEY----- 产生的方法则是: 1234567891011121314from Crypto.Random import get_random_bytesimport base64from Crypto.Signature import pkcs1_15from Crypto.Hash import SHA256,SHA1from Crypto.PublicKey import RSAkey = RSA.generate(2048)private_key = key.export_key()file_out = open(&quot;private.pem&quot;, &quot;wb&quot;)file_out.write(private_key)public_key = key.publickey().export_key()file_out = open(&quot;public.pem&quot;, &quot;wb&quot;)file_out.write(public_key) 不过这两种pem格式，都是同一种构成规则，就是 123前缀行对DER格式的公匙进行base64后的结果后缀行 DER格式的公匙： DER格式的公匙，通常是byte字节流。我们所遇到的string类型的公匙，就是对这种字节流进行base64之后得到的字符串。而 openssl 格式 和 标准pem 格式 内容中所包含的 DER字节流，在没有前缀来区分的情况下，我们很难知道它是 openssl 格式 还是 标准pem 格式 中的那一段DER，而不同的类型，要用不同的处理方法来解析，这也是库方法解不出public key的最主要的原因之一。 DER格式1: 123456MIIBCgKCAQEAhU9EQ3z&#x2F;zNCH+68tTN6Vkhnq8jaCx+9iT+zfq6rmwGzdNcErkt8xgqD5iuuQmpnFtF0fM3aKyCdztbYcJcscggceg9Wf14Nu5xitWsG47Mpd4M13RIGX0p5lMuE2zI4x5YCUSsTLV9vNtRK73tnUq8HYcHrRCK+RmylRcXvyIDjpVcGbwT37MebFuufCGqo0rYfZl7bb4kDMgKk5gULGBDxc5tz7YktMXQ0FOa7g9WXsxIWmoy0qOUMZVyHY+55b8vGUT2EevqrpusrnUJvwYRTtTiHHU+ftSV3VwY+1g38CWTk148LgUL0pIrnVxjPKUbUuoHA+YNbLL&#x2F;BLpJr7jwIDAQAB DER格式2： 1234567MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA59JFc2huRupfSvTmI96eVuAWRAIziNG&#x2F;sTm0Z+XvWqWFMk4s9WIAu9Pi1d1VKhhwJoUSZKdFvMtKxQ2nACOUu01ykiqKmxYpU2jgKrKdAuM4R9hMnp5eqN7ql1zg5PA&#x2F;cF07AM0nG&#x2F;Z2y6XZUSz8mnAv7F0ePf0Ba1CmUAk2r+VwxA2rvpR0HM87T2Qq8b3ZieUuCyp0bxtQmHcbSAEVALHSucFxPVHKQ7b&#x2F;cjp5Teh4yWJnyhAOU8rphFY0fGehQpWsKTWTZFlxm+TEcH7c9mlFu290z0DE4xzYHv7kKWhConqJAphcNAExm7j&#x2F;qhvQF27DT90tj0oWtjz&#x2F;tCNjGQIDAQAB 最后给出完整代码: rsa库的可以根据解密过程自己写公钥解密的方法。而crypto库在解密的过程中也用到了pqn等参数，不太清楚为什么。所以就没有写出公钥解密的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227import requestsfrom Crypto.Random import get_random_bytesimport base64from Crypto.Signature import pkcs1_15from Crypto.Hash import SHA256, SHA1from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPimport rsasignature = &#x27;n6KsB/rBh3DzRjWVuocnzqyPm6jxyLp31kF80PewabKKsgfO8OaYtWjdwBOLld0E9Ynx0MiH81KYfGrBZv6Ef+gtl55Kkkfezol3UheNtmOhYE+LprI78blh55SeYnixEmd439tLCfQNuvftDYSDkEnlMXZ6Emz8X0J1AnfhUHU=&#x27;rsa_key_str = &#x27;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDnI3kW16XWPxx2y8vJwX58/3gNqpe3sgxIBjwhY8HKAbrZOHffcpkPYPO2uZZZSchIUd05E7x3daRbD6dmMVjbYzrs7U9L0m+5l8yKvNdVa9wMG3iWG/4a/e6V8tCDXuTx0i14MZoRYWmZBKwuWDkZCBtd1hq4xiU4fvMRfOg9wIDAQAB&#x27;message = &#x27;encryp_data=Lziso+i0rAjZSZMh/OfdVkACvSVLLUHZVkiLkqOEMGOWPuXCw65y1jr8Az5rC1H0NxkWtPKlSTMHxBM8dSnP1cbOqfdgHSiL5nVZq8k9yXvcShh4OfwZACvikDjDRsQo9nL+G4MjB7q34N5H/8pBZeN4cg9DuCg7ycXF0YG5V+w=&amp;extends_info_data=当前是最强的游戏扩展数据&amp;game_area=当前是最强的游戏区服&amp;game_level=49&amp;game_orderid=X7123456789&amp;game_role_id=x7id&amp;game_role_name=我是最强的角色名称&amp;sdk_version=2.0&amp;subject=大元宝&amp;xiao7_goid=18634202&#x27;encryp_data = &#x27;Lziso+i0rAjZSZMh/OfdVkACvSVLLUHZVkiLkqOEMGOWPuXCw65y1jr8Az5rC1H0NxkWtPKlSTMHxBM8dSnP1cbOqfdgHSiL5nVZq8k9yXvcShh4OfwZACvikDjDRsQo9nL+G4MjB7q34N5H/8pBZeN4cg9DuCg7ycXF0YG5V+w=&#x27;rsa_public_key = &#x27;&#x27;&#x27;-----BEGIN RSA PUBLIC KEY-----MIIBCgKCAQEAhU9EQ3z/zNCH+68tTN6Vkhnq8jaCx+9iT+zfq6rmwGzdNcErkt8xgqD5iuuQmpnFtF0fM3aKyCdztbYcJcscggceg9Wf14Nu5xitWsG47Mpd4M13RIGX0p5lMuE2zI4x5YCUSsTLV9vNtRK73tnUq8HYcHrRCK+RmylRcXvyIDjpVcGbwT37MebFuufCGqo0rYfZl7bb4kDMgKk5gULGBDxc5tz7YktMXQ0FOa7g9WXsxIWmoy0qOUMZVyHY+55b8vGUT2EevqrpusrnUJvwYRTtTiHHU+ftSV3VwY+1g38CWTk148LgUL0pIrnVxjPKUbUuoHA+YNbLL/BLpJr7jwIDAQAB-----END RSA PUBLIC KEY-----&#x27;&#x27;&#x27;rsa_public_key_str = &#x27;MIIBCgKCAQEAhU9EQ3z/zNCH+68tTN6Vkhnq8jaCx+9iT+zfq6rmwGzdNcErkt8xgqD5iuuQmpnFtF0fM3aKyCdztbYcJcscggceg9Wf14Nu5xitWsG47Mpd4M13RIGX0p5lMuE2zI4x5YCUSsTLV9vNtRK73tnUq8HYcHrRCK+RmylRcXvyIDjpVcGbwT37MebFuufCGqo0rYfZl7bb4kDMgKk5gULGBDxc5tz7YktMXQ0FOa7g9WXsxIWmoy0qOUMZVyHY+55b8vGUT2EevqrpusrnUJvwYRTtTiHHU+ftSV3VwY+1g38CWTk148LgUL0pIrnVxjPKUbUuoHA+YNbLL/BLpJr7jwIDAQAB&#x27;crypto_public_key = &#x27;&#x27;&#x27;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA59JFc2huRupfSvTmI96eVuAWRAIziNG/sTm0Z+XvWqWFMk4s9WIAu9Pi1d1VKhhwJoUSZKdFvMtKxQ2nACOUu01ykiqKmxYpU2jgKrKdAuM4R9hMnp5eqN7ql1zg5PA/cF07AM0nG/Z2y6XZUSz8mnAv7F0ePf0Ba1CmUAk2r+VwxA2rvpR0HM87T2Qq8b3ZieUuCyp0bxtQmHcbSAEVALHSucFxPVHKQ7b/cjp5Teh4yWJnyhAOU8rphFY0fGehQpWsKTWTZFlxm+TEcH7c9mlFu290z0DE4xzYHv7kKWhConqJAphcNAExm7j/qhvQF27DT90tj0oWtjz/tCNjGQIDAQAB-----END PUBLIC KEY-----&#x27;&#x27;&#x27;crypto_public_key_str = &#x27;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA59JFc2huRupfSvTmI96eVuAWRAIziNG/sTm0Z+XvWqWFMk4s9WIAu9Pi1d1VKhhwJoUSZKdFvMtKxQ2nACOUu01ykiqKmxYpU2jgKrKdAuM4R9hMnp5eqN7ql1zg5PA/cF07AM0nG/Z2y6XZUSz8mnAv7F0ePf0Ba1CmUAk2r+VwxA2rvpR0HM87T2Qq8b3ZieUuCyp0bxtQmHcbSAEVALHSucFxPVHKQ7b/cjp5Teh4yWJnyhAOU8rphFY0fGehQpWsKTWTZFlxm+TEcH7c9mlFu290z0DE4xzYHv7kKWhConqJAphcNAExm7j/qhvQF27DT90tj0oWtjz/tCNjGQIDAQAB&#x27;def crypto_generate_keys(): key = RSA.generate(2048) private_key = key.export_key() file_out = open(&quot;private.pem&quot;, &quot;wb&quot;) file_out.write(private_key) public_key = key.publickey().export_key() file_out = open(&quot;public.pem&quot;, &quot;wb&quot;) file_out.write(public_key)def rsa_generate_keys(): (pubkey, privkey) = rsa.newkeys(2048) with open(&#x27;public2.pem&#x27;, &#x27;w+&#x27;) as f: f.write(pubkey.save_pkcs1().decode()) with open(&#x27;private2.pem&#x27;, &#x27;w+&#x27;) as f: f.write(privkey.save_pkcs1().decode())def rsa_get_pubkey(pub_string): try: pubkey = rsa.PublicKey.load_pkcs1(pub_string) print(pubkey) except: print(&#x27;1 failed&#x27;) try: pubkey = rsa.PublicKey.load_pkcs1(pub_string, format=&#x27;DER&#x27;) print(pubkey) except: print(&#x27;2 failed&#x27;) try: pubkey = rsa.PublicKey.load_pkcs1_openssl_der(pub_string) print(pubkey) except: print(&#x27;3 failed&#x27;) try: pubkey = rsa.PublicKey.load_pkcs1_openssl_pem(pub_string) print(pubkey) except: print(&#x27;4 failed&#x27;) try: pubkey = rsa.PublicKey.load_pkcs1( base64.b64decode(pub_string), format=&#x27;DER&#x27;) print(pubkey) except: print(&#x27;5 failed&#x27;) try: pubkey = rsa.PublicKey.load_pkcs1_openssl_der( base64.b64decode(pub_string)) print(pubkey) except: print(&#x27;6 failed&#x27;) if pubkey: print(&#x27;rsa_get_pubkey success&#x27;) return pubkeydef crypto_get_pubkey(pub_string): try: pubkey = RSA.import_key(pub_string) print(pubkey.n) print(pubkey.e) except: print(&#x27;1 failed&#x27;) try: pubkey = RSA.import_key(base64.b64decode(pub_string)) print(pubkey.n) print(pubkey.e) except: print(&#x27;2 failed&#x27;) if pubkey: print(&#x27;crypto_get_pubkey success&#x27;) return pubkeydef crypto_sign_verify(pubkey_str,message_str,signature_str): &#x27;&#x27;&#x27; 如果signature是从外部获得的string格式，则需要base64解码一下。否则签名的时候直接用即可 &#x27;&#x27;&#x27; # prikey = RSA.import_key(open(&#x27;private.pem&#x27;).read()) # missing_padding = 4 - len(message) % 4 # if missing_padding: # message += &#x27;=&#x27;* missing_padding # h = SHA.new(message.encode()) # signature = pkcs1_15.new(prikey).sign(h) pubkey = crypto_get_pubkey(pubkey_str) h = SHA1.new(message_str.encode()) try: pkcs1_15.new(pubkey).verify(h, base64.b64decode(signature_str)) print(&quot;The signature is valid.&quot;) except (ValueError, TypeError): print(&quot;The signature is not valid.&quot;)def rsa_sign_verify(pubkey_str,message_str,signature_str): &#x27;&#x27;&#x27; 如果signature是从外部获得的string格式，则需要base64解码一下。否则签名的时候直接用即可 &#x27;&#x27;&#x27; # (pubkey, privkey) = rsa.newkeys(512) # message = &#x27;Go left at the blue tree&#x27; # signature = rsa.sign(message.encode(), privkey, &#x27;SHA-1&#x27;) # message = &#x27;Go right at the blue tree&#x27; pubkey = rsa_get_pubkey(pubkey_str) result = rsa.verify(message_str.encode(), base64.b64decode(signature_str), pubkey) print(result)def rsa_encrypt_decrypt(): (bob_pub, bob_priv) = rsa.newkeys(512) message = &#x27;hello Bob!&#x27;.encode() crypto = rsa.encrypt(message, bob_pub) print(base64.b64encode(crypto).decode()) message = rsa.decrypt(crypto, bob_priv) print(message.decode())def get_max_out_len(key_n): &#x27;&#x27;&#x27; 根据key的长度获取可以一次解密输出的密文数据的长度 密文数据的长度-11 就是一次解密的明文数据的最大长度 &#x27;&#x27;&#x27; bits = 0 while key_n &gt;&gt; bits: bits += 1 r, q = divmod(bits, 8) if q != 0: r += 1 return rdef get_max_input_len(key_n): return get_max_out_len(key_n)def crypto_decrypt_with_public(): # crypto 不允许公钥解密，算法有点看不懂，所以也不太会改 pubkey = crypto_get_pubkey(rsa_key_str) cipher_rsa_decrypt = PKCS1_OAEP.new(pubkey) if len(base64.b64decode(encryp_data)) &lt;= get_max_out_len(pubkey.n): data = cipher_rsa_decrypt.decrypt(base64.b64decode(encryp_data)) else: print(&#x27;需要分段解密&#x27;) pass print(data)def decrypt_with_public_key(crypto, pub_key): blocksize = rsa.common.byte_size(pub_key.n) encrypted = rsa.transform.bytes2int(crypto) # blind_r = rsa.randnum.randint(pub_key.n - 1) # blinded = (encrypted * pow(blind_r, pub_key.e, pub_key.n)) % pub_key.n # decrypted = rsa.core.decrypt_int(blinded, pub_key.e, pub_key.n) decrypted = rsa.core.decrypt_int(encrypted, pub_key.e, pub_key.n) cleartext = rsa.transform.int2bytes(decrypted, blocksize) # If we can&#x27;t find the cleartext marker, decryption failed. if cleartext[0:2] != b&#x27;\\x00\\x01&#x27;: #这里表示是私钥加密，公钥加密这里是\\x02 raise Exception(&#x27;Decryption failed,the message is not encrypted by private key&#x27;) # Find the 00 separator between the padding and the message try: sep_idx = cleartext.index(b&#x27;\\x00&#x27;, 2) #寻找填充数据的最后一个byte except ValueError: raise Exception(&#x27;Decryption failed,cannot find end of padding space&#x27;) return cleartext[sep_idx + 1:]def rsa_decrypt_with_public(): pubkey = rsa_get_pubkey(rsa_key_str) if len(base64.b64decode(encryp_data)) &lt;= get_max_out_len(pubkey.n): decrypt = decrypt_with_public_key(base64.b64decode(encryp_data), pubkey) decrypt_dict = &#123;&#125; for pair_str in decrypt.decode().split(&#x27;&amp;&#x27;): (key, value) = pair_str.split(&#x27;=&#x27;) decrypt_dict[key] = value else: print(&#x27;需要分段解密&#x27;) passif __name__ == &#x27;__main__&#x27;: processes = [rsa_public_key,rsa_public_key_str,crypto_public_key,crypto_public_key_str] for process in processes: pubkey = rsa_get_pubkey(process) pubkey = crypto_get_pubkey(process) rsa_decrypt_with_public() 最后的总结： pycryptodome 不支持公钥解密 rsa 支持公钥解密 两者都支持公钥加密私钥解密，验证签名等","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}]},{"title":"python flask 设置","slug":"python-flask-设置","date":"2018-07-20T08:07:36.000Z","updated":"2018-08-20T14:18:20.904Z","comments":true,"path":"2018/07/20/python-flask-设置/","link":"","permalink":"http://example.com/2018/07/20/python-flask-%E8%AE%BE%E7%BD%AE/","excerpt":"几个月之前刚学python后看完了狗书，照着上面写完了flask的项目，然后在公司内部写了个后台网站，主要是数据库的操作和调用外部工具.然后就没管了。现在接入sdk的时候需要一个游戏服务器，只好自己搭一个来测试。发现flask相关的东西又忘光了。。。","text":"几个月之前刚学python后看完了狗书，照着上面写完了flask的项目，然后在公司内部写了个后台网站，主要是数据库的操作和调用外部工具.然后就没管了。现在接入sdk的时候需要一个游戏服务器，只好自己搭一个来测试。发现flask相关的东西又忘光了。。。 环境 ：python 3.6 ,vscode 首先是建立虚拟目录 : python -m venv venv windows下，编写一个bat : start venv\\scripts\\activate.bat ，双击bat启动虚拟环境 linux下，terminal中执行 source venv/bin/activate 启动虚拟环境 进入虚拟环境，pip install flask 新建python文件，输入 12345678910111213# -*- coding:utf-8 -*-from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def hello_world(): return &#x27;Hello Flask!&#x27;if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=5000,debug=True) 在vscode中ctrl+p, 输入&gt;python ,选择调试器，选择venv,这时候flask应该不会报错了 虚拟环境中直接运行python文件","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[],"keywords":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}]},{"title":"RxJava学习记录1","slug":"RxJava学习记录1","date":"2017-12-11T05:50:48.000Z","updated":"2018-11-05T14:46:23.288Z","comments":true,"path":"2017/12/11/RxJava学习记录1/","link":"","permalink":"http://example.com/2017/12/11/RxJava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/","excerpt":"之前就已经听说过这个了，一直没有引入到项目中去，然后看过就忘了，所以现在准备重新捡起来。 首先是gradle设置 12implementation &#39;io.reactivex.rxjava2:rxjava:2.1.0&#39;implementation &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39; 然后是","text":"之前就已经听说过这个了，一直没有引入到项目中去，然后看过就忘了，所以现在准备重新捡起来。 首先是gradle设置 12implementation &#39;io.reactivex.rxjava2:rxjava:2.1.0&#39;implementation &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39; 然后是 基本操作1234567891011121314151617181920212223242526272829303132Observable&lt;String&gt; observable &#x3D; Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(&quot;123&quot;); e.onNext(&quot;456&quot;); e.onComplete(); &#125;&#125;);Observer&lt;String&gt; observer &#x3D; new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.i(TAG, &quot;onSubscribe: &quot;); &#125; @Override public void onNext(String s) &#123; Log.i(TAG, &quot;onNext: &quot; + s); &#125; @Override public void onError(Throwable e) &#123; Log.i(TAG, &quot;onError: &quot;); &#125; @Override public void onComplete() &#123; Log.i(TAG, &quot;onComplete: &quot;); &#125;&#125;;observable.subscribe(observer); 这里面涉及到的东西也就两个，一个是创建被观察者，重写subscribe ，在里面写一些自定义的动作，里面的参数是发给观察者的。然后是创建观察者，被观察者调用订阅方法拿到观察者的引用，之后会按照被观察者的流程调用相应的方法输出是 123412-11 06:52:14.454 3517-3517&#x2F;com.example.alan.rxpractice I&#x2F;Activity1: onSubscribe: 12-11 06:52:14.454 3517-3517&#x2F;com.example.alan.rxpractice I&#x2F;Activity1: onNext: 12312-11 06:52:14.454 3517-3517&#x2F;com.example.alan.rxpractice I&#x2F;Activity1: onNext: 45612-11 06:52:14.454 3517-3517&#x2F;com.example.alan.rxpractice I&#x2F;Activity1: onComplete: ObservableObservable的其他几种创建方法： 使用Observable.just()创建被观察者1Observable&lt;String&gt; just &#x3D; Observable.just(&quot;123&quot;, &quot;456&quot;); 使用Observable.from()创建被观察者12String [] words &#x3D; &#123;&quot;123&quot;, &quot;456&quot;&#125;;Observable observable3 &#x3D; Observable.from(words); 或者1234List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();list.add(&quot;123&quot;);list.add(&quot;456&quot;);Observable observable4 &#x3D; Observable.from(list); 效果相同 线程控制 —— Scheduler在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 * subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 * observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 操作符分类按照官方(http://reactivex.io/)的分类，操作符大致分为以下几种： Creating Observables(Observable的创建操作符)，比如：Observable.create()、Observable.just()、Observable.from()等等； Transforming Observables(Observable的转换操作符)，比如：observable.map()、observable.flatMap()、 observable.buffer()等等； Filtering Observables(Observable的过滤操作符)，比如：observable.filter()、observable.sample()、observable.take()等等； Combining Observables(Observable的组合操作符)，比如：observable.join()、observable.merge()、observable.combineLatest()等等； Error Handling Operators(Observable的错误处理操作符)，比如:observable.onErrorResumeNext()、observable.retry()等等； Observable Utility Operators(Observable的功能性操作符)，比如：observable.subscribeOn()、observable.observeOn()、observable.delay()等等； Conditional and Boolean Operators(Observable的条件操作符)，比如：observable.amb()、observable.contains()、observable.skipUntil()等等； Mathematical and Aggregate Operators(Observable数学运算及聚合操作符)，比如：observable.count()、observable.reduce()、observable.concat()等等； 其他如observable.toList()、observable.connect()、observable.publish()等等； 感谢：给Android开发者的RxJava详解感谢：RxJava 与 Retrofit 结合的最佳实践感谢：RxJava使用介绍（二） RxJava的操作符","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"求最长连续1的长度","slug":"求最长连续1的长度","date":"2017-12-10T11:18:23.000Z","updated":"2018-10-23T02:16:51.123Z","comments":true,"path":"2017/12/10/求最长连续1的长度/","link":"","permalink":"http://example.com/2017/12/10/%E6%B1%82%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD1%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"题目: 由0和1组成的数组[0,1,1,0,0,1,1,1]，求最长连续1的长度","text":"题目: 由0和1组成的数组[0,1,1,0,0,1,1,1]，求最长连续1的长度 周一去笔试的题目， 我在纸上写的代码就直接连续扫描了一遍数组，记录最长连续1的数量，最后输出。 面试的时候，面试官问我，你这个时间复杂度是On，有没有不用On的解法。 今天晚上洗头发无聊乱想忽然想起来这个问题，仔细想了想，二分查找快的原理是因为数组本身是有序的，这样的数组本身就包含了一些信息，查找的时候利用了这些信息，每次查找直接去掉一半的错误答案，因此能够达到Olgn的速度。那么，在这个问题里面，包含的信息是什么？01100111 ,似乎什么也没包含，可能有位运算，01标记？什么玩意儿。。突然想到，信息在”最长”这两个字里面，最长，意味着少的就不用扫描了。 因此可以想到这样一个算法，如果我们目前发现的最长连续1的数量是6，那么我们再遇到1的时候，直接跳6位查是不是1，如果不是1，说明这段数字不可能超过6(因为末尾不是1，最多连续5个1)，如果是1的话，那么有可能是6个1，那么依次从5，4，3位倒着查，遇到不是1直接跳出，然后重复这个过程。 这样子的话，最后算出来应该是最坏情况On，不过平均情况应该要比On好。当时就在想怎么到Olgn，想错了方向. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class MaxLength &#123; public static void main(String[] args) &#123; int length = 20; int[] data = new int[length]; Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; data[i] = random.nextInt(2); &#125; getMaxSuccessiveLength1(data); getMaxSuccessiveLength2(data); &#125; private static int getMaxSuccessiveLength2(int[] numbers) &#123; int result = 0; int successiveLength = 0; //连续1的个数 int accessTime = 0; //从数组读取的次数 for (int i = 0; i &lt; numbers.length; ) &#123; accessTime++; if (numbers[i] == 0) &#123; result = (result &gt; successiveLength) ? result : successiveLength; successiveLength = 0; i += 1; &#125; else &#123; successiveLength++; if (shouldJump(successiveLength)) &#123; result = (result &gt; successiveLength) ? result : successiveLength; int jumpDistance = result; if (i + jumpDistance &gt; numbers.length - 1) &#123; jumpDistance = numbers.length - 1 - i; &#125; if (jumpDistance == 0) &#123; break; &#125; i += jumpDistance; for (int j = i; j &gt; i - jumpDistance; j--) &#123; if (numbers[j] == 0) &#123; i = j + 1; successiveLength = 0; accessTime++; break; &#125; else &#123; accessTime++; if (j == i - result + 1) &#123; successiveLength += jumpDistance; // 这一段是连续的1 result = (result &gt; successiveLength) ? result : successiveLength; i++; &#125; &#125; &#125; &#125; else &#123; i++; result = (result &gt; successiveLength) ? result : successiveLength; &#125; &#125; &#125; System.out.println(&quot;getMaxSuccessiveLength2 = &quot; + result + &quot;,accessTime = &quot; + accessTime); return result; &#125; /** * 遇到第一个1，应该向后跳 * * @param successiveLength * @return */ private static boolean shouldJump(int successiveLength) &#123; return successiveLength == 1; &#125; private static int getMaxSuccessiveLength1(int[] numbers) &#123; int result = 0; int successLength = 0; int accessTime = 0; for (int i = 0; i &lt; numbers.length; i++) &#123; if (numbers[i] == 0) &#123; result = (result &gt; successLength) ? result : successLength; successLength = 0; &#125; else &#123; successLength++; &#125; accessTime++; if (i == numbers.length - 1) &#123; result = (result &gt; successLength) ? result : successLength; &#125; &#125; System.out.println(&quot;getMaxSuccessiveLength1 = &quot; + result + &quot;,accessTime = &quot; + accessTime); return result; &#125; public static void print(int[] data) &#123; for (int i = 0; i &lt; data.length; i++) &#123; System.out.print(data[i] + &quot;,&quot;); &#125; System.out.println(); &#125;&#125; 这个结果是和最大连续长度有关的，最大连续长度越大，跳过的位就可能越多，但速度还是On吧","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"protocol buffer的序列化过程","slug":"protocol-buffer的序列化过程","date":"2017-12-06T12:14:18.000Z","updated":"2018-10-17T01:38:28.023Z","comments":true,"path":"2017/12/06/protocol-buffer的序列化过程/","link":"","permalink":"http://example.com/2017/12/06/protocol-buffer%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B/","excerpt":"网上看到一篇很详细的文章，因为涉及到很多图片，所以直接发地址把","text":"网上看到一篇很详细的文章，因为涉及到很多图片，所以直接发地址把 文章 protocol buffer序列化过的对象，最终转成二进制流，它的形式是T-L-V的格式， 1. Tag 定义：经过 Protocol Buffer采用Varint &amp; Zigzag编码后 的消息字段 标识号 &amp; 数据类型 的值 作用：标识 字段 存储了字段的标识号（field_number）和 数据类型（wire_type），即Tag = 字段数据类型（wire_type） + 标识号（field_number） 占用 一个字节 的长度（如果标识号超过了16，则占用多一个字节的位置） 解包时，Protocol Buffer根据 Tag 将 Value 对应于消息中的 字段 具体使用 1234567891011121314151617181920// Tag 的具体表达式如下 Tag = (field_number &lt;&lt; 3) | wire_type// 参数说明：// field_number：对应于 .proto文件中消息字段的标识号，表示这是消息里的第几个字段// field_number &lt;&lt; 3：表示 field_number = 将 Tag的二进制表示 右移三位 后的值 // field_num左移3位不会导致数据丢失，因为表示范围还是足够大地去表示消息里的字段数目// wire_type：表示 字段 的数据类型// wire_type = Tag的二进制表示 的最低三位值// wire_type的取值 enum WireType &#123; WIRETYPE_VARINT = 0, WIRETYPE_FIXED64 = 1, WIRETYPE_LENGTH_DELIMITED = 2, WIRETYPE_START_GROUP = 3, WIRETYPE_END_GROUP = 4, WIRETYPE_FIXED32 = 5 &#125;;// 从上面可以看出，`wire_type`最多占用 3位 的内存空间（因为 3位 足以表示 0-5 的二进制）//其中，3，4已经弃用，对于0，1，5类型，L位可以省略掉，也就是只需要T-V表示即可，对于2类型，才需要TLV表示 实例说明 123456789101112&#x2F;&#x2F; 消息对象 message person &#123; required int32 id &#x3D; 1; &#x2F;&#x2F; wire type &#x3D; 0，field_number &#x3D;1 required string name &#x3D; 2; &#x2F;&#x2F; wire type &#x3D; 2，field_number &#x3D;2 &#125;&#x2F;&#x2F; 如果一个Tag的二进制 &#x3D; 0001 0010标识号 &#x3D; field_number &#x3D; field_number &lt;&lt; 3 &#x3D;右移3位 &#x3D; 0000 0010 &#x3D; 2数据类型 &#x3D; wire_type &#x3D; 最低三位表示 &#x3D; 010 &#x3D; 2 2. Value经过 Protocol Buffer采用Varint &amp; Zigzag编码后 的消息字段的值 实例说明下面通过一个实例进行整个编码过程的说明： 消息说明 123456789101112131415message Test&#123;required int32 id1 &#x3D; 1；required int32 id2 &#x3D; 2；&#125;&#x2F;&#x2F; 在代码中给id1 附上1个字段值：296&#x2F;&#x2F; 在代码中给id2 附上1个字段值：296Test.setId1（300）；Test.setId2（296）；&#x2F;&#x2F; 编码结果为：二进制字节流 &#x3D; [8，-84，2，16, -88, 2]&#x2F;&#x2F;8和16是编码后的tag的值，其余字节表示value编码后的值 对于String类型，value则直接是其UTF8的字节表示，L则是其长度 对于嵌套类型，则表示有可能是TL-TLV-TLV 还有一种情况，则是packed修饰的 repeat 字段，可以存储为TL-VVVVV的形式 比较核心和有意思的则是它编码的方法,从效果来看很像huffman coding，思想都是把高频的数据进行压缩，比如 低于256的int值，我们不需要4字节去存储，可以去掉高位的三字节0位，压缩为1字节去存储 Varint编码: 123456789101112131415161718private void writeVarint32(int n) &#123; int idx = 0; while (true) &#123; if ((n &amp; ~0x7F) == 0) &#123; //n &amp; ~0x7F表示和1000 0000相与，判断条件则表示最高位是否为1，即最后七位 //或者不足七bit位的时候，直接赋值n,表示头部补0，并且退出循环 i32buf[idx++] = (byte)n; break; &#125; else &#123; // 取出字节串末7位然后高位补1，存到buf里面取 i32buf[idx++] = (byte)((n &amp; 0x7F) | 0x80); //将n字节串整体往右移7位，继续从字节串的末尾选取7位，高位补1存入，直到取完为止。 n &gt;&gt;&gt;= 7; &#125; &#125; trans_.write(i32buf, 0, idx); //将上述形成的每个字节 按序拼接 成一个字节串 即该字节串就是经过Varint编码后的字节&#125; 采用Varint编码，对于高位为0，不足4字节的正数，值越小编码后生成的byte值就越小，但对于负数，由于计算机里面有符号数负数表示为高位1，那么采用Varint编码的时候，则会把4byte的数据转成5byte，因此在数据中有负数的时候，需要先用 Zigzag编码转一下 Zigzag编码方式详解i. 简介 定义：一种变长的编码方式 原理：使用 无符号数 来表示 有符号数字； 作用：使得绝对值小的数字都可以采用较少 字节 来表示； ​ 特别是对 表示负数的数据 能更好地进行数据压缩 b. 原理 源码分析 12345678910111213141516171819202122public int int_to_zigzag(int n)&#123; return (n &lt;&lt;1) ^ (n &gt;&gt;31); &#x2F;&#x2F; 对于sint 32 数据类型，使用Zigzag编码过程如下： &#x2F;&#x2F; 1. 将二进制表示数 左移1位（左移 &#x3D; 整个二进制左移，低位补0） &#x2F;&#x2F; 2. 将二进制表示数 右移31位 &#x2F;&#x2F; 对于右移： &#x2F;&#x2F; 首位是1的二进制（有符号数），是算数右移，即右移后左边补1 &#x2F;&#x2F; 首位是0的二进制（无符号数），是逻辑左移，即右移后左边补0 &#x2F;&#x2F; 3. 将上述二者进行异或 &#x2F;&#x2F; 对于sint 64 数据类型 则为： return (n &lt;&lt; 1&gt; ^ (n &gt;&gt; 63) ；&#125;&#x2F;&#x2F; 附：将Zigzag值解码为整型值public int zigzag_to_int(int n) &#123; return(n &gt;&gt;&gt; 1) ^ -(n &amp; 1);&#x2F;&#x2F; 右移时，需要用不带符号的移动，否则如果第一位数据位是1的话，就会补1&#125; 比如-2，2表示为0000 0010，-2则是1111 1110，按照公式，-2左移一位，得到1111 1100，-2右移31位，得到1111 1111，两者异或，得到0000 0011，十进制是3，这样子，-2就转成了3 对比于XML 的序列化 &amp; 反序列化过程XML的反序列化过程如下： 从文件中读取出字符串 将字符串转换为 XML 文档对象结构模型 从 XML 文档对象结构模型中读取指定节点的字符串 将该字符串转换成指定类型的变量 上述过程非常复杂，其中，将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。 因为序列化 &amp; 反序列化过程简单，所以序列化 &amp; 反序列化过程速度非常快，这也是 Protocol Buffer效率高的原因 总结 Protocol Buffer的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：a. 编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）b. 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成 Protocol Buffer的数据压缩效果好（即序列化后的数据量体积小）的原因是：a. 采用了独特的编码方式，如Varint、Zigzag编码方式等等b. 采用T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑","categories":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}],"tags":[],"keywords":[{"name":"通用","slug":"通用","permalink":"http://example.com/categories/%E9%80%9A%E7%94%A8/"}]},{"title":"Android-DiskLruCache","slug":"Android-DiskLruCache","date":"2017-12-06T01:05:11.000Z","updated":"2018-11-05T14:13:32.121Z","comments":true,"path":"2017/12/06/Android-DiskLruCache/","link":"","permalink":"http://example.com/2017/12/06/Android-DiskLruCache/","excerpt":"DiskLruCache是用来在磁盘上缓存文件的类，","text":"DiskLruCache是用来在磁盘上缓存文件的类，在网上看到说的都是谷歌写的，不过我找到的DiskLruCache目前都是jakewharton的库，但里面的注释都是Android Open Source Project，不是很清楚这之间的原因。 一个是独立的库，文件流的操作采用Java IO , 通过 1api &#39;com.jakewharton:disklrucache:2.0.2&#39; 使用，另外一个是okhttp里面的，文件流操作采用ok.io，两者都是类似的。 一次写入操作的代码是 1234567891011121314151617181920212223242526272829 /** * 在这段代码里面，需要关注的， * 一是Editor是什么；在DiskLruCache里面，Editor是用来对Entry进行操作的类，而Entry又是对缓存文件 * 的封装，包括cleanFile和dirtyFile，我们每次拿imageUrl生成一个key,然后根据这个key创建一个Entry条 * 目，然后用Editor控制缓存文件的读写。文件的写入是先写到DirtyFile，然后再通过Editor.commit提 * 交，提交成功则把DirtyFile重命名为cleanFile,失败则丢弃，同时也会写到相应的日志文件里面去 */new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String imageUrl = &quot;http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg&quot;; String key = hashKeyForDisk(imageUrl); DiskLruCache.Editor editor = mDiskLruCache.edit(key); if (editor != null) &#123; OutputStream outputStream = editor.newOutputStream(0); if (downloadUrlToStream(imageUrl, outputStream)) &#123; editor.commit(); &#125; else &#123; editor.abort(); &#125; &#125; mDiskLruCache.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); 读取操作： 123456789101112131415161718192021 /** * 这里涉及到Snapshot类，Snapshot是在mDiskLruCache.get(key)的时候才生成的，主要作用是根据 * key取到的Entry，对这个Entry做一个封装，把Entry的一些参数暴露出来给Snapshot,比如拿到文件 * 输入流给你，至于为什么要这么做，猜测一是为了隐藏Entry类，只把需要的参数暴露出来，二是承担 * 读取的作用，让Editor专心去写。很多文件写入的封装都是用一个Editor去写并且不负责读，写的好处 * 在于隔离了数据生效的及时性，可以通过Editor来控制同步或者异步写入数据的过程，同时也能在中间 * 做一些处理，至于为什么不让Editor类负责读数据...只能猜测就是这么设计这个类的功能的。。。 */try &#123; String imageUrl = &quot;http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg&quot;; String key = hashKeyForDisk(imageUrl); DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key); if (snapShot != null) &#123; InputStream is = snapShot.getInputStream(0); Bitmap bitmap = BitmapFactory.decodeStream(is); mImage.setImageBitmap(bitmap); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 和读写缓存相关的就是这些类了，另外在DiskLruCache中很大的一部分内容是缓存日志的读写操作，下面的日志文件的注释 1234567891011121314151617181920212223242526272829303132&#x2F;** * 这个缓存用了一个名字较journal的日志文件，一个典型的日志文件是这样的格式： * libcore.io.DiskLruCache * 1 * 100 * 2 * * CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 * DIRTY 335c4c6028171cfddfbaae1a9c313c52 * CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342 * REMOVE 335c4c6028171cfddfbaae1a9c313c52 * DIRTY 1ab96a171faeeee38496d8b330771a7a * CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234 * READ 335c4c6028171cfddfbaae1a9c313c52 * READ 3400330d1dfc7f3f7f4b8d4d803dfcf6 * * 头五行构成了日志文件的header。它们是固定的字符串&quot;libcore.io.DiskLruCache&quot;，磁盘缓存的 * 版本号，应用程序的版本号，valueCount（一个key对应几套读写缓存文件），空白行 * * 下面的连续行每一行都表示对一个canche Entry的状态的记录，包括三个数据，状态，key，和可选的 * 状态相关的数值 * DIRTY行 表示一个Entry正在被创建或者更新。每一个成功的DIRTY动作都应该紧跟着一个CLEAN行 * 或者REMOVE行，如果缺失CLEAN或者REMOVE表示这一行的key对应的缓存文件需要被删除掉 * CLEAN行 表示一个Entry已经成功的记录下来并且可读了，后面跟着的数据表示每一个文件的长度 * READ行 表示一次成功的读取记录 * REMOVE行 表示已经删除掉的Entry的记录 * * The journal file is appended to as cache operations occur. The journal may * occasionally be compacted by dropping redundant lines. A temporary file named * &quot;journal.tmp&quot; will be used during compaction; that file should be deleted if * it exists when the cache is opened. *&#x2F; 读取这个日志文件用到了一个工具类函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 /** * Reads the next line. A line ends with &#123;@code &quot;\\n&quot;&#125; or &#123;@code &quot;\\r\\n&quot;&#125;, * this end of line marker is not included in the result. * * @return the next line from the input. * @throws IOException for underlying &#123;@code InputStream&#125; errors. * @throws EOFException for the end of source stream. *///读取一行数据// 从输入流里面读8192的数据到buf[]里面去，检查有没有换行符，有就输出，没有再new ByteArrayOutputStream// 类，循环的读数据到buf再写到output流里面去，一直读到文件末尾都没有换行符则抛出Exception public String readLine() throws IOException &#123; synchronized (in) &#123; if (buf == null) &#123; throw new IOException(&quot;LineReader is closed&quot;); &#125; // Read more data if we are at the end of the buffered data. // Though it&#x27;s an error to read after an exception, we will let &#123;@code fillBuf()&#125; // throw again if that happens; thus we need to handle end == -1 as well as end == pos. if (pos &gt;= end) &#123; fillBuf(); &#125; // Try to find LF in the buffered data and return the line if successful. for (int i = pos; i != end; ++i) &#123; if (buf[i] == LF) &#123; int lineEnd = (i != pos &amp;&amp; buf[i - 1] == CR) ? i - 1 : i; String res = new String(buf, pos, lineEnd - pos, charset.name()); pos = i + 1; return res; &#125; &#125; // Let&#x27;s anticipate up to 80 characters on top of those already read. ByteArrayOutputStream out = new ByteArrayOutputStream(end - pos + 80) &#123; @Override public String toString() &#123; int length = (count &gt; 0 &amp;&amp; buf[count - 1] == CR) ? count - 1 : count; try &#123; return new String(buf, 0, length, charset.name()); &#125; catch (UnsupportedEncodingException e) &#123; throw new AssertionError(e); // Since we control the charset this will never happen. &#125; &#125; &#125;; while (true) &#123; out.write(buf, pos, end - pos); // Mark unterminated line in case fillBuf throws EOFException or IOException. end = -1; fillBuf(); // Try to find LF in the buffered data and return the line if successful. for (int i = pos; i != end; ++i) &#123; if (buf[i] == LF) &#123; if (i != pos) &#123; out.write(buf, pos, i - pos); &#125; pos = i + 1; return out.toString(); &#125; &#125; &#125; &#125; &#125; /** * Reads new input data into the buffer. Call only with pos == end or end == -1, * depending on the desired outcome if the function throws. */ private void fillBuf() throws IOException &#123; int result = in.read(buf, 0, buf.length); if (result == -1) &#123; throw new EOFException(); &#125; pos = 0; end = result; &#125; 其他更详细的细节需要去看源码了。 感谢 郭霖的博客","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"LruCache和LinkedHashMap","slug":"LruCache和LinkedHashMap","date":"2017-12-05T04:38:42.000Z","updated":"2021-01-24T09:19:19.032Z","comments":true,"path":"2017/12/05/LruCache和LinkedHashMap/","link":"","permalink":"http://example.com/2017/12/05/LruCache%E5%92%8CLinkedHashMap/","excerpt":"昨天笔试的时候，有一题是补充LruCache的实现，我想了想，应该不至于要写到链表实现把，于是写了LinkedHashMap进去了，","text":"昨天笔试的时候，有一题是补充LruCache的实现，我想了想，应该不至于要写到链表实现把，于是写了LinkedHashMap进去了，面试的时候面试官问我，这题你是不是用手机查过了……。 于是今天补充下记忆，前提知识：知道LinkedHashMap本身有实现LRU算法，这个会在后面去写 Android下LruCache源码也就300多行，在android.util包下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//看了源码后可以发现LruCache实际上就是对LinkedHashMap的包装，只是增加了一些统计数据比如命中率，丢失率//因为几乎每个方法都加锁，是一个线程安全的类public class LruCache&lt;K, V&gt; &#123; private final LinkedHashMap&lt;K, V&gt; map; private int size; //数据的条目数 private int maxSize; //LruCache的大小 //构造函数很简单，就是new了一个LinkedHashMap,初始化大小为0，装载因子是0.75，最后一个参数表示 //使用LRU算法 public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; /** * Returns the value for &#123;@code key&#125; if it exists in the cache or can be * created by &#123;@code #create&#125;. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. * 这里可以看到get仅仅是调用了LinkedHashMap的map.get(key)方法，加了锁，读取value本身 * 应该是不用加锁的，猜测加锁是为了同步hitcount这些统计数据 */ public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException(&quot;key == null&quot;); &#125; V mapValue; synchronized (this) &#123; mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ //create(key)默认实现就是直接返回null,因此这里会直接return掉 V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; ... &#125; /** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * 写操作，加锁，map.put(key, value)后返回了key之前对应的value previous,safeSizeOf * 默认实现return 1,entryRemoved默认空实现， * 写入后检查如果超出了maxSize，就把最久的条目移出map直到size = maxSize * @return the previous value mapped by &#123;@code key&#125;. */ public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException(&quot;key == null || value == null&quot;); &#125; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous; &#125; /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * 缩小LruCache到maxSize * 一个while循环，remove掉map.eldest() * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); &#125; if (size &lt;= maxSize) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; /** * Removes the entry for &#123;@code key&#125; if it exists. * 调用map.remove(key); * @return the previous value mapped by &#123;@code key&#125;. */ public final V remove(K key) &#123; if (key == null) &#123; throw new NullPointerException(&quot;key == null&quot;); &#125; V previous; synchronized (this) &#123; previous = map.remove(key); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, null); &#125; return previous; &#125; 接下来，我们来看LinkeHashMap是怎么实现LRU算法的 1234567891011121314151617181920212223242526272829303132//LinkedHashMap继承自HashMappublic class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123; //继承了HashMap的内部类，增加了before和after引用指向每一个&lt;K,V&gt;对的前后&lt;K,V&gt;对， //增加为双向链表表示 static class LinkedHashMapEntry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; LinkedHashMapEntry&lt;K,V&gt; before, after; LinkedHashMapEntry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; /** * The head (eldest) of the doubly linked list. * 双链表的头结点 */ transient LinkedHashMapEntry&lt;K,V&gt; head; /** * The tail (youngest) of the doubly linked list. * 双链表的尾节点 */ transient LinkedHashMapEntry&lt;K,V&gt; tail; /** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * 新增的构造函数参数，false表示按插入的顺序获取，true表示按接触的顺序遍历，此时就是 * LRU实现 * @serial */ final boolean accessOrder;&#125; 看一下HashMap.Node是什么 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 /** * 内部类Node实现了map.Entry接口，当我们存一个&lt;K,V&gt;对的时候，就会保存成Node类存 * 到HashMap里面去 * Node类重写了Equals方法和hashCode方法，不过看代码中好像没有用到，比较的时候依旧 * 是拿node1.key == node2.key2 和 node1.key.equals(node2.key)去比较的 * */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //保存的是key的hash值 final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 然后是linkedhashMap的一些操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//重写了HashMap的get方法，只是增加了 if (accessOrder) afterNodeAccess(e);//修改访问顺序 public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value; &#125;public Map.Entry&lt;K, V&gt; eldest() &#123; return head; &#125; //重写newNode方法，新增节点时链接到双链表的末尾Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMapEntry&lt;K,V&gt; p = new LinkedHashMapEntry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; &#125;//在get（K key）之后调用，把这个节点移到双链表的末尾 void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMapEntry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125; 可以看到，LinkedHashmap的LRU实现过程就是，新增的&lt;K,V&gt;对会链接到双链表的末尾，get操作后的&lt;K,V&gt;对也会把操作的节点双链表断开然后移动到双链表的末尾，每次取最久未使用的节点就是双链表的头结点，在LRUCache里面，每次要移除也就是移除的这个节点","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"注解处理器 1","slug":"注解处理器-1","date":"2017-12-03T09:20:04.000Z","updated":"2018-08-20T14:18:20.967Z","comments":true,"path":"2017/12/03/注解处理器-1/","link":"","permalink":"http://example.com/2017/12/03/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-1/","excerpt":"上一篇中，我们生成了一个类，但是要在项目里用，还有几个问题： 这个类要生成在哪个位置，项目可以引用到 绑定的过程是什么样的","text":"上一篇中，我们生成了一个类，但是要在项目里用，还有几个问题： 这个类要生成在哪个位置，项目可以引用到 绑定的过程是什么样的 第一个问题，之前有apt插件，现在新版gradle(3.0) 已经自动处理了这个问题了，目前来说一般都是和绑定的类生成在同一个包下，我们需要annationProcess标注 AbstractProcessor所在的库。 第二个问题，如果要绑定，肯定要执行方法，联想到butterknife里面的bind方法，我们可以在这个方法里面调用生成类的构造函数，然后在生成的类的构造函数里面执行findviewbyId方法。于是问题成了，怎么可以拿到需要的数据，xxView var = (xxView) view.findviewbyId(id)所涉及到的，view我们可以根据Activity拿到DecorView，因此还需要的是注解标记的变量类型，变量名字，此外还需要注解所在的类的名字，用于生成类。因此我们可以设想，一个生成类，类里面有一个list，保存注解的条目。 此外就是javaPoet的内容了，javaPoet api不熟的话挺头疼的.. 项目结构的话，新建了一个mybutterknife的Android库，主要是定义了bind方法，然后在这个库里面引用了annotation库，这样就和ButterKnife一样用了，我们的app目录需要引用processor库和mybutterknife库，基本就是这样子，具体的注释都在代码里面 代码在github上,打了tag v0.2","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"注解处理器 0","slug":"注解处理器-0","date":"2017-12-02T16:35:08.000Z","updated":"2018-10-14T02:32:46.355Z","comments":true,"path":"2017/12/03/注解处理器-0/","link":"","permalink":"http://example.com/2017/12/03/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-0/","excerpt":"今天试着写一下ButterKnife的原理,虽然网上已经有很多说的了，但是代码还是要亲手打出来，而且网上都是旧版本的gradle，仍然用的apt插件，gradle 3.0已经不需要了，而且是不能用apt了 因为代码部分比较简单，所以只写一下步骤。","text":"今天试着写一下ButterKnife的原理,虽然网上已经有很多说的了，但是代码还是要亲手打出来，而且网上都是旧版本的gradle，仍然用的apt插件，gradle 3.0已经不需要了，而且是不能用apt了 因为代码部分比较简单，所以只写一下步骤。 创建一个Android项目，名字随意，Android Studio会在这个项目创建一个默认模块app 。 创建一个新的模块annotation,并且在模块里面创建一个注解类AnnotationFIELD 123456789101112131415161718package com.example.annotation;import java.lang.annotation.Retention;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.FIELD;import static java.lang.annotation.RetentionPolicy.CLASS;/** * Created by alan on 2017/12/2. */@Target(FIELD)@Retention(CLASS)public @interface AnnotationFIELD &#123; int value() default 0;&#125; 并且在此模块的build.gradle文件末尾增加 123sourceCompatibility &#x3D; &quot;1.7&quot;targetCompatibility &#x3D; &quot;1.7&quot; 创建一个新的模块processor，并且在模块里面创建一个注解处理器MyProcessor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.example.processor;import com.example.annotation.AnnotationFIELD;import com.google.auto.service.AutoService;import java.io.IOException;import java.io.Writer;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.Processor;import javax.annotation.processing.RoundEnvironment;import javax.annotation.processing.SupportedAnnotationTypes;import javax.annotation.processing.SupportedSourceVersion;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;import javax.tools.Diagnostic;import javax.tools.JavaFileObject;/** * Created by alan on 2017/12/2. */@AutoService(Processor.class)@SupportedAnnotationTypes(&quot;com.example.annotation.AnnotationFIELD&quot;)@SupportedSourceVersion(SourceVersion.RELEASE_8)public class MyProcessor extends AbstractProcessor &#123; static final String CLASS_NAME = &quot;GeneratedClass&quot;; final String PACKAGENAME = this.getClass().getPackage().getName(); @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; StringBuilder builder = new StringBuilder() .append(&quot;package &quot;) .append(PACKAGENAME) .append(&quot;;\\n\\n&quot;) .append(&quot;public class &quot; + CLASS_NAME + &quot; &#123;\\n\\n&quot;) // open class .append(&quot;\\tpublic String getMessage() &#123;\\n&quot;) // open method .append(&quot;\\t\\treturn \\&quot;&quot;); // for each javax.lang.model.element.Element annotated with the AnnotationFIELD for (Element element : roundEnvironment.getElementsAnnotatedWith(AnnotationFIELD.class)) &#123; String objectType = element.getSimpleName().toString(); printMessageInGradleConsole(&quot;====objectType :==== &quot; + objectType); // this is appending to the return statement builder.append(objectType).append(&quot; says hello! &quot;); &#125; builder.append(&quot;\\&quot;;\\n&quot;) // end return .append(&quot;\\t&#125;\\n&quot;) // close method .append(&quot;&#125;\\n&quot;); // close class printMessageInGradleConsole(&quot;Package : &quot; + PACKAGENAME); try &#123; // write the file JavaFileObject source = processingEnv.getFiler().createSourceFile(PACKAGENAME + &quot;.&quot; + CLASS_NAME); Writer writer = source.openWriter(); writer.write(builder.toString()); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; // Note: calling e.printStackTrace() will print IO errors // that occur from the file already existing after its first run, this is normal &#125; return true; &#125; void printMessageInGradleConsole(String str)&#123; //processingEnv是父类的成员变量 processingEnv.getMessager().printMessage(Diagnostic.Kind.MANDATORY_WARNING,str); &#125;&#125; 然后修改这个模块的build.gradle文件: 12345678910apply plugin: &#x27;java-library&#x27; dependencies &#123; implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;]) implementation &#x27;com.google.auto.service:auto-service:1.0-rc3&#x27; implementation project(&#x27;:annotation&#x27;) &#125; sourceCompatibility = &quot;1.7&quot; targetCompatibility = &quot;1.7&quot; ​ 之前不能生成对应的 .class文件，就是在这里卡了一下。主要注意的地方有以下几个： Java的版本，1.7和1.8都可以 AutoService注解，别的地方说，添加了之后不需要设置meta文件夹了，我看Butterknife的项目里面也只加了这一行，但是我这里仍然需要@SupportedAnnotationTypes(“com.example.annotation.AnnotationFIELD”)@SupportedSourceVersion(SourceVersion.RELEASE_8) _ 这两个注解，不然无法生成类，(或者重写对应的方法 )； SourceVersion，RELEASE_7或8都可以 在最开始的模块，app模块的build.gradle里面加入 12345678910Android&#123;compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;dependencies&#123; implementation project(&#x27;:annotation&#x27;) annotationProcessor project(&#x27;:processor&#x27;)&#125; 这里要说明的是，虽然在本地建立了processor模块，但是实际上并不需要implementation，只需要annotationProcessor就行了，这个和Butterknife的处理也是一致的，而且也不需要apt插件了 在app模块下的MainActivity类增加声明 12@AnnotationFIELD(3)private TextView textView; 这里只需要用一下注解就好 clean Project，Rebuild Project ,这时候应该可以在 1app\\build\\generated\\source\\apt\\debug 目录下找到GeneratedClass这个生成类了 ​ 相应的代码在github上，打了tag v0.1","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"Android-HandlerThread","slug":"Android-HandlerThread","date":"2017-12-01T01:28:26.000Z","updated":"2021-01-24T09:20:58.551Z","comments":true,"path":"2017/12/01/Android-HandlerThread/","link":"","permalink":"http://example.com/2017/12/01/Android-HandlerThread/","excerpt":"假如我们有这样一个需要，我们想要一个带消息队列的子线程，带消息队列是因为我们还希望和子线程有一个交互，如果只是一个runnable,那么就是一次性的任务。 这个时候很容易想到Looper，Handler之类的， 考虑到需要进行任务的处理，我们需要继承Handler来处理任务， 因为是子线程，所以需要这个子线程能够提供Looper来构造handler, 如果有这样一个接口，那么我们在Thread的runnable函数里面，就要执行Looper.prepar和Looper.loop,这两个函数，一个是new Looper出来，一个是启动消息循环，没有消息时会阻塞，因此runnable不会执行完流程而导致线程退出。","text":"假如我们有这样一个需要，我们想要一个带消息队列的子线程，带消息队列是因为我们还希望和子线程有一个交互，如果只是一个runnable,那么就是一次性的任务。 这个时候很容易想到Looper，Handler之类的， 考虑到需要进行任务的处理，我们需要继承Handler来处理任务， 因为是子线程，所以需要这个子线程能够提供Looper来构造handler, 如果有这样一个接口，那么我们在Thread的runnable函数里面，就要执行Looper.prepar和Looper.loop,这两个函数，一个是new Looper出来，一个是启动消息循环，没有消息时会阻塞，因此runnable不会执行完流程而导致线程退出。 那么，除了这些，还有什么需要考虑的呢？可以考虑一个退出的接口，Looper类已经提供了looper.quit方法 这些基本就是HandlerThread的大致内容了，我们可以看看源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/** * Handy class for starting a new thread that has a looper. The looper can then be * used to create handler classes. Note that start() must still be called. */public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; /** * Constructs a HandlerThread. * @param name * @param priority The priority to run the thread at. The value supplied must be from * &#123;@link android.os.Process&#125; and not from java.lang.Thread. */ public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; /** * Call back method that can be explicitly overridden if needed to execute some * setup before Looper loops. */ protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; /** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */ public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; /** * @return a shared &#123;@link Handler&#125; associated with this thread * @hide */ @NonNull public Handler getThreadHandler() &#123; if (mHandler == null) &#123; mHandler = new Handler(getLooper()); &#125; return mHandler; &#125; /** * Quits the handler thread&#x27;s looper. * &lt;p&gt; * Causes the handler thread&#x27;s looper to terminate without processing any * more messages in the message queue. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt; * Using this method may be unsafe because some messages may not be delivered * before the looper terminates. Consider using &#123;@link #quitSafely&#125; instead to ensure * that all pending work is completed in an orderly manner. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. * * @see #quitSafely */ public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; /** * Quits the handler thread&#x27;s looper safely. * &lt;p&gt; * Causes the handler thread&#x27;s looper to terminate as soon as all remaining messages * in the message queue that are already due to be delivered have been handled. * Pending delayed messages with due times in the future will not be delivered. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p&gt; * If the thread has not been started or has finished (that is if * &#123;@link #getLooper&#125; returns null), then false is returned. * Otherwise the looper is asked to quit and true is returned. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. */ public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; /** * Returns the identifier of this thread. See Process.myTid(). */ public int getThreadId() &#123; return mTid; &#125;&#125; 系统的源码里面除了上面说的内容以外，还额外的有线程pid,priority参数。值得注意的是getLooper方法，除了有线程存活的判断以外，还有调用wait方法等待，因为考虑到有可能线程刚刚new 出来，或者还没有执行到Looper.prepare方法，而在run()里面Looper.prepare执行后则调用了notifyAll来唤醒。 使用方法就是 12345678HandlerThread handlerThread = new HanderThread();handlerThread.start();Handler handler = new Handler(handlerThread.getLooper())&#123; @Override public void handleMessage()&#123; doSomething(); &#125;&#125;","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"Android-ANR分析","slug":"Android-ANR分析","date":"2017-11-24T02:28:58.000Z","updated":"2018-10-17T01:46:54.410Z","comments":true,"path":"2017/11/24/Android-ANR分析/","link":"","permalink":"http://example.com/2017/11/24/Android-ANR%E5%88%86%E6%9E%90/","excerpt":"来源,在这里看到的一些总结，觉得有些收获","text":"来源,在这里看到的一些总结，觉得有些收获 ANR类型ANR一般有三种类型： KeyDispatchTimeout(5 seconds) –主要类型 按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) BroadcastReceiver在特定时间内无法处理完成 ServiceTimeout(20 seconds) –小概率类型 Service在特定的时间内无法处理完成 如何去分析ANR先看个LOG: 12345678910111213141516171819202122232425262728293031323334353637383940414243444504-01 13:12:11.572** I&#x2F;InputDispatcher( 220): Application is not responding**:Window&#123;2b263310com.android.email&#x2F;com.android.email.activity.SplitScreenActivitypaused&#x3D;false&#125;. 5009.8ms since event, 5009.5ms since waitstarted04-0113:12:11.572 I&#x2F;WindowManager( 220): Input event dispatching timedout sending tocom.android.email&#x2F;com.android.email.activity.SplitScreenActivity04-01 **13:12:14.123 I&#x2F;Process( 220): Sending signal. PID: 21404 SIG: 3---**发生**ANR**的时间和生成**trace.txt**的时间04-01 13:12:14.123 I&#x2F;dalvikvm(21404):threadid&#x3D;4: reacting to signal 3 ……04-0113:12:15.872 E&#x2F;ActivityManager( 220): ANR in com.android.email(com.android.email&#x2F;.activity.SplitScreenActivity)04-0113:12:15.872 E&#x2F;ActivityManager( 220): Reason:keyDispatchingTimedOut04-0113:12:15.872 E&#x2F;ActivityManager( 220): Load: 8.68 &#x2F; 8.37 &#x2F; 8.5304-0113:12:15.872 E&#x2F;ActivityManager( 220): **CPUusage from 4361ms to 699ms ago** ----CPU在ANR发生前的使用情况04-0113:12:15.872 E&#x2F;ActivityManager( 220): 5.5%21404&#x2F;com.android.email: 1.3% user + 4.1% kernel &#x2F; faults: 10 minor04-0113:12:15.872 E&#x2F;ActivityManager( 220): 4.3%220&#x2F;system_server: 2.7% user + 1.5% kernel &#x2F; faults: 11 minor 2 major04-0113:12:15.872 E&#x2F;ActivityManager( 220): 0.9%52&#x2F;spi_qsd.0: 0% user + 0.9% kernel04-0113:12:15.872 E&#x2F;ActivityManager( 220): 0.5%65&#x2F;irq&#x2F;170-cyttsp-: 0% user + 0.5% kernel04-0113:12:15.872 E&#x2F;ActivityManager( 220): 0.5%296&#x2F;com.android.systemui: 0.5% user + 0% kernel04-0113:12:15.872 E&#x2F;ActivityManager( 220): **100%TOTAL: 4.8% user + 7.6% kernel + 87% iowait**04-0113:12:15.872 E&#x2F;ActivityManager( 220): **CPUusage from 3697ms to 4223ms later**:-- ANR后CPU的使用量04-0113:12:15.872 E&#x2F;ActivityManager( 220): 25%21404&#x2F;com.android.email: 25% user + 0% kernel &#x2F; faults: 191 minor04-0113:12:15.872 E&#x2F;ActivityManager( 220): 16% 21603&#x2F;__eas(par.hakan: 16% user + 0% kernel04-0113:12:15.872 E&#x2F;ActivityManager( 220): 7.2% 21406&#x2F;GC: 7.2% user + 0% kernel04-0113:12:15.872 E&#x2F;ActivityManager( 220): 1.8% 21409&#x2F;Compiler: 1.8% user + 0% kernel04-0113:12:15.872 E&#x2F;ActivityManager( 220): 5.5%220&#x2F;system_server: 0% user + 5.5% kernel &#x2F; faults: 1 minor04-0113:12:15.872 E&#x2F;ActivityManager( 220): 5.5% 263&#x2F;InputDispatcher: 0% user + 5.5% kernel04-0113:12:15.872 E&#x2F;ActivityManager( 220): **32%TOTAL: 28% user + 3.7% kernel** 从LOG可以看出ANR的类型，CPU的使用情况，如果CPU使用量接近100%，说明当前设备很忙，有可能是CPU饥饿导致了ANR 如果CPU使用量很少，说明主线程被BLOCK了 如果IOwait很高，说明ANR有可能是主线程在进行I/O操作造成的 除了看LOG，解决ANR还得需要trace.txt文件，data/anr/traces.txt 如何调查并解决ANR 首先分析log，根据Log里面ANR发生的时间去trace.txt文件里面查到对应的段落 从trace.txt文件对应的段落里查看调用stack. 看代码 仔细查看ANR的成因（iowait?block?memoryleak?） 例子： 打开log文件 ， 由于是ANR错误，因此搜索”ANR “ ， 为何要加空格呢，你加上和去掉比较一下就知道了 。 可以屏蔽掉不少保存到anr.log文件的无效信息。 定位到关键的事件信息如下： 12345678910111213141516171819202122232425262701-15 16:49:02.433 E&#x2F;ActivityManager( 2466): ANR in com.android.mms (com.android.mms&#x2F;.ui.SlideshowActivity)01-15 16:49:02.433 E&#x2F;ActivityManager( 2466): Reason: keyDispatchingTimedOut01-15 16:49:02.433 E&#x2F;ActivityManager( 2466): Load: 0.6 &#x2F; 0.61 &#x2F; 0.4201-15 16:49:02.433 E&#x2F;ActivityManager( 2466): CPU usage from 1337225ms to 57ms ago:01-15 16:49:02.433 E&#x2F;ActivityManager( 2466): sensorserver_ya: 8% &#x3D; 0% user + 8% kernel &#x2F; faults: 40 minor......01-15 16:49:02.433 E&#x2F;ActivityManager( 2466): -com.android.mms: 0% &#x3D; 0% user + 0% kernel01-15 16:49:02.433 E&#x2F;ActivityManager( 2466): -flush-179:8: 0% &#x3D; 0% user + 0% kernel01-15 16:49:02.433 E&#x2F;ActivityManager( 2466): TOTAL: 25% &#x3D; 10% user + 14% kernel + 0% iowait + 0% irq + 0% softirq01-15 16:49:02.436 I&#x2F; ( 2466): dumpmesg &gt; &quot;&#x2F;data&#x2F;log&#x2F;dumpstate_app_anr.log&quot; 我们用自然语言来描述一下日志，这也算是一种能力吧 。 01-15 16:49:02.433 E/ActivityManager( 2466): ANR in com.android.mms (com.android.mms/.ui.SlideshowActivity) 翻译：在16:49分2秒433毫秒的时候 ActivityManager （进程号为2466) 发生了如下错误：com.android.mms包下面的.ui.SlideshowActivity 无响应 。 01-15 16:49:02.433 E/ActivityManager( 2466): Reason: keyDispatchingTimedOut 翻译：原因 ， keyDispatchingTimeOut - 按键分配超时 01-15 16:49:02.433 E/ActivityManager( 2466): Load: 0.6 / 0.61 / 0.42 翻译：5分钟，10分钟，15分钟内的平均负载分别为：0.6 , 0.61 , 0.42 在这里我们大概知道问题是什么了，结合我们之前的操作流程，我们知道问题是在点击按钮某时候可能处理不过来按钮事件，导致超时无响应 。那么现在似乎已经可以进行工作了 。 我们知道Activity中是通过重载dispatchTouchEvent(MotionEvent ev)来处理点击屏幕事件 。 然后我们可以顺藤摸瓜，一点点分析去查找原因 。 但这样够了么 ？ 其实不够 ， 至少我们不能准确的知道到底问题在哪儿 ， 只是猜测 ，比如这个应用程序中，我就在顺藤摸瓜的时候发现了多个IO操作的地方都在主线程中，可能引起问题，但不好判断到底是哪个 ，所以我们目前掌握的信息还不够 。 于是我们再分析虚拟机信息 ， 搜索“Dalvik Thread”关键词，快速定位到本应用程序的虚拟机信息日志，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178----- pid 2922 at 2011-01-13 13:51:07 -----Cmd line: com.android.mmsDALVIK THREADS:&quot;main&quot; prio&#x3D;5 tid&#x3D;1 NATIVE | group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x4001d8d0 self&#x3D;0xccc8 | sysTid&#x3D;2922 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;-1345017808 | schedstat&#x3D;( 3497492306 15312897923 10358 ) at android.media.MediaPlayer._release(Native Method) at android.media.MediaPlayer.release(MediaPlayer.java:1206) at android.widget.VideoView.stopPlayback(VideoView.java:196) at com.android.mms.ui.SlideView.stopVideo(SlideView.java:640) at com.android.mms.ui.SlideshowPresenter.presentVideo(SlideshowPresenter.java:443) at com.android.mms.ui.SlideshowPresenter.presentRegionMedia(SlideshowPresenter.java:219) at com.android.mms.ui.SlideshowPresenter$4.run(SlideshowPresenter.java:516) at android.os.Handler.handleCallback(Handler.java:587) at android.os.Handler.dispatchMessage(Handler.java:92) at android.os.Looper.loop(Looper.java:123) at android.app.ActivityThread.main(ActivityThread.java:4627) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:521) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:858) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) at dalvik.system.NativeStart.main(Native Method)&quot;Binder Thread #3&quot; prio&#x3D;5 tid&#x3D;11 NATIVE | group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x4837f808 self&#x3D;0x242280 | sysTid&#x3D;3239 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;2341032 | schedstat&#x3D;( 32410506 932842514 164 ) at dalvik.system.NativeStart.run(Native Method)&quot;AsyncQueryWorker&quot; prio&#x3D;5 tid&#x3D;9 WAIT | group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x482f4b80 self&#x3D;0x253e10 | sysTid&#x3D;3236 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;2432120 | schedstat&#x3D;( 3225061 26561350 27 ) at java.lang.Object.wait(Native Method) - waiting on &lt;0x482f4da8&gt; (a android.os.MessageQueue) at java.lang.Object.wait(Object.java:288) at android.os.MessageQueue.next(MessageQueue.java:146) at android.os.Looper.loop(Looper.java:110) at android.os.HandlerThread.run(HandlerThread.java:60)&quot;Thread-9&quot; prio&#x3D;5 tid&#x3D;8 WAIT | group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x4836e2b0 self&#x3D;0x25af70 | sysTid&#x3D;2929 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;2370896 | schedstat&#x3D;( 130248 4389035 2 ) at java.lang.Object.wait(Native Method) - waiting on &lt;0x4836e240&gt; (a java.util.ArrayList) at java.lang.Object.wait(Object.java:288) at com.android.mms.data.Contact$ContactsCache$TaskStack$1.run(Contact.java:488) at java.lang.Thread.run(Thread.java:1096)&quot;Binder Thread #2&quot; prio&#x3D;5 tid&#x3D;7 NATIVE | group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x482f8ca0 self&#x3D;0x130fd0 | sysTid&#x3D;2928 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1215968 | schedstat&#x3D;( 40610049 1837703846 195 ) at dalvik.system.NativeStart.run(Native Method)&quot;Binder Thread #1&quot; prio&#x3D;5 tid&#x3D;6 NATIVE | group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x482f4a78 self&#x3D;0x128a50 | sysTid&#x3D;2927 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1201352 | schedstat&#x3D;( 40928066 928867585 190 ) at dalvik.system.NativeStart.run(Native Method)&quot;Compiler&quot; daemon prio&#x3D;5 tid&#x3D;5 VMWAIT | group&#x3D;&quot;system&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x482f1348 self&#x3D;0x118960 | sysTid&#x3D;2926 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1149216 | schedstat&#x3D;( 753021350 3774113668 6686 ) at dalvik.system.NativeStart.run(Native Method)&quot;JDWP&quot; daemon prio&#x3D;5 tid&#x3D;4 VMWAIT | group&#x3D;&quot;system&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x482f12a0 self&#x3D;0x132940 | sysTid&#x3D;2925 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1255680 | schedstat&#x3D;( 2827103 29553323 19 ) at dalvik.system.NativeStart.run(Native Method)&quot;Signal Catcher&quot; daemon prio&#x3D;5 tid&#x3D;3 RUNNABLE | group&#x3D;&quot;system&quot; sCount&#x3D;0 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x482f11e8 self&#x3D;0x135988 | sysTid&#x3D;2924 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1173688 | schedstat&#x3D;( 11793815 12456169 7 ) at dalvik.system.NativeStart.run(Native Method)&quot;HeapWorker&quot; daemon prio&#x3D;5 tid&#x3D;2 VMWAIT | group&#x3D;&quot;system&quot; sCount&#x3D;1 dsCount&#x3D;0 s&#x3D;N obj&#x3D;0x45496028 self&#x3D;0x135848 | sysTid&#x3D;2923 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1222608 | schedstat&#x3D;( 79049792 1520840200 95 ) at dalvik.system.NativeStart.run(Native Method)----- end 2922 ----- 每一段都是一个线程 ，当然我们还是看线程号为1的主线程了。通过分析发现关键问题是这样： at com.android.mms.ui.SlideshowPresenter$3.run(SlideshowPresenter.java:531) 定位到代码： 12345678910111213141516171819202122232425262728293031mHandler.post(new Runnable() &#123;​ public void run() &#123;​ try &#123;​ presentRegionMedia(view, (RegionMediaModel) model, dataChanged);​ &#125; catch (OMADRMException e) &#123;​ Log.e(TAG, e.getMessage(), e);​ Toast.makeText(mContext,​ mContext.getString(R.string.insufficient_drm_rights),​ Toast.LENGTH_SHORT).show();​ &#125; catch (IOException e)&#123;​ Log.e(TAG, e.getMessage(), e);​ Toast.makeText(mContext,​ mContext.getString(R.string.insufficient_drm_rights),​ Toast.LENGTH_SHORT).show();​ &#125;​ &#125; 很清楚了， Handler.post 方法之后执行时间太长的问题 。 继续看presentRegionMedia(view, (RegionMediaModel) model, dataChanged);方法 ， 发现最终是调用的framework 中MediaPlayer.stop方法 。 至此，我们的日志分析算是告一段落 。 可以开始思考解决办法了","categories":[{"name":"Android_性能优化","slug":"Android-性能优化","permalink":"http://example.com/categories/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[],"keywords":[{"name":"Android_性能优化","slug":"Android-性能优化","permalink":"http://example.com/categories/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Java虚拟机-类,对象，内存","slug":"Java虚拟机-类,对象，内存","date":"2017-11-22T07:51:43.000Z","updated":"2021-01-24T09:24:17.634Z","comments":true,"path":"2017/11/22/Java虚拟机-类,对象，内存/","link":"","permalink":"http://example.com/2017/11/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%B1%BB,%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%86%85%E5%AD%98/","excerpt":"来源：《深入理解Java虚拟机(第2版)》 Java虚拟机-类,对象，内存类加载虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 虚拟机规定了有且只有五种情况需要开始类的加载过程: 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。","text":"来源：《深入理解Java虚拟机(第2版)》 Java虚拟机-类,对象，内存类加载虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 虚拟机规定了有且只有五种情况需要开始类的加载过程: 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 这五种场景中的行为称为对一个类的主动引用，其他情况称为被动引用， 1234567891011121314151617181920//被动引用示例一: 使用子类引用父类的静态字段，不会导致子类初始化。public class SuperClass &#123; public static int value = 123; static &#123; System.out.println(&quot;super class init.&quot;); &#125;&#125;public class SubClass extends SuperClass &#123; static &#123; System.out.println(&quot;sub class init.&quot;); &#125;&#125;public static void main(String[] args) &#123; System.out.println(SubClass.value);&#125;//输出：super class init. 1234567891011121314//被动引用示例二：通过数组定义来引用类，不会触发类的初始化public static void main(String[] args) &#123; SuperClass[] arr = new SuperClass[10];&#125;public class SuperClass &#123; public static int value = 123; static &#123; System.out.println(&quot;super class init.&quot;); &#125;&#125;//输出nonthing 123456789101112131415//被动引用示例三：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。public static void main(String[] args) &#123; System.out.println(ConstClass.Test);&#125;public class ConstClass &#123; public static final String Test = &quot;Hello world!&quot;; static &#123; System.out.println(&quot;const class init.&quot;); &#125;&#125;//输出Hello world! 类加载的过程java虚拟机中类加载的全过程：加载、验证、准备、解析和初始化这5个阶段，注意区别于类的生命周期。 加载在加载阶段，虚拟机需要完成以下3件事情： 1）通过一个类的全限定名来获取定义此类的二进制字节流。 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 数组类本身不通过类加载器创建，它是由java虚拟机直接创建的。但数组类与类加载器仍然有密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建。 加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证 验证是连接阶段（连接阶段包括验证、准备、解析）的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。如果验证失败，会抛出java.lang.VerifyError异常。 验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次，这里所说的初始值“通常情况下“是数据类型的零值。假设一个类变量的定义为： 1public static int value&#x3D;123; 那变量value在准备阶段过后的初始值为0而不是123 如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为： 1public static final int value&#x3D;123; 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置讲value赋值为123。 解析解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在java虚拟机规范的Class文件格式中。 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那直接引用的目标必定已经在内存中存在。 解析的动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行解析。 初始化 在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员制定的主观计划去初始化类变量和其他资源，或者从另一个角度来表达：初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程。 关于&lt; clinit &gt;： &lt; clinit &gt;方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量。 类构造器&lt; clinit &gt;方法对于类和接口并不是必须的，如果一个类中没有静态初始化块，也没有类变量赋值操作，则编译器可以不为该类生成类构造器&lt; clinit &gt;方法。 java虚拟机会保证一个类的&lt; clinit &gt;方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，只会有一个线程去执行这个类的&lt; clinit &gt;方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit &gt;方法完毕。 初始化阶段，当执行完类构造器&lt; clinit &gt;方法之后，才会执行实例构造器的&lt; init &gt;方法，实例构造方法同样是按照先父类，后子类，先成员变量，后实例构造方法的顺序执行。 类加载器类与类加载器对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。 双亲委派模型从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。 扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\\lib\\，该加载器可以被开发者直接使用。 应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 在Android系统中，情况有所不同,SecureClassLoader和UrlClassLoader是在Java中的类加载器，在Android中是没法办使用的: 其中，App系统类加载器是PathClassLoader，而BootClassLoader是其parent类加载器。 双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。 自定义类加载器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 代码来自 http://blog.csdn.net/boyupeng/article/details/47951037 * 一、ClassLoader加载类的顺序 * 1.调用 findLoadedClass(String) 来检查是否已经加载类。 * 2.在父类加载器上调用 loadClass 方法。如果父类加载器为 null，则使用虚拟机的内置类加载器。 * 3.调用 findClass(String) 方法查找类。 * 二、实现自己的类加载器 * 1.获取类的class文件的字节数组 * 2.将字节数组转换为Class类的实例 */ public class ClassLoaderTest &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; //新建一个类加载器 MyClassLoader cl = new MyClassLoader(&quot;myClassLoader&quot;); //加载类，得到Class对象 Class&lt;?&gt; clazz = cl.loadClass(&quot;classloader.Animal&quot;); //得到类的实例 Animal animal=(Animal) clazz.newInstance(); animal.say(); &#125; &#125; class Animal&#123; public void say()&#123; System.out.println(&quot;hello world!&quot;); &#125; &#125; class MyClassLoader extends ClassLoader &#123; //类加载器的名称 private String name; //类存放的路径 private String path = &quot;E:\\\\workspace\\\\Algorithm\\\\src&quot;; MyClassLoader(String name) &#123; this.name = name; &#125; MyClassLoader(ClassLoader parent, String name) &#123; super(parent); this.name = name; &#125; /** * 重写findClass方法 */ @Override public Class&lt;?&gt; findClass(String name) &#123; byte[] data = loadClassData(name); return this.defineClass(name, data, 0, data.length); &#125; public byte[] loadClassData(String name) &#123; try &#123; name = name.replace(&quot;.&quot;, &quot;//&quot;); FileInputStream is = new FileInputStream(new File(path + name + &quot;.class&quot;)); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int b = 0; while ((b = is.read()) != -1) &#123; baos.write(b); &#125; return baos.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 对象对象的创建 当虚拟机遇到一条new指令时，首先会去检查这个类的符号引用是否可以在常量池中定位，这个类是否已经被加载解析和初始化过。 检查通过后，虚拟机开始为新生的对象分配内存。分配内存通常有两种方式： 如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，这种分配方式称为“指针碰撞”。 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的， 这种分配方式成为“空闲列表”。采用哪种方式和虚拟机的GC类型有关。 内存分配完成后。虚拟机需要将这块内存空间初始化为零值。此时一个新的对象已经诞生了，然后是执行&lt;init&gt;方法，按照程序员的意愿进行初始化，之后才可用。 对象的内存布局对象在内存中存储的布局可以分为三块区域：对象头，实例数据和对齐填充。 对象头包含两部分信息，一部分用来存储对象自身的运行时数据,包括对象的哈希码，gc分代年龄，锁状态标识，线程锁等，称为Mark Word（在32bit和64bit虚拟机上长度分别为32bit和64bit）；另一部分是类型指针，指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针。另外，如果对象是一个Java数组，那么对象头重还会记录数组的长度。 实例数据是对象真正存储信息的地方,也是代码中所定义的各种类型的字段内容.无论是继承下来的,还是子类中定义的,都需要记录起来. 对齐填充并不是必然存在的，因为虚拟机要对对象的大小必须是8的整数倍，因此，它仅仅用来对齐。 对象的访问定位Java程序需要通过栈上的引用数据来操作堆上的具体对象。对象的访问方式取决于虚拟机实现，目前主流的访问方式有使用句柄和直接指针两种。 句柄，可以理解为指向指针的指针，维护指向对象的指针变化，而对象的句柄本身不发生变化；指针，指向对象，代表对象的内存地址。 句柄 Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 优势：引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身不需要修改。 直接指针 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而引用中存储的直接就是对象地址。优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。（例如HotSpot） 运行时内存区域划分根据《Java虚拟机规范(SE 7)》的规定，Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不用的区域。 程序计数器程序计数器可以看作当前线程所执行的字节码的行号指示器，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，因此，为什么线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，它们互不影响，存储在线程私有内存区域。此区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈和程序计数器一样，Java虚拟机栈也是线程私有的，每一个Java方法执行的时候，都会创建一个栈帧，它的生命周期很短，主要用于存储局部变量，操作数栈，动态链接，方法出口地址等，此区域可能会抛出StackOverFlow异常和OutOfMemoryError异常。还会保存堆中对象变量的引用。 本地方法栈和Java虚拟机栈的作用类似，为Native方法服务，线程私有。 Java堆Java堆是被所有的线程共享的一块内存区域，此区域的唯一目的就是存放对象实例，几乎所有的对象实例和数组都会在这里分配。Java堆是GC管理的主要区域。由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为新生代和老年代；再细致点就是Eden，From Survivor,To Survivor空间等。可以通过-Xmx和-Xms来进行大小的扩展。堆内存的生命周期从程序的运行开始到运行结束。 方法区方法区也是被所有线程共享的内存区域，它用于存储已经被虚拟机加载的类信息，常量，静态变量等。 运行时常量池方法区的一部分 直接内存直接内存并不是虚拟机运行时数据区的一部分。它使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。虽然直接内存的分配不受Java虚拟机的限制，但是它仍然受到物理内存总大小等的限制，当Java堆过大的时候，可能会导致这块区域分配不足而OutOfMemory异常。 图片来源于http://gityuan.com/2016/01/09/java-memory/","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","permalink":"http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"Android性能优化典范1阅读","slug":"Android性能优化典范1阅读","date":"2017-11-21T09:27:54.000Z","updated":"2018-10-15T08:23:01.357Z","comments":true,"path":"2017/11/21/Android性能优化典范1阅读/","link":"","permalink":"http://example.com/2017/11/21/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%85%B8%E8%8C%831%E9%98%85%E8%AF%BB/","excerpt":"这里是原文地址 界面卡顿问题大多数用户感知到的卡顿等性能问题的最主要根源都是因为渲染性能。Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在32ms内看到的会是同一帧画面。","text":"这里是原文地址 界面卡顿问题大多数用户感知到的卡顿等性能问题的最主要根源都是因为渲染性能。Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在32ms内看到的会是同一帧画面。 用户容易在UI执行动画或者滑动ListView的时候感知到卡顿不流畅，是因为这里的操作相对复杂，容易发生丢帧的现象，从而感觉卡顿。有很多原因可以导致丢帧，也许是因为你的layout太过复杂，无法在16ms内完成渲染，有可能是因为你的UI上有层叠太多的绘制单元，还有可能是因为动画执行的次数过多。这些都会导致CPU或者GPU负载过重。 我们可以通过一些工具来定位问题，比如可以，也可以。你还可以使用TraceView来观察CPU的执行情况，更加快捷的找到性能瓶颈。 检查渲染时间打开手机里面的开发者选项，选择Profile GPU Rendering，选中On screen as bars的选项。 Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。 检查Activity中的布局是否过于复杂使用HierarchyViewer，使得布局尽量扁平化，避免出现重复的嵌套布局。移除非必需的UI组件，这些操作能够减少Measure，Layout的计算时间。 检查过度绘制的情况使用手机设置里面的开发者选项，打开Show GPU Overdraw等选项进行观察 Overdraw描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。 对于自定义的View(重写了onDraw方法)，我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。 可以尝试的方法： 移除Window默认的Background 移除XML布局文件中非必需的Background 按需显示占位背景图片 内存抖动和GC Memory Monitor：跟踪整个app的内存变化情况。 Heap Viewer：查看当前内存快照，便于对比分析哪些对象有可能发生了泄漏。 Allocation Tracker：追踪内存对象的来源。 通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。 导致GC频繁执行有两个原因： Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。 瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。 检查内存泄漏的情况使用Heap Tool查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的 内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。 电池优化可以通过Battery Historian Tool来查看详细的电量消耗。有下面一些措施能够显著减少电量的消耗： 我们应该尽量减少唤醒屏幕的次数与持续的时间，使用WakeLock来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态。 某些非必须马上执行的操作，例如上传歌曲，图片处理等，可以等到设备处于充电状态或者电量充足的时候才进行。 触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗。","categories":[{"name":"Android_性能优化","slug":"Android-性能优化","permalink":"http://example.com/categories/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[],"keywords":[{"name":"Android_性能优化","slug":"Android-性能优化","permalink":"http://example.com/categories/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"约瑟夫问题","slug":"约瑟夫问题","date":"2017-11-21T04:37:09.000Z","updated":"2018-08-20T14:18:20.982Z","comments":true,"path":"2017/11/21/约瑟夫问题/","link":"","permalink":"http://example.com/2017/11/21/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/","excerpt":"问题描述：n个人（编号1~n)，从1开始报数，报到m的退出，剩下的人继续从1开始报数。求胜利者的编号","text":"问题描述：n个人（编号1~n)，从1开始报数，报到m的退出，剩下的人继续从1开始报数。求胜利者的编号 分析： 从问题来看，首先我们假设有个数组，那么第一圈(0到n)的报数结束之后，剩下的人继续报数，可是第一圈出去的人仍然在数组里面，这样肯定会影响到编号的计算，一个方法就是出去的人的位置清0，比如第一次出去的是arr[2]，那么arr[2]的值就变成0，下一次计算的时候忽略掉这个标记的位置。 如果不用数组，整个遍历的过程就很容易想起来链表，退出的人则直接移除节点，剩下的人继续报数那么意思是最后一个人的next指针指向第一个人，这样就是符合题目的流程。注意循环结束的条件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;&quot; + getLive(6, 3)); &#125; private static int getLive(int n, int m) &#123; if (n == 1) &#123; return 1; &#125; if (m == 1) &#123; return n; &#125; Node head = new Node(0); Node temp = head; for (int i = 1; i &lt; n; i++) &#123; Node node = new Node(i); temp.next = node; temp = node; &#125; temp.next = head; Node current = head; Node prev = null; int i = 1; while (current.next != current) &#123; if (i == m) &#123; //报数到m的时候，移除这个节点 removeNode(prev, current); i = 0; &#125; prev = current; current = current.next; i++; &#125; System.out.println(); return current.data + 1; &#125; private static void removeNode(Node prev, Node current) &#123; System.out.print(&quot; removeNode &quot; + current.data); prev.next = current.next; current = null; &#125; static class Node &#123; int data; Node next; public Node(int data) &#123; this.data = data; &#125; &#125;&#125; 下面是数学上的解法，我们假设有5个人参与，每报3则出列，具体的过程如下： 1 12345 – 3出列，从4号继续开始报数 2 4512 – 1出列，从2继续开始报数 3 245 – 5出列，24继续报数 4 24 – 2出列，剩下一个4 5 4 n个人参与的时候，出列一个人，剩下的n-1继续构成新的约瑟夫环，因此n个人的问题最后肯定可以递归的转化成1个人的问题，最后这个人在1个人的情况下就是最后生存的人，它此时的编号是1，问题是这最后一个人的在n人环里面的编号是多少？ 观察上面的步骤，5个人的约瑟夫环，3出列后，让4号做开头，重新构成的新的4个人的环，它们有这样一个对应关系， 5人环里面的编号4的那个人，变成了4人环里面编号1的人 5人环里面的编号5的那个人，变成了4人环里面编号2的人 5人环里面的编号1的那个人，变成了4人环里面编号3的人 基于这个过程，我们可以做出这样一个推导f(5) = f(4) + 3 % 5,其中f(5)表示5人环里面的人的编号，f(4)表示4人环里面的人的编号，这个公式表示它们之间的对应关系。除5因为这是5人环。 同样的，我们也可以得出f(4) = (f(3) + 3) % 4，f(3) = (f(2) + 3) %3，f(2) =( f(1) + 3)%2，f(1) = 1 ; 在1人的情况下，生存的是人编号一定是1， 2人的时候，它对应的编号是 1+3 % 2 = 2 3个人的时候，生存的人对应的编号是2+3%3 = 2 … n个人的时候，对应的是f(n) = f(n-1) + 3 % n, 我们把m带入进去，f(n) = (f(n-1) + m) % n 123456789101112131415161718static int joseph(int n, int m) &#123; if (n == 1) &#123; return 1; &#125; if (m == 1) &#123; return n; &#125; int s = 1; //n=1的时候的值 for (int i = 2; i &lt; n+1; i++) &#123; //一直循环到 i = n ，就是n个人的时候的编号 s = (s + m) % i; if (s == 0) &#123; //编号没有0，修正为n s = i; &#125; &#125; return s;&#125; 结果与上面相同。","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"Android消息队列和链表","slug":"Android消息队列和链表","date":"2017-11-19T15:07:06.000Z","updated":"2018-11-05T14:16:05.737Z","comments":true,"path":"2017/11/19/Android消息队列和链表/","link":"","permalink":"http://example.com/2017/11/19/Android%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8/","excerpt":"链表是很常用的数据结构，JDK已经提供了LinkedList，也就是双向链表。今天写了个单链表，主要是想写一下单链表的逆置：","text":"链表是很常用的数据结构，JDK已经提供了LinkedList，也就是双向链表。今天写了个单链表，主要是想写一下单链表的逆置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public class MyList&lt;E&gt; implements MyListInterface&lt;E&gt; &#123; private Node&lt;E&gt; first; private Node&lt;E&gt; last; //用于添加到尾节点 private int size; @Override public void add(E e) &#123; linkInLast(new Node&lt;&gt;(e, null)); &#125; @Override public void add(int index, E e) &#123; Node temp = first; Node prev = null; for (int i = 0; i &lt; index; i++) &#123; prev = temp; temp = temp.next; &#125; Node&lt;E&gt; node = new Node&lt;&gt;(e, null); link(prev, node); &#125; private void link(Node&lt;E&gt; prev, Node&lt;E&gt; current) &#123; if (prev == null) &#123; linkInFirst(current); &#125; else if (current.next == null) &#123; linkInLast(current); &#125; else &#123; current.next = prev.next; prev.next = current; size++; &#125; &#125; private void linkInFirst(Node&lt;E&gt; node) &#123; if (first == null) &#123; first = node; last = node; &#125; else &#123; node.next = first; first = node; &#125; size++; &#125; private void linkInLast(Node&lt;E&gt; node) &#123; if (last == null) &#123; first = node; last = node; &#125; else &#123; last.next = node; last = node; &#125; size++; &#125; @Override public void remove(E e) &#123; Node temp = first; Node prev = null; while ((temp != null)) &#123; if (temp.data.equals(e)) &#123; unlink(prev, temp); &#125; prev = temp; temp = temp.next; &#125; &#125; private void unlink(Node&lt;E&gt; prev, Node&lt;E&gt; current) &#123; if (prev == null) &#123; //说明要删掉的节点是头结点 first = current.next; &#125; else if (current.next == null) &#123; //说明要删掉的节点是尾节点 prev.next = null; last = prev; &#125; else &#123; prev.next = current.next; &#125; current.data = null; size--; if (size == 0) &#123; first = last = null; &#125; &#125; @Override public boolean contains(E e) &#123; return (indexOf(e) != -1); &#125; public int indexOf(E e) &#123; int index = 0; Node temp = first; while ((temp != null)) &#123; if (temp.data.equals(e)) &#123; return index; &#125; temp = temp.next; index++; &#125; return -1; &#125; @Override public int size() &#123; return size; &#125; public void print() &#123; Node temp = first; if (first != null) &#123; System.out.print(&quot;first.data : &quot; + first.data); &#125; else &#123; System.out.print(&quot;first : null &quot;); &#125; if (last != null) &#123; System.out.print(&quot;,last.data : &quot; + last.data); &#125; else &#123; System.out.print(&quot;,last : null &quot;); &#125; System.out.print(&quot;, size = &quot; + size()); System.out.print(&quot;, list: &quot;); while ((temp != null)) &#123; System.out.print(temp.data); System.out.print(&quot; &quot;); temp = temp.next; &#125; System.out.println(); &#125; public void reverse() &#123; if (size == 0 || size == 1) &#123; return; &#125; if (size == 2) &#123; last.next = first; first.next = null; first = last; last = first.next; &#125; else &#123; last = first; Node current = first; Node prev = null; Node next = current.next; while (next != null) &#123; //实际的操作就这一步，然后就是不停的循环赋值了 current.next = prev; prev = current; current = next; next = next.next; &#125; current.next = prev; first = current; &#125; &#125; private static class Node&lt;E&gt; &#123; E data; Node next; public Node(E e, Node next) &#123; this.data = e; this.next = next; &#125; &#125;&#125; 不过在网上看了下，好像别人实现的都是一个Node类不停next就完了，我这里还写了个List类感觉有点格格不入。。Android里面在MessageQueue和Message类里面都有用到链表: MessageQueue::mMessages 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class MessageQueue &#123; ... //链表的头节点 Message mMessages; private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;(); ... Message next() &#123; ... synchronized (this) &#123; ... Message msg = mMessages; ... if (msg != null) &#123; ... //链表取节点操作 mMessages = msg.next; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; ... &#125; &#125; ... boolean enqueueMessage(Message msg, long when) &#123; ... synchronized (this) &#123; ... msg.markInUse(); msg.when = when; Message p = mMessages; ... if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. //如果mMessages为空，那么新发送的这个消息就成为头结点 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; //否则根据时间找个合适的位置插入到链表中 msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; Message类里面也有类似的成员变量 Message::sPool 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public final class Message implements Parcelable &#123; ... // sometimes we store linked lists of these things //链表节点定义 /*package*/ Message next; private static final Object sPoolSync = new Object(); //这是一个静态成员变量，用于指示消息池里面的消息链表的头指针 private static Message sPool; private static int sPoolSize = 0; private static final int MAX_POOL_SIZE = 50; private static boolean gCheckRecycle = true; /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. 取出消息时，取出sPool所指向的那个消息 */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; //由MessageQueue调用，回收消息加入到消息池 void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; //sPool是一个头节点 //回收时，设置自己的next节点为sPool所指向的节点，然后把自己成为新的sPool synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 我到底想说啥……","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"Java虚拟机-GC相关","slug":"Java虚拟机-GC相关","date":"2017-11-18T06:59:47.000Z","updated":"2021-01-24T09:24:05.426Z","comments":true,"path":"2017/11/18/Java虚拟机-GC相关/","link":"","permalink":"http://example.com/2017/11/18/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-GC%E7%9B%B8%E5%85%B3/","excerpt":"来源：《深入理解Java虚拟机(第2版)》 通常来说，人们会把Java和垃圾收集器(GC)绑定在一起，事实上GC的历史比Java要更久远。GC一般需要完成三件事： 哪些内存需要回收 什么时候进行回收 怎么回收 对于Java来说， 程序计数器，虚拟机栈，本地方法栈3个区域，因为它们都是线程私有的，线程结束了它们也就回收了，而栈的栈帧随着方法的调用有序的执行入栈和出栈的操作，因此方法结束时，这部分也回收了； Java堆和方法区，这部分的内存分配和回收都是动态的，不确定的，因此也是GC所关注的区域。","text":"来源：《深入理解Java虚拟机(第2版)》 通常来说，人们会把Java和垃圾收集器(GC)绑定在一起，事实上GC的历史比Java要更久远。GC一般需要完成三件事： 哪些内存需要回收 什么时候进行回收 怎么回收 对于Java来说， 程序计数器，虚拟机栈，本地方法栈3个区域，因为它们都是线程私有的，线程结束了它们也就回收了，而栈的栈帧随着方法的调用有序的执行入栈和出栈的操作，因此方法结束时，这部分也回收了； Java堆和方法区，这部分的内存分配和回收都是动态的，不确定的，因此也是GC所关注的区域。 对象存活判定引用计数法简单的引用计数法是这样的：给对象添加一个引用计数器，引用时+1,失效时-1，计数器为0时则对象可以被回收。在实际应用中可能会更复杂一些，比如可以把引用分为多种类型（比如弱引用），根据不同类型引用的数量来决定不同的内存回收策略。目前来说，主流的Java虚拟机都没有采用引用计数法来管理内存，其中最主要的原因是解决对象间相互循环引用的问题会很复杂。 可达性分析基本思想是：通过GC Roots对象作为起点，从这些节点开始向下搜索，搜索的路径称为引用链。当一个对象到GC Roots没有任何引用链连接时，称这个对象不可达。Java中做为GCRoots的对象： a.虚拟机栈(栈桢中的本地变量表)中的引用的对象 b.方法区中的类静态属性引用的对象 c.方法区中的常量引用的对象 d.本地方法栈中JNI的引用的对象 Object 1234可达，567不可达 引用无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。 JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。 GC算法 标记-清除算法 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。 现代商业虚拟机多半采用这种收集算法来回收新生代。因为新生代中的对象大部分生存周期都很短，因此不需要按照1:1的比例来划分，而是将内存分为一块较大的Eden区和两块较小的Survivor区，每次使用Eden和一块Survivor区，回收的时候，将它们中还存活的对象复制到另外一块Survivor区上，然后清理掉Eden和刚才用过的Survivor区。HotSpot虚拟机默认的Eden和Survivor大小的比例是8：1，也就是说，新生代可用空间会90%，只有10%会用来保存。 标记-整理算法 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法 当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收 HotSpot实现枚举根节点枚举根节点面临的主要问题有两个： 可作为GC Roots的节点太多，主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了，这是典型的空间换时间的做法； GC停顿，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。 安全点 程序执行时并非在所有的地方都能停下来开始GC，只有在安全点是才能暂停，它的定义是： A point during program execution at which all GC roots are known and all heap object contents are consistent. From a global point of view, all threads must block at a safepoint before the GC can run. 在哪里设置安全点 安全点的设置既不能太少以至于让GC长时间等待，也不能太多以至于过分增大运行时的负荷 如何在GC发生时让所有的线程都停到安全点： 抢先式中断 GC发生时，直接把所有的线程中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。现在几乎没有虚拟机采用这种方式 主动式中断 GC需要中断线程的时候，仅仅简单的设置一个标志，让Java线程运行到safepoint的时候主动检查这个标志位，如果标志被设置，那么线程停顿，如果没有被设置，那么继续执行。 安全区域安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域的任何时间开始GC都是安全的。 当程序执行到safe region中的代码时，首先标识自己已经进入了safe region，当jvm要发起gc时，则可以不用管标识了这种状态的线程了。在线程要离开safe region时，它需要检查当前GC状态，如果不能离开就必须等待直到收到信号可以离开为止。 Safepoint机制保证了程序在执行的时候，在不太长的时间里就可以进入到GC的安全点，但是如果此时程序没有被分配时间，比如线程处于sleep或者block状态，则无法响应jvm的请求。这时候需要安全区域来解决，我们可以把安全区域看成是扩展了的安全点。 垃圾收集器不同的虚拟机会包含不同的垃圾收集器，在最新的Java 9 中，使用G1作为默认的收集器。 内存的回收和分配策略 对象优先在Eden分配 大多数情况下，对象在新生代的Eden区分配，当Eden区没有足够的空间分配时，虚拟机将发起一次GC，如果GC期间发现Survivor空间不够保存，此时会转移对象到老年代。 大对象直接进入老年代 大对象是指需要大量连续内存空间的Java对象，比如很长的字符串和数组，经常出现大对象容易导致内存还有不少空间时就触发垃圾收集以获取足够的连续空间； 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计数器，一次GC后，年龄加1，当Survivor中的对象经过多次gc时就会被转移到老年代中。 Minor GC 和 Full GC ： 新生代GC（Minor GC）：是指发生在新生代的GC，因为新生代对象朝生夕灭的特性，所以Minor GC发生的很频繁，回收速度也比较快 老年代GC（Major GC / Full GC）：是指发生在老年代的GC,此GC的速度一般会比Minor GC慢10倍以上 扩展阅读： http://blog.csdn.net/lqp276/article/details/52249438 http://blog.csdn.net/iter_zc/article/details/41847887 https://www.zhihu.com/question/29268019 https://www.zhihu.com/question/51914583/answer/128083814 呃，在面试里面被问到，哪些对象可以作为GC roots的对象，为什么它们可以作为gc roots对象？解释一下为什么Activity里面handler会导致内存泄露的问题,它们的gcRoot路径是什么样的？ 当时没有答出来…..以下是个人根据网上的一些资料的想法整理，不是答案： tracing gc的基本思路是，以当前存活的对象集为root，遍历出他们（引用）关联的所有对象（Heap中的对象），没有遍历到的对象即为非存活对象，这部分对象可以gc掉。这里的初始存活对象集就是GC Roots。 1.JAVA虚拟机栈中的本地变量引用对象； 2.方法区中静态变量引用的对象； 3.方法区中常量引用的对象； 4.本地方法栈中JNI引用的对象； 选择这些对象的依据是什么？ 当前栈帧中的引用型变量；静态变量引用的对象；本地方法栈JNI的引用对象，很明显是当前存活对象。所以他们比如是GC Roots的一部分。 https://www.zhihu.com/question/33093157 还有这里 作者：Accelerator链接：https://www.zhihu.com/question/50381439/answer/120846441来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 A garbage collection root is an object that is accessible from outside the heap. The following reasons make an object a GC root: 1.System Class———-Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .2.JNI Local———-Local variable in native code, such as user defined JNI code or JVM internal code.3.JNI Global———-Global variable in native code, such as user defined JNI code or JVM internal code.4.Thread Block———-Object referred to from a currently active thread block.Thread———-A started, but not stopped, thread.5.Busy Monitor———-Everything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.6.Java Local———-Local variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.7.Native Stack———-In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.7.Finalizable———-An object which is in a queue awaiting its finalizer to be run.8.Unfinalized———-An object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.9.Unreachable———-An object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.10.Java Stack Frame———-A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.11.Unknown———-An object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump. Activity和Handler之间会有泄露的场景是Handler作为一个内部类而不是静态内部类，因而持有了Activity的引用，所以即使Activity销毁了，这个handler也会有引用指向它，而handler自己在sendMessage的时候会把自己作为target设置到message里面去，因此message会持有handler的引用，而message又会被MessageQueue引用，所以在message没有被主线程处理的情况下，根据上面的第四条，可以得到这样一条gcRoots路径，因此GC不会回收掉Activity","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","permalink":"http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}]},{"title":"Android-贝塞尔曲线","slug":"Android-贝塞尔曲线","date":"2017-11-14T14:30:34.000Z","updated":"2018-11-05T14:15:02.380Z","comments":true,"path":"2017/11/14/Android-贝塞尔曲线/","link":"","permalink":"http://example.com/2017/11/14/Android-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/","excerpt":"贝塞尔曲线是在计算机图形学和相关领域内常用的一种参数曲线，它的主要应用有 生成光滑的曲线 动画 圆滑的字体，比如TrueType","text":"贝塞尔曲线是在计算机图形学和相关领域内常用的一种参数曲线，它的主要应用有 生成光滑的曲线 动画 圆滑的字体，比如TrueType 它由一系列控制点P0到PN组成(n=1时是一阶，n=2时是2阶,etc)，第一个和最后一个控制点总是曲线的终端节点，而中间的控制点通常不会出现在曲线上。 一阶贝塞尔曲线 它表示的点B随着t变化的位置如图所示： 二阶贝塞尔曲线 计算后得到： 它表示的点B随着t变化的位置如图所示 三阶贝塞尔曲线 资料来源于 https://en.wikipedia.org/wiki/B%C3%A9zier_curve Android 中的Path类可以直接绘制一阶到三阶的贝塞尔曲线，在onDraw(Canvas canvas) 方法中使用,其中start,endpoint分别表示起始点和终点，一般也叫做数据点，controlPoint则是中间的控制点: 绘制一阶贝塞尔曲线： 1canvas.drawLine(start.x,start.y,end.x,end.y); 绘制二阶贝塞尔曲线： 123mPath.moveTo(startPoint.x, startPoint.y);&#x2F;&#x2F;起点mPath.quadTo(controlPoint1.x, controlPoint1.y, endPoint.x, endPoint.y);canvas.drawPath(mPath, mPaint); 绘制三阶贝塞尔曲线： 123mPath.moveTo(startPoint.x, startPoint.y);&#x2F;&#x2F;起点mPath.cubicTo(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, endPoint.x, endPoint.y);canvas.drawPath(mPath, mPaint); 当我们知道不在一条直线上的三个或者以上固定的点的时候，就可以利用api绘制出一条曲线，不过大多数的情况下，这三个点的坐标通常不是固定的，因此就可以不断地绘制一段一段连接起来的光滑的曲线，连续绘制的时候，quadTo或者cubicTo的终点就是下一段的起点。 因为网上已经有很多的例子了，这次先看这里,建议下载源码到Android Studio里面去看，这里主要是分析一下源码 二阶模拟和三阶模拟 ： 没什么好说的，主要是基于控制点坐标的变化不断的重新绘制曲线，可以理解一下基础的变化。 圆滑绘图 : 里面的一段关键代码: case MotionEvent.ACTION_MOVE: float x1 = event.getX(); float y1 = event.getY(); float preX = mX; float preY = mY; float dx = Math.abs(x1 - preX); float dy = Math.abs(y1 - preY); if (dx &gt;= offset || dy &gt;= offset) &#123; // 贝塞尔曲线的控制点为起点和终点的中点 float cX = (x1 + preX) / 2; float cY = (y1 + preY) / 2; mPath.quadTo(preX, preY, cX, cY); mX = x1; mY = y1; &#125; 刚开始看的时候不是很理解为什么是mPath.quadTo(preX, preY, cX, cY)，明明注释里面说控制点是（cX, cY），我们假设在绘图的时候有下面这种情形 mPath.quadTo(preX, preY, cX, cY) 第一次调用是时候，起始点控制点终点分别是AAD,这样子画出来是AD直线，第二次调用的时候起始点控制点终点则变成了DBE，然后就是ECF，实际上是以各个线段的中点作为数据点绘制的，这样子就把折线的角度改成了圆滑的曲线。 曲线变形 这里用到了属性动画 1234567891011mAnimator &#x3D; ValueAnimator.ofFloat(mStartPointY, (float) h); mAnimator.setInterpolator(new BounceInterpolator()); mAnimator.setDuration(1000); mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; mAuxiliaryOneY &#x3D; (float) valueAnimator.getAnimatedValue(); mAuxiliaryTwoY &#x3D; (float) valueAnimator.getAnimatedValue(); invalidate(); &#125; &#125;); 从起点mStartPointY到屏幕底部h的一段属性动画，利用动画中y值的变化更新控制点的坐标 波浪动画 这里有个更详细的版本，对于 12345678910111213141516@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPath.reset(); mPath.moveTo(-mWaveLength + mOffset, mCenterY); for (int i &#x3D; 0; i &lt; mWaveCount; i++) &#123; &#x2F;&#x2F; + (i * mWaveLength) &#x2F;&#x2F; + mOffset mPath.quadTo((-mWaveLength * 3 &#x2F; 4) + (i * mWaveLength) + mOffset, mCenterY + 60, (-mWaveLength &#x2F; 2) + (i * mWaveLength) + mOffset, mCenterY); mPath.quadTo((-mWaveLength &#x2F; 4) + (i * mWaveLength) + mOffset, mCenterY - 60, i * mWaveLength + mOffset, mCenterY); &#125; mPath.lineTo(mScreenWidth, mScreenHeight); mPath.lineTo(0, mScreenHeight); mPath.close(); canvas.drawPath(mPath, mPaint); &#125; mPath.quadTo这个方法里面，需要明确的是虽然i是变化的，但实际上offset不变的时候，绘制出来的就是一条固定形状的曲线。从屏幕外面的左边一直绘制到屏幕外面的右边，当offset随着属性动画变化的时候，mPath.quadTo绘制的所需要的起始点控制点终点的x坐标都在以相同的大小增加，这样绘制出来的曲线也会随着平移，去除掉屏幕外面的部分，屏幕内显示的就是波浪动画了。 路径动画 这里算是真真正正用到了上面所提到的B(t)的求值公式。主要是重写了估值器， 12345678910111213public class BezierEvaluator implements TypeEvaluator&lt;PointF&gt; &#123; private PointF mControlPoint; public BezierEvaluator(PointF controlPoint) &#123; this.mControlPoint &#x3D; controlPoint; &#125; @Override public PointF evaluate(float t, PointF startValue, PointF endValue) &#123; return BezierUtil.CalculateBezierPointForQuadratic(t, startValue, mControlPoint, endValue); &#125;&#125; 其中3个控制点都固定了位置，正好插值器传过来的t的值[0,1]，根据上面所提到的二阶贝塞尔的公式，就可以得到曲线上的点B(t)的值，然后返回给valueAnimator.getAnimatedValue()，把这个点变化的过程绘制出来就是贝塞尔曲线了。当把固定的小球，曲线都不绘制出来的时候，视觉效果就出来了。 切线拟合 纯数学。两个圆通过属性动画已经画出来，主要是一个圆的坐标变化导致的连接块的范围变化。 实现了两个简单的动画效果： 这个动画主要用到的知识是用四段三阶贝塞尔曲线去画一个圆，在这里和这里给出了绘制的思路,圆画出来之后，就是常规的改变控制点的位置来重绘曲线了，虽然这个动画挺简单的，不过三阶曲线去拟合一个圆，这个思路在后面很多的地方都会用到。 然后是这样一个心型上升动画 用来练练手。其实就是一个起点固定，两个控制点和终点都不固定的三阶贝塞尔曲线，不过需要注意的是因为添加了view，动画结束后需要remove掉。 代码上传到了github 感谢： https://en.wikipedia.org/wiki/B%C3%A9zier_curve https://github.com/xuyisheng/BezierArt http://blog.csdn.net/eclipsexys/article/details/51956908 http://blog.csdn.net/IT_XF/article/details/75014160","categories":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}],"tags":[{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://example.com/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"}],"keywords":[{"name":"android_app","slug":"android-app","permalink":"http://example.com/categories/android-app/"}]},{"title":"博客终于搭建起来啦","slug":"博客终于搭建起来啦","date":"2017-11-14T02:20:27.000Z","updated":"2018-08-20T14:18:20.967Z","comments":true,"path":"2017/11/14/博客终于搭建起来啦/","link":"","permalink":"http://example.com/2017/11/14/%E5%8D%9A%E5%AE%A2%E7%BB%88%E4%BA%8E%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%9D%A5%E5%95%A6/","excerpt":"心心念念好多年的个人博客终于弄出来了，到真正弄的时候才发现只花了半天就搭建好了，网上太多的参考资料，比如这个,然后是这个。","text":"心心念念好多年的个人博客终于弄出来了，到真正弄的时候才发现只花了半天就搭建好了，网上太多的参考资料，比如这个,然后是这个。其实之前曾经帮人做一个VB作业的时候接触过IIS，那时候用IIS弄了个可以通过IP访问的地址，现在这个也算是更进一步。目前是Hexo+next+github的方案，优点是简单迅速免费。不过现在评论，统计模块都还没有加上去，也还没有买域名，这些问题看上去也是遥遥无期。 不知道这里会不会有人看到，如果你也想搭博客的话也可以尝试一下。Hexo是一个基于Node.js的博客框架，如果你和我一样什么都不懂也不要紧，只要知道需要安装Node.js和安装Hexo就行了，然后hexo的操作方式就是打开一个命令行，类似于git一样，但是常用命令也就个位数。next则是一个Hexo的主题，github地址在这里,命令行一键安装，github则不需要介绍了吧。说了这么多其实就是一个意思，很简单，可以试试。 之前工作的时候其实也有很多次心动的时候，还热血来潮的想要翻译Gradle文档，翻译了两篇之后就躺在github的角落里了。。那时候的笔记本真的很烂，烂到不想开机。其实有时候完美主义挺要命的，对环境有点不满意就没有热情去做事情的性格，因为笔记本不行，然后赶上加班，就痛痛快快的放弃了庞大的翻译计划。。。。也曾经在cnblogs上写过一篇jni和java交互流程的文章，现在都忘了地址了…..回想起来那时候放弃是因为觉得才工作不久，写的不怎么样，以免误导别人。现在虽然也没有进步多少，新电脑给我加了buff！花了钱就不能亏本 -_- 。。。 之所以有空做这个，也是因为最近比较闲，而且刚刚买了个新的笔记本电脑，让人有开机的欲望，开机了总得找点事情做。目前的计划的话，可能会把onenote里面的笔记复制一些到这里来，也有可能另外写，总之既然期待了这么久就没有中途而废的理由啦。 Hexo相关命令总结 : 12345678910111213hexo clean #清除缓存hexo g #保存修改，生成文件hexo s #启动本地服务hexo d #发布到远程hexo init #生成站点hexo new page &quot;xxx&quot; #生成页面hexo new &quot;&quot; #生成文章 hexo升级 : npm outdated 修改 package.json npm install --save","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[],"keywords":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}]}]}